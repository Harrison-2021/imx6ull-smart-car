# 一、光环境传感器硬件原理图分析
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e8c63c6f471841dda6bbaa1aa5dfc41b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b177d4cdbaac424580de71eacd21722b.png)
# 二、IMX6ull IIC控制器介绍
- The Inter IC (I2C) provides functionality of a `standard I2C slave and master`. The I2C is designed to be `compatible with the standard NXP I2C bus protocol`.

	- >I2C提供标准I2C从站和主站的功能。I2C被设计为**与标准NXP I2C总线协议兼容**。

- I2C is a `two-wire`, `bidirectional serial bus` that provides a simple, efficient method of data exchange, minimizing the interconnection between devices. This bus is suitable for applications requiring `occasional communications` over a `short distance` between many devices. The flexible I2C standard allows `additional devices` to be connected to the bus for `expansion and system development`.

	- >I2C是一种==双线双向串行总线==，它提供了一种简单、高效的数据交换方法，最大限度地减少了设备之间的互连。这种总线适用于需要在==许多设备==之间进行==短距离,偶尔通信==的应用。灵活的I2C标准允许**将其他设备连接到总线以进行扩展和系统开发。**

## 1.IIC控制器设计
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/471f1598444a49999521eccf8a29d236.png)
## 2.Clocks
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/aaf7851bf11b4dbaadcbcaf327e643c2.png)
- ==Peripheral clock==: This clock is used for peripheral bus register read/writes. (外围时钟：该时钟用于外围总线寄存器读/写)
- ==Module clock==: This is the `functional clock` of the I2C. **The serial bit clock frequency is derived from the module clock**. ==The module clock and peripheral clocks are synchronous with each other==. The minimum frequency of the module clock should be 12.8 MHz for Fast mode to achieve 400-kbps operation.
	- >(模块时钟：这是I2C的功能时钟。==串行位时钟频（SCL频率）率来自模块时钟==。模块时钟和外围时钟相互同步。快速模式下模块时钟的最小频率应为12.8 MHz，以实现400 kbps操作)
	
	- >==传感器的时钟频率为400KHZ,而芯片ipg_clock为66MHZ,因此需要转换==
	![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ba330f25a7cd47ab9cb893b9b7724d35.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/08207803e97e47febce412a958d00b51.png)
	- >【传输速率与时钟频率的关系】传输速率=时钟频率X数据位宽举例：100Mbps传输速率下，数据位宽为4位，时钟频率即为25MHZ。PS：HZ和bit/s是一个相同的概念。1个时钟脉冲只能传输1bit数据，时钟周期为1HZ，则传输数据的速率为1bit/s；时钟周期为100KHZ，则传输数据的速率为100kbit/s。：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3d8e7165f556448bb67a20b7619d8275.png)
## 3.Arbitration procedure
- If multiple devices `simultaneously` request the bus, the bus clock is determined by a synchronization procedure in which the `low period` equals the `longest clock`-low period among the devices, and the `high period` equals the `shortest`. A data arbitration procedure determines the `relative priority` of competing devices.

	- >如果多个设备同时请求总线，则总线时钟由同步过程确定，其中==低周期等于设备之间最长的时钟低周期，高周期等于最短的==。数据仲裁过程确定竞争设备的相对优先级。
	- >即，==根据请求SCL总线的高低电平持续时间==，==与门==，低电平0，所以低电平周期以持续时间长的为标准，同理，高电平1，以短周期为标准，因为长周期的被0拉低了

- A device `loses arbitration if it sends logic high while another sends logic low`; it immediately `switches to Slave Receive mode` and `stops driving I2Cn_SDA`. In this case, **the transition from master to Slave mode does not generate a Stop condition**. Meanwhile, hardware sets the arbitration lost bit in the `I2C Status register (I2C_I2SR[IAL] `to indicate loss of arbitration).

	- >如果==设备发送逻辑高电平而另一个发送逻辑低电平，则设备将失去仲裁==；它会立即切换到从属接收模式并停止驱动I2Cn_SDA。在这种情况下，从主模式到从属模式的转换不会生成停止条件。同时，硬件会在I2C状态寄存器中设置仲裁丢失位（`I2C_I2SR[IAL]`以指示仲裁丢失）。

## 4.Initialization sequence
Before the interface can transfer serial data, `registers must be initialized`, as listed here. (在接口可以传输串行数据之前，必须初始化寄存器，如下所示)

- \1. `Set the data sampling rate`(`I2C_IFDR[IC]` to obtain ==SCL frequency== from the system bus clock(设置数据采样率（I2C_IFDR[IC]，从系统总线时钟获取SCL频率).

- \2. `Update the address` in the (`I2C_IADR`) to define its slave address (address can range from 0 to 0x7f). (更新（I2C_IADR）中的地址以定义其从属地址（地址范围可以从0到0x7f）)

- \3. `Set the I2C enable bit` (`I2C_I2CR[IEN]`) to enable the I2C bus interface system. (设置I2C使能位（I2C_I2CR[IEN]）使能I2C总线接口系统)

- \4. `Modify the bits` in the` I2C_I2CR` to select ==Master/Slave mode==, ==Transmit/Receive mode==, and ==Interrupt-Enable or not==.(修改I2C_I2CR中的位以选择主/从模式、发送/接收模式和中断-启用与否)
## 5.Generation of Start
- After completion of the initialization procedure, serial data can be transmitted by `selecting the Master Transmit mode.` On a multimaster bus system, the busy bus (`I2C_I2SR[IBB]`) must be `tested` to determine `whether the serial bus is free`. If the bus is free (`IBB = 0`), the Start signal and the first byte (the slave address) can be sent. The data written to the data register `comprises` the `address of the desired slave` and the `LSB indicates the transfer direction`.

	- >在完成初始化程序后，可以通过**选择主传输模式来传输串行数据**。在多主总线系统上，必须**测试繁忙总线（I2C_I2SR[IBB]）以确定串行总线是否空闲**。如果总线空闲（IBB=0），则可以发送Start信号和第一个字节（从属地址）。**写入数据寄存器的数据包括所需从属的地址，LSB指示传输方向。**

- The free time between a Stop and the next Start condition is built into the hardware that generates the `Start cycle`. Depending on the `relative frequencies` of the `system clock` and the `SCL period`, it may be necessary to wait until the I2C is not busy after writing the `calling address` to the `data register (I2C_I2DR)`, before proceeding to `load data into the data register (I2C_I2DR)`.

	- >停止和下一个开始条件之间的空闲时间内置在生成开始周期的硬件中。根据系统时钟和SCL周期的相对频率，**在将调用地址写入数据寄存器（I2C_I2DR）后**，**可能需要等到I2C不忙的时候，然后再将数据加载到数据寄存器（I2C_I2DR）中**。

## 6.Generation of Stop
- A data transfer ends when the `master signals a Stop`, which can occur `after all data is sent`. For a master receiver to terminate a data transfer, it must `inform the slave transmitter by not acknowledging the last data byte`. This is done by `setting the transmit acknowledge bit `(`I2C_I2CR[TXAK]`) **before reading the next-to-last byte**. ==Before the last byte is read, a Stop signal must be generated.==

	- >数据搬迁结束时，主站发出停止信号，这可能发生在所有数据发送后。对于主接收器终止数据搬迁，==它必须通过不确认最后一个数据字节来通知从站发送器==。这是通过在读取倒数第二个字节之前设置传输确认位（I2C_I2CR[TXAK]）来完成的。==在读取最后一个字节之前，必须生成停止信号。==,（**即，一旦读取最后一个字节完成后，就结束传输，这是通过寄存器实现，与GPIO模拟信号发送不同，GPIO模拟是在传输最后一个字节数据后，主动发送一个NACK信号**）

## 7.Generation of Repeated Start
- After the data transfer, if the master still requires the bus, it can signal `another Start followed by another slave address without signaling a Stop.`

	- >数据搬迁后，如果主站仍然需要总线，**它可以发出另一个开始信号，然后是另一个从站地址，而不会发出停止信号。**

## 8.Post-transfer software response
- **Sending or receiving a byte sets the data transferring bit** (`I2C_I2SR[ICF]`), which indicates one byte of communication is finished. Upon completion, the `interrupt status` (`I2C_I2SR[IIF]`) is also set. An external interrupt is generated **if the interrupt enable (`I2C_I2CR[IIEN]`) is set.** `The software must first clear the interrupt status` (`I2C_I2SR[IIF]`) in the `interrupt routine`.

	- >发送或接收一个字节设置数据传输位（I2C_I2SR[ICF]），表示一个字节的通信完成。完成后，还设置中断状态（I2C_I2SR[IIF]）。**如果设置了中断使能（I2C_I2CR[IIEN]），则会生成外部中断。软件必须首先清除中断例程中的中断状态（I2C_I2SR[IIF]）**。

- The data transferring bit (I2C_I2SR[ICF]) `is cleared either by reading from I2C_I2DR in Receive mode or by writing to this register in Transmit mode`.

	- >**数据传输位（I2C_I2SR[ICF]）通过在接收模式下从I2C_I2DR读取或在传输模式下写入该寄存器来清除**。(即，==下次读取或写入时，会自当清除状态位==）
# 三、IIC控制器重点寄存器介绍
## 1.I2C Frequency Divider Register (`I2Cx_IFDR`)
- The I2C_IFDR provides a programmable `prescaler` to configure the clock for `bit-rate selection`. ==The register does not get reset by a software reset==.

	- >I2C_IFDR提供了一个可编程的**预分频器**来配置时钟以进行比特率选择。==寄存器不会被软件复位复位==。

**I2C clock Frequency = (PERCLK_ROOT frequency)/(division factor corresponding to IFDR)**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f7bfe793384745d29ce1ff76dbf1d4a2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/62bb7bebdc184807b14d71e0eb5e02ff.png)
## 2.I2C Control Register (`I2Cx_I2CR`)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1576eb3c37cf4e1893d15658085a3da3.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/67e42d4385ca45b69205883c92866295.png)
## 3.I2C Status Register (`I2Cx_I2SR`)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b654a6307f1f40ee9b2cf20c7981068d.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1811c92fb7f74b3fa62644b04f428654.png)
## 4.I2C Data I/O Register (I2Cx_I2DR)
- In Master Receive mode, **reading the data register allows a read to occur and initiates the next byte to be received**. In Slave mode, the same function is available after it is addressed.

	- >在主接收模式下，**读取数据寄存器允许读取发生并启动要接收的下一个字节**。在从属模式下，相同的功能在寻址后可用。
	- >即，==为了读取寄存器中的数据，需要先读取寄存器，触发寄存器放入数据，下次再读取寄存器中的数据==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/495482be774b4a989c27e3fd4c9f5ef0.png)
# 四、IMX6ull IIC控制器操作
## 1.管脚初始化
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b177d4cdbaac424580de71eacd21722b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0fed87346dc5413b83c68f4812377bae.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4afa830fdc1345d0a36344aef98feb61.png)

```c
void iic1_pin_init() {
    // SCL
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 |= (0x2 << 0);

    // SDA
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO29 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO29 |= (0x2 << 0);

}
```
## 2.控制器初始化
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/249e965a49a04235a5bcd44925429741.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f7bfe793384745d29ce1ff76dbf1d4a2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/62bb7bebdc184807b14d71e0eb5e02ff.png)

```c
/* iic_control init*/
void iic_con_init(I2C_Type* base) {
    // I2C enable
    base->I2CR &= ~(1 << 7);

    /* target: <400kHZ, ~= 100KHZ
       clocks : 66MHZ --> div:660
    */
    // base->IFDR &= ~(0x1f << 0);
    // base->IFDR |= (0x15 << 0);
    // 15-6:read-only,always has the value 0
    base->IFDR = 0x15;  

    // I2C enable
    base->I2CR |= (1 << 7);
}
```

## 3.产生开始信号
> 注意：==发送开始信号前，先清除中断标志==，防止中断期间，无法执行开始信号
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/792f064f6c1445dc846f2423a686fc53.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/505a5831c20648028cdfcb51856b2b75.png)

```c
/* iic_control start signal*/
void iic_con_start(I2C_Type* base) {
    // clear interrupt, 防止中断期间，无法执行开始信号
    base->I2SR &= ~(1 << 1);

    // start signal
    base->I2CR &= ~(1 << 5);
    base->I2SR |= (1 << 5);
}

/* iic_control restart signal*/
void iic_con_restart(I2C_Type* base) {
    // clear interrupt, 防止中断期间，无法执行开始信号
    base->I2SR &= ~(1 << 1);

    // start signal
    base->I2SR |= (1 << 2);
}
```
## 4.发送从机地址和读写位
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/495482be774b4a989c27e3fd4c9f5ef0.png)
> 注意：向数据寄存器发送数据后，==要判断是否发送完毕，可以通过中断标志位来验证==，当发送完毕后，会产生中断
> 判断后，要将中断位清除，以免对后续其它操作产生影响
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/792f064f6c1445dc846f2423a686fc53.png)

> 因要发送数据，==可以初始化master 模式，为发送模式==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7b7704cb22af4e76a032e9f86bd1a6db.png)

```c
/* send slave addr + write/read*/ 
void iic_con_send_slave_addr(I2C_Type* base, uint8_t slave_rw) {
    int flag = 0;
    //master transmit mode
    base->I2CR |= (1 << 4);
    // send data
    base->I2DR = slave_rw;

    // check send finish
    do {
        flag = base->I2CR & (1 << 1);
    } while(!flag);

    // clear interrupt
    base->I2CR &= ~(1 << 1);
    
```
## 5.产生结束信号
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/34ca9ca959cd43d4aacfab70be140890.png)
> 与开始信号类似，==要先置为1，再置为0，从1到0的跳变，产生结束信号==

```c
/* send stop signal*/
void iic_con_stop(I2C_Type* base) {
	// 延时一点时间，等待NACK/ACK信号完成，才能停止
	gpt_delay_ms(10);
    base->I2SR &= ~(1 << 1);

    base->I2CR |= (1 << 5);
    base->I2CR &= ~(1 << 5);
}
```
## 6.读写数据
> IIC通信介绍
同步串行半双工通信
==同步==：带时钟线，==发送方和接收方的时钟信号保持同步==

>==串行==：==比特按照一个一个按顺序进行传输，而不是同时传输多个比特==。
>1.GPIO模拟时，写入1bit位后，要延时一点时间等待从机读。
>2.IIC内置控制器中，写入8bit到I2DR中后，从机同步接收，当从机接收到1byte字节数据后，会发送ACK,这是一次完整的数据传输，
>3.即当第9个bit位从高拉到低时，即从机发送ACK后，会产生一个中断，主机根据是否有中断，判断是否发送下个字节数据，从机根据是否有中断，判断是否接收数据成功。

>半双工：数据可以在两个设备之间进行双向传输，但不能同时进行双向传输。

```c
/* send data*/
void iic_con_send_data(I2C_Type* base, uint8_t* buf, uint32_t size) {
    int i;
    int flag = 0;
    // master transmit mode
    base->I2CR |= (1 << 4);

    for(i = 0; i < size; i++) {
        // send data
        base->I2DR = buf[i];

        // check send finish(receive success)
        do {
            flag = base->I2SR & (1 << 1);
        } while(!flag);

        // clear interrupt, iic start work
        base->I2SR &= ~(1 << 1);
    }
}

/* read data*/
void iic_con_read_data(I2C_Type* base, uint8_t* buf, uint32_t size) {
    int i;
    int flag = 0;
    uint8_t dummy;

    // mode : receive
    // ACK is sent(auto)
    base->I2CR &= ~((1 << 4) | (1 << 3));

    // dummy data
    dummy = base->I2DR;

    for(i = 0; i < size; i++) {
        if(i == size -1) base->I2CR |= (1 << 3); // NACK
        // wait one byte transfer is completed
        do {
            flag = base->I2SR & (1 << 1);
        } while(!flag);
        // read data
        buf[i] = base->I2DR;
        // clear interrupt, iic start work
        base->I2SR &= ~(1 << 1);
    }
}
```
# 五、IMX6ull IIC控制器读取光环境传感器数据
## 1.初始化管脚和I2C控制器

```c
/* init iic pin and controller*/
void hardware_ltr_553als_init() {
    iic1_pin_init();
    iic_con_init(I2C1);
}
```
## 2.编写传感器内部寄存器写函数接口

```c
/* write register*/
void hardware_ltr_5553als_write_register(uint8_t regaddr, uint8_t regvl) {
    uint8_t tx_buf[] = {regaddr, regvl};
    // 1.start signal
    iic_con_start(I2C1);

    // 2.write slave address + write bit
    // auto wait ACK(interrupt)
    iic_con_send_slave_addr(I2C1, LTC_ADR_WRITE);

    // 3.write register addr and command
    iic_con_send_data(I2C1, tx_buf, sizeof(tx_buf));

    // 4.stop signal
    iic_con_stop(I2C1);

}
```
## 3.编写传感器内部寄存器读函数接口

```c
/* read register*/
uint8_t hardware_ltr_5553als_read_register(uint8_t regaddr) {
    uint8_t tx_buf[] = {regaddr};
    uint8_t rx_buf[1];
    // 1.start signal
    iic_con_start(I2C1);

    // 2.write slave address + write bit
    iic_con_send_slave_addr(I2C1, LTC_ADR_WRITE);

    // 3.write register
    iic_con_send_data(I2C1, tx_buf, sizeof(tx_buf));

    // 4.restart
    iic_con_restart(I2C1);

    // 5.write slave addr + read bit
    iic_con_send_slave_addr(I2C1, LTC_ADR_READ);

    // 6.read data
    iic_con_read_data(I2C1, rx_buf, sizeof(rx_buf));

    // 7.stop signal
    iic_con_stop(I2C1);

    return rx_buf[0];
}
```

## 4.测试读取传感器ID
> ==注意点：对寄存器的操作位要细心，例如0xf不要误写成0xff,多清理一些位，会产生错误==
> // SCL
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 |= (0x2 << 0);
```c
/* 测试读取光传感器厂家ID*/
void hardware_read_ltr_553als_manufac_id() {
    uint8_t manufac_id;
    // init
    hardware_ltr_553als_init();

    // read id
    manufac_id = hardware_ltr_5553als_read_register(LTC_MANUFAC_ADR);
    uart_printf("manufac ID : %#x\r\n",manufac_id);
}

void hardware_iic_test() {
    while(1) {
        hardware_read_ltr_553als_manufac_id();
        gpt_delay_sec(1);
    }
}
```

### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f84a563aae264afb855d0cc1494d6413.png)
## 5.测试读取接近传感器与光线传感器值
> 注意点：==连续读取两次传感器值时，由于从设备反应时间不够，需要在两次读取时，延迟一点时间==，防止在中断等待ack值时产生错误，一直卡在中断处理地方

>  data[0] = hardware_ltr_5553als_read_register(LTC_PS_DATA0_REG_ADR);
    gpt_delay_ms(10); // wait ack
    data[1] = hardware_ltr_5553als_read_register(LTC_PS_DATA1_REG_ADR);
    gpt_delay_ms(10); // wait ack

```c
/* 测试读取接近传感器数据*/
void hardware_read_ltc_553als_ps_data() {
    uint16_t ps_data;
    uint8_t data[2];
    hardware_ltr_553als_init();
    // active mode
    hardware_ltr_5553als_write_register(LTC_PS_REG_ADR, 0x3);
    gpt_delay_ms(10);

    // read data from two register
    data[0] = hardware_ltr_5553als_read_register(LTC_PS_DATA0_REG_ADR);
    gpt_delay_ms(10); // wait ack
    data[1] = hardware_ltr_5553als_read_register(LTC_PS_DATA1_REG_ADR);
    gpt_delay_ms(10); // wait ack

    // join data
    ps_data = ((data[1] & 0x7) << 8) | data[0];
    uart_printf("ps data : %d\r\n",ps_data);
}

/* 测试读取光线传感器数据*/
void hardware_read_ltc_553als_als_data() {
    uint8_t low;
    uint8_t high;
    uint16_t channel[2];
    // init
    hardware_ltr_553als_init();
    // active
    hardware_ltr_5553als_write_register(LTC_ALS_REG_ADR, 0x1);
    gpt_delay_ms(10);

    // read data,ch1 first,ch2 second
    low = hardware_ltr_5553als_read_register(LTC_ALS_CH1_DATA0_REG_ADR);
    gpt_delay_ms(10); // wait ack
    high = hardware_ltr_5553als_read_register(LTC_ALS_CH1_DATA1_REG_ADR);
    gpt_delay_ms(10); // wait ack
    channel[1] = (high << 8) | low;
    uart_printf("CH1 DATA : %d\r\n", channel[1]);

    low = hardware_ltr_5553als_read_register(LTC_ALS_CH0_DATA0_REG_ADR);
    gpt_delay_ms(10); // wait ack
    high = hardware_ltr_5553als_read_register(LTC_ALS_CH0_DATA1_REG_ADR);
    gpt_delay_ms(10); // wait ack
    channel[0] = (high << 8) | low;
    uart_printf("CH0 DATA : %d\r\n", channel[0]);
}

void hardware_iic_test() {
    while(1) {
        hardware_read_ltr_553als_manufac_id();
        hardware_read_ltc_553als_ps_data();
        hardware_read_ltc_553als_als_data();
        gpt_delay_sec(1);
    }
}

```
### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cf7c0ee7f31547a09eba492a64a4be36.png)
