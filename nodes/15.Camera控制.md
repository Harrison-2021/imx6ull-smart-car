# <font color="#fd6f01">1.理论篇</font>

# 一、生活中的摄像头

![图片描述](https://img.mukewang.com/wiki/63f88e5509a9022f09720637.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88e81094ea17c10260267.jpg)

# 二、摄像头工作原理剖析

![图片描述](https://img.mukewang.com/wiki/63f88e9509c32a5a11360337.jpg)

摄像头工作原理:拍摄景物通过镜头(LENS)，**将生成的光学图像投射到传感器上**，**然后光学图像被转换成电信号，电信号再经过A/D(模数转换)变成数字信号**，**数字信号经过DSP加工处理**，再被送到手机处理器中进行处理，最终转换成手机屏幕上能够看到的图像。

![图片描述](https://img.mukewang.com/wiki/63f88eaa096760a007110353.jpg)

> CCD (Charge Couple Device) : 电荷耦合器件 CMOS (Complementary Metal Oxide Semiconductor):互补金属氧化物半导体

## 1.图像传感器(Sensor)

图像传感器：是一种半导体芯片，其表面包含有几十万到几百万个感光二极管，这些感光二极管受到照射时，就会产生电荷(光信号->电信号)

## 2.CCD和CMOS比较

![图片描述](https://img.mukewang.com/wiki/63f88ebb0980a61707110314.jpg)

## 3.ISP(Image Signal Processor)

**ISP(Image Signal Processor)即图像\**\**信号处理**， 主要作用是对前端图像传感器输出的信号做后期处理，依赖于 ISP 才能在不同的光学条件下都能较好的还原现场细节。

ISP一般用来处理Image Sensor（图像传感器）的输出数据，如做`AEC`（自动曝光控制）、`AGC`（自动增益控制）、`AWB`（自动白平衡）、色彩校正、`Gamma` 校正、`Auto Black Level`、`Auto White Level` 等等功能的处理。

### (1)AEC(Automatic Exposure Control)

AEC(Automatic Exposure Control)自动曝光；当外界光线较弱时, CMOS成像芯片工作电流较小,所成图像偏暗,这时要适当增加曝光时间进行背光补偿;光线充足或较强时,要适当减少曝光时间,防止曝光过度,图像发白。

### (2)AWB(Automatic White Balance)

AWB(Automatic White Balance) 自动白平衡；对色温环境所造成的颜色偏差和拍摄一起本身所固有的色彩通道增益的偏差进行统一补偿，从而让获得的图像能正确反映物体的真实色彩。

### (3)AGC(Automatic Gain Control)

AGC(Automatic Gain Control)自动增益控制；使放大电路的增益自动地随信号强度而增强的自动控制方法；当弱信号输入，线性放大电路工作；反之启动压缩放大电路。

### (4)色彩校正(Color Correction)

色彩校正(Color Correction)；颜色饱和度(Saturation)、亮度(Brightness)的调整;

### (5)ABL、AWL(Auto Black Level、Auto White Level)

ABL、AWL(Auto Black Level、Auto White Leve)自动黑、白电平;向上调节黑电平(**黑电平是指图像数据为0时对应的信号电平**)，图片将变暗；低于黑电平的像素会全部显示成黑色以遮盖暗场噪点；一般来说黑电平数值越低说明屏幕在暗场的显示效果越好。

### (6)Gamma 校正

Gamma矫正，原因是人眼睛的非线性特性，亮度发生变化时，人眼感受到的不是成倍的关系

## 4.DSP(Digital Signal Processing)

**DSP(Digital Signal Processing)**:通过一系列复杂的数学算法运算，对数字图像信号参数进行优化处理(**RGB/YUV->JPEG**),并把处理后的信号传输到存储或显示部件

# 三、Camera常用参数介绍

## **1.图像解析度/分辨率(Resolution)**

![图片描述](https://img.mukewang.com/wiki/63f88ed0092647a408550809.jpg)

## 2.**图像格式(imageFormat/Colorspace)**

像素格式，比如:RGB565，YUV4:2:2等。

## 3.**自动白平衡调整(AWB)**

白平衡指不管在任何光源下，都能将白色物体还原为白色。白平衡是描述显示器或相机中红、绿、蓝三基色混合生成后白色精确度的一项指标。

## 4.**色彩深度**

色彩深度在计算机图形学领域中表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多。现在市场上的摄像头均已达到24位，有的甚至是32位。

## 5.**图像噪音**

指的是图像中的杂点干扰。

## 6.**帧率**

帧率指的就是1秒钟时间里传输、显示图片的帧数，每一帧就是一个画面，快速连续的多帧就形成了运动的动态效果。高的帧率可以得到更加流畅，更加逼真的画面。

## 7.**码流**

码流(Data Rate)是指视频文件单位时间内使用的数据流量，也叫码率或码流率，单位是kb/s或者Mb/s。同样分辨率下，视频文件的码流越大，画面质量就越高。

## 8.**曝光**

曝光就是图像的明暗程度 ，照片太暗称为曝光不足 ，照片太亮称为曝光过度

# 四、Camera常用接口

Camera接口实在多种多样，总的来说分为三大类：**Parallel（并口）/DVP接口/CSI接口**、**Serial（\**\*\*串口\*\**\*）/MIPI-CSI2接口**以及**USB口**。

## 1.DVP接口

并口一般称**DVP接口(Digital Video Port)**，也称为**CSI(CMOS Sensor Interface)接口**,就是将图像信号按照8bit ,12bit等数据格式，在时钟的作用下，一次性传输8位或者12位，这种方式最大的特点就是需要的数据线较多，时钟PCLK极限约在96MHZ左右，且走线长度不能过长，所以DVP的最大速率最好控制在72M以下。
![图片描述](https://img.mukewang.com/wiki/63f88ee409df0c1707120427.jpg)

### (1) 输入总线介绍

- **PWDN:camera的使能管脚**,有两种配置方式,一种为standby,一种为normal work,当设置为standby时,一切对于camea的操作都是无效的,包括复位,所以一定要将PWDN管脚设置为normal模式,否则RESET无效
- **RESET:camera的复位管脚**,此方式为硬复位模式,camera的各个IO口恢复到出厂默认状态,只有当XCLK开启后,将RESET置为低,硬复位才有效,否则复位无效
- **XCLK:是camera的工作时钟管脚**,此管脚为SOC提供camera的工作时钟，也可以外接一个晶振给Camera提供时钟信号
- **IIC:是camera和SOC通信的I2C总线**，主要用来对Camera Sensor进行一些参数的配置，如分辨率、数据格式等。

### (2)输出总线介绍

- **DATA :camera数据管脚**,此数据脚可以输出的格式为YUV,RGB,JPEG等
- **VSYNC:camera的帧同步信号管脚**。一个VYSNC信号结束表示一帧（即一个画面）的数据已经输出完毕
- **HSYNC:camera行同步信号管脚**。一个HSYNC信号结束表示一行的数据已经输出完毕。
- **PCLK:像素同步信号管脚**。一个PCLK信号结束表示一个像素点的数据已经输出完毕。

### (3)注意点

**XCLK(MCLK)是由SOC提供给摄像头到工作时钟，从而使摄像头工作**，**PCLK是摄像头自己产生的时钟信号，通过摄像头sensor的内部PLL电路可以产生不同频率的PCLK**。

## 2.MIPI-CSI2接口

MIPI接口：移动产业处理器接口(Mobile Industry Processor Interface：简称MIPI ),1对时钟线，1~4 lane对数据线，且都是差分走线，有比较强的抗干扰性。这种接口多用于手机接口，一些监控用的CMOS如SONY IMX185,OV5640等传感器接口；

> ```
> 4lane`的意思是有四组DATAP/DATAN线,`2lane`的意思是`2组DATAP/DATAN`线,最大支持`4通道`数据传输,单线传输速度高达`2Gb/s
> ```

![图片描述](https://img.mukewang.com/wiki/63f88eff09a278fa06400346.jpg)

> **CCI（Camera Control Interface）摄像头控制接口**。在MIPI中，充当着控制接口的作用，提供mipi接口sensor的控制传输通道。

## 3.USB接口

我们先介绍一下UVC是什么，UVC全称 USB video class或者USB device class,是Microsoft 与另外几家设备厂联合推出的USB视频捕获设备定义的协议标准，目前已经成为USB ORG标准之一。如今的主流操作系统都已经提供UVC设备驱动，因此符合UVC规格的硬件设备在不需要安装任何驱动程序下就可以在主机中正常使用。

# 五、Camera 输出的数据格式

## 1.**RAW data** 格式

CMOS 在将光信号转换为电信号时的高低电平的原始记录，**单纯地将没有进行任何处理的图像数据进行存储**，即摄像元件直接得到的电信号进行数字化处理而得到的。每个pixel只能感光R光或者B光或者G光，每个像素此时存贮的是单色的，即RAW DATA。后续需要ISP处理还原成三基色。

## 2.RGB格式

采用这种编码方法，每种颜色都可用三个变量来表示红色、绿色以及蓝色的强度。每一个像素有三原色 R 红色、G 绿色、B 蓝色组成。

## 3.YUV格式

其中“Y”表示明亮度(Luminance 或 Luma),就是灰阶值；而“U”和“V”表示色度(Chrominance 或 Chroma),是描述影像色彩及饱和度，用于指定像素的颜色。

## 4.JPEG格式

有些sensor，特别是低分辨率的，其自带JPEG engine，可以直接输出压缩后的jpg格式的数据

# 六、**数字视频信号标准ITU-R BT.601和ITU-R BT.656**

## 1.标准命名解析

ITU = International Telecommunication Union (联合国)国际电信联盟

R = Radio communication Sector 无线电部

BT = Broadcasting service (television) 广播服务(电视)

**ITU-R BT601/656\**\*\*和\*\**\*CCIR601/656\**\**的前世今生**

CCIR (Consultative Committee of International Radio，国际无线电咨询委员会) 是国际无线电咨询委员会的简称。成立于1927年，是国际电信联盟（ITU）的常设机构之一。主要职责是研究无线电通信和技术业务问题，并对这类问题通过建议书。从1993年3月1日起，与国际频率登记委员会（IFRB）合并，成为现今国际电信联盟（ITU）无线电通信部门，简称ITU-R。之后更新的CCIR601/656建议书就正式更名为ITU-RBT601和ITU-R BT656。

## 2.**ITU-R BT.601与ITU-R BT.656 标准区别**

ITU601与ITU656都具有8根数据线并行传输数据，差别在于前者还需要场频和行频传输线

![图片描述](https://img.mukewang.com/wiki/63f88f1f09113f8e06680304.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88f2d09db5d0506810146.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88f3909f5758007370135.jpg)

> **EVA代表有效视频结束**,**SAV代表有效视频开始**。

两者的区别在于：这两种标准都是video transmission 的 interface，在video frame format 的规格应该是相同的。两者的差别在于interface 规格的不同，**在CCIR656中，有8bit 的data bus和clock 的信号，也就是说CCIR656 是同步传输的，decoder端不用自己产生clock。**在CCIR601中，信号內还包含了其它两个同步信号：Horizontal Synchronization 和 Vertical Synchronization，decoder 要自己去锁定這个同步信号，再自己产生clock 來解。**CCIR 656需从DATA 中解出VS、HS**, **CCIR 601 則直接使用输入的VS、HS 即可**。

# <font color="#fd6f01">2.实战篇</font>

# 一、硬件原理图阅读



## 1.原理图

![图片描述](https://img.mukewang.com/wiki/63f8913109b68bbb12800475.jpg)

![图片描述](https://img.mukewang.com/wiki/63f8913f08c04c0006970106.jpg)



## 2.OV2640接口定义

![图片描述](https://img.mukewang.com/wiki/63f89153096ef11612322953.jpg)



# 二、OV2640摄像头

The OV2640 CAMERACHIPTM is a low voltage CMOS image sensor that provides the full functionality of a single-chip UXGA (1632x1232) camera and image processor in a small footprint package. The OV2640 provides full-frame, sub-sampled, scaled or windowed 8-bit/10-bit images in a wide range of formats, controlled through the Serial Camera Control Bus (SCCB) interface.

> OV2640 CAMERACHIPTM是一款低电压互补式金属氧化物半导体图像传感器，采用小型封装，提供单芯片UXGA（1632x1232）相机和图像处理器的全部功能。OV2640通过串行相机控制总线（SCCB）接口控制，提供各种格式的全帧、子采样、缩放或窗口化8位/10位图像。

This product has an image array capable of operating at up to 15 frames per second (fps) in UXGA resolution with complete user control over image quality, formatting and output data transfer. All required image processing functions, including exposure control, gamma, white balance, color saturation, hue control, white pixel canceling, noise canceling, and more, are also programmable through the SCCB interface. The OV2640 also includes a compression engine for increased processing power. In addition, OmniVision CAMERACHIPS use proprietary sensor technology to improve image quality by reducing or eliminating common lighting/electrical sources of image contamination, such as fixed pattern noise, smearing, etc., to produce a clean, fully stable color image.

> 该产品具有一个图像阵列，能够以高达每秒15帧（fps）的UXGA分辨率运行，用户可以完全控制画质、格式化和输出数据搬迁。所有必需的图像处理功能，包括曝光控制、伽马、白平衡、色彩饱和度、色调控制、白像素消除、噪声消除等，也可通过SCCB接口进行编程。OV2640还包括一个压缩引擎，以提高处理能力。此外，OmniVision CAMERACHIPS使用专有的传感器技术，通过减少或消除图像污染的常见照明/电气来源（如固定图案噪声、涂抹等）来提高画质，以产生干净、完全稳定的彩色图像。

![图片描述](https://img.mukewang.com/wiki/63f89169097f11cd12800511.jpg)



## 1.控制寄存器

控制寄存器配置摄像头的相关参数，如对比度、曝光参数等，通过SCCB(Serial Camera Control Bus)（与I2C类似）外设的**SIO_C**和**SIO_D**引脚写入。



## 2.通信、控制信号及时钟

其中PCLK、HREF及VSYNC分别是像素同步时钟、行同步信号以及帧同步信号。RESETB引脚为低电平时，用于复位整个传感器芯片，PWDN用于控制芯片进入低功耗模式。

`XCLK`是用于驱动整个传感器芯片的时钟信号，由**外部时钟源**（**外接晶振或由外部控制器提供**）输入到OV2640；而PCLK是OV2640输出数据时的同步信号，由OV2640输出。



## 3.**感光矩阵**

The OV2640 sensor has an image array of 1632 columns by 1232 rows (2,010,624 pixels).

> OV2640传感器具有1632列乘1232行（2,010,624像素）的图像阵列。

![图片描述](https://img.mukewang.com/wiki/63f8918009e2f94f07630631.jpg)

The color filters are arranged in a Bayer pattern. The primary color BG/GR array is arranged in line-alternating fashion. Of the 2,010,624 pixels, 1,991,040 (1632x1220) are active. The other pixels are used for black level calibration and interpolation.

> 滤色片以拜耳模式排列。原色BG/GR阵列以线交替方式排列。在2,010,624个像素中，1,991,040（1632x1220）是活动的。其他像素用于黑色电平校准和插值。



## 4.数据采集



### (1)**Analog Amplifier**

When the column sample/hold circuit has sampled one row of pixels, the pixel data will shift out one-by-one into an analog amplifier.

> 当列采样/保持电路对一行像素进行采样时，像素数据将逐一移出到模拟放大器中。

#### **Gain Control**

The amplifier gain can either be programmed by the user or controlled by the internal automatic gain control circuit (AGC).

> 放大器增益可以由用户编程或由内部自动增益控制电路（AGC）控制。



### (2)**10-Bit A/D Converters**

After the analog amplifier, the bayer pattern Raw signal is fed to two 10-bit analog-to-digital (A/D) converters, one for G channel and one shared by the BR channels. These A/D converters operate at speeds up to 20 MHz and are fully synchronous to the pixel rate (actual conversion rate is related to the frame rate).

> 在模拟放大器之后，拜耳模式原始信号被馈送到两个10位模数转换器，一个用于G通道，一个由BR通道共享。这些A/D转换器以高达20 MHz的速度工作，并且与像素速率完全同步（实际转换速率与帧率有关）。



### (3)**Channel Balance**

The amplified signals are then balanced with a channel balance block. In this block, the Red/Blue channel gain is increased or decreased to match Green channel luminance level.

> 然后用通道平衡块平衡放大的信号。在这个块中，红/蓝通道增益被增加或减少以匹配绿色通道亮度水平。

#### **Balance Control**

Channel Balance can be done manually by the user or by the internal automatic white balance (AWB) controller.

> 通道平衡可以由用户手动完成，也可以由内部自动白平衡（AWB）控制器完成。



### (4)**Black Level Compensation**

After the pixel data has been digitized, black level Calibration can be applied before the data is output. The black level calibration block subtracts the average signal level of optical black pixels to compensate for the dark current in the pixel output. The user can disable black level calibration.

> 像素数据数字化后，可以在数据输出之前应用黑色电平校准。黑色电平校准块减去光学黑色像素的平均信号电平以补偿像素输出中的暗电流。用户可以禁用黑色电平校准。



## 5.**数据输出**

包含了`DSP`处理单元，它会根据控制寄存器的配置做一些基本的图像处理运算，如色彩饱和度调整、边缘增强等。这部分还包含了图像格式转换单元及压缩单元，转换出的数据最终通过Y0-Y9引脚输出。

![图片描述](https://img.mukewang.com/wiki/63f8919b09a4179911440422.jpg)



# 三、SCCB协议



## 1. 介绍

OmniVision Technologies, Inc. has defined and deployed the Serial Camera Control Bus (SCCB), a 3-wire serial bus, for control of most of the functions in OmniVision’s family of CAMERACHIPSTM. In reduced pin package parts, the SCCB operates in a modified 2-wire serial mode.

> OmniVision Technologies， Inc.已经定义并部署了串行摄像机控制总线（SCCB），这是一种3线串行总线，用于控制OmniVision CAMERACHIPSTM系列中的大多数功能。在减少引脚封装部件中，SCCB以修改后的2线串行模式运行。

OmniVision CAMERACHIPS will only operate as slave devices and the companion back-end interface must assert as the master. One SCCB master device can be connected to the SCCB to control at least one SCCB slave device. An optional suspend-control signal provides the capability for the SCCB master device to power down the SCCB system. Refer to Figure 1-1 for the SCCB functional diagram illustrating the 3-wire connection.

> OmniVision CAMERACHIPS只能作为从设备运行，配套的后端接口必须作为主设备断言。一个SCCB主设备可以连接到SCCB以控制至少一个SCCB从设备。可选的挂起控制信号提供了SCCB主设备关闭SCCB系统电源的能力。有关说明3线连接的SCCB功能图，请参阅图1-1。

![图片描述](https://img.mukewang.com/wiki/63f891b409ee5d4612090426.jpg)

![图片描述](https://img.mukewang.com/wiki/63f891c209229bbc12010745.jpg)



## 2. **2-Wire SCCB Interface**

The modified 2-wire implementation allows for a SCCB master device to interface with only one slave device. This 2-wire application is implemented in the CAMERACHIP reduced pin package products where the SCCB_E signal is not available externally. Refer to Figure 1-2 for the functional diagram of the 2-wire implementation for the SCCB interface.

> 修改后的双线实现允许SCCB主设备仅与一个从设备接口。此双线应用程序在CAMERACHIP缩减引脚封装产品中实现，其中外部SCCB_E信号不可用。有关SCCB接口的双线实现的功能图，请参阅图1-2。

![图片描述](https://img.mukewang.com/wiki/63f8923e09011df412000173.jpg)



## **3.Transmission Phases**

A phase contains a total of 9 bits. The 9 bits consist of an 8-bit sequential data transmission followed by a ninth bit. The ninth bit is a Don’t-Care bit or an NA bit, depending on whether the data transmission is a write or read. The maximum number of phases that can be included in a transmission is three. The Most Significant Bit (MSB) is always asserted first for each phase.

> 一个相位总共包含9位。这9位包括8位顺序数据传输，然后是第9位。第9位是不关心位还是NA位，具体取决于数据传输是写入还是读取。传输中可以包含的最大相位数为3个。对于每个相位，始终首先声明最高有效位（MSB）。

![图片描述](https://img.mukewang.com/wiki/63f8924e09d154ff11960292.jpg)



### (1)**Phase 1 — ID Address**

Phase 1 is asserted by the master to identify the selected slave to which the data is read or written. Each slave has a unique ID address. The ID address is comprised of seven bits, ordered from bit 7 to bit 1, and can identify up to 128 slaves. The eighth bit, bit 0, is the read/write selector bit that specifies the transmission direction of the current cycle. A logical 0 represents a write cycle and a logical 1 represents a read cycle.

> 阶段1由主服务器断言，以识别读取或写入数据的选定从服务器。每个从服务器都有一个唯一的ID地址。ID地址由7位组成，从第7位到第1位排序，最多可识别128个从服务器。第八位，第0位，是读/写选择器位，指定当前周期的传输方向。逻辑0代表一个写周期，逻辑1代表一个读周期。



### (2)**Phase 2 — Sub-address/Read Data**

Either the master or the slave(s) may assert a phase 2 transmission. A phase 2 transmission asserted by the master identifies the sub-address of the slave(s) the master intends to access. A phase 2 transmission asserted by the slave(s) indicates the read data that the master will receive. The slave(s) recognize the sub-address of this read data according to the previous 3-phase or 2-phase write transmission cycles.

> 主站或从站可以断言第二阶段传输。主站断言的第二阶段传输标识主站打算访问的从站的子地址。从站断言的第二阶段传输指示主站将接收的读取数据。从站根据之前的3阶段或2阶段写入传输周期识别此读取数据的子地址。



### (3) **Phase 3 — Write Data**

Only the master may assert the phase 3 transmission. The phase 3 transmission contains the actual data the master intends to write to the slave(s).

> 只有主机可以断言第3阶段传输。第3阶段传输包含主机打算写入从属设备的实际数据。



### (4) **Don’t-Care Bit**

The Don’t-Care bit is the ninth bit of a master-issued transmission (ID address, sub-address, and write data). The master will continue to assert transmission phases until the transmission cycle is complete. The master also assumes that there is no transmission error during data transmissions. The purpose of the Don’t-Care bit is to indicate the completion of the transmission.

> 不关心位是主设备发出的传输（ID地址、子地址和写入数据）的第九位。主设备将继续断言传输阶段，直到传输周期完成。主设备还假定在数据传输过程中没有传输错误。不关心位的目的是指示传输完成。



# 四、OV2640摄像头编程思路介绍



## 1.IIC控制器GPIO口初始化

```c
void ov2640_pin_init(void)
{
    /*SCL*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);
    
    /*SDA*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);

    IOMUXC_I2C2_SCL_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT |= (0x2 << 0);

    IOMUXC_I2C2_SDA_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SDA_SELECT_INPUT |= (0x2 << 0);

    /*RESET*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 |= (0x5 << 0);

    return;
}
代码块12345678910111213141516171819202122
```



## 2.IIC控制器初始化

```c
iic_con_init(I2C2);
代码块1
```



## 3.重置OV2640摄像头模块

```c
void ov2640_hardware_reset(void)
{
    //output low level for reset
    GPIO1->GDIR |= (1 << 18);
    GPIO1->DR &= ~(1 << 18);
    gpt_delay_ms(500);

    //reset over
    GPIO1->DR |= (1 << 18);
    gpt_delay_ms(500);

    return;
}
代码块12345678910111213
```



## 4.编写OV2640内部寄存器读写函数



### (1)内部寄存器读函数

```c
#define OV2640_SLAVE_ADDR_READ  0x61

uint8_t ov2640_read_register(uint8_t regaddr)
{
    int ret;
    uint8_t rx_buf[1];
    uint8_t tx_buf[] = {regaddr};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,OV2640_SLAVE_ADDR_WRITE);

    //3.发送寄存器地址
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.重新发送开始信号
    iic_con_send_repeat_start(I2C2);
    
    //7.发送从机地址 + read
    iic_con_send_slave_addr(I2C2,OV2640_SLAVE_ADDR_READ);

    //8.读取从机数据
    iic_con_read_data(I2C2,rx_buf,sizeof(rx_buf));

    //9.发送stop信号
    iic_con_send_stop(I2C2);

    return rx_buf[0];
}
代码块12345678910111213141516171819202122232425262728293031
```



### (2)内部寄存器写函数

```c
#define OV2640_SLAVE_ADDR_WRITE 0x60

void ov2640_write_register(uint8_t regaddr,uint8_t regval)
{
    int ret;
    uint8_t tx_buf[] = {regaddr,regval};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,OV2640_SLAVE_ADDR_WRITE);
    
    //3.发送寄存器地址和数据
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.发送stop信号
    iic_con_send_stop(I2C2);

    return;
}
代码块123456789101112131415161718192021
```



### (3)读取产品ID

```c
#define OV2640_PIDH_REG_ADDR  0x0a
#define OV2640_PIDL_REG_ADDR  0x0b

void read_ov2640_pid(void)
{
    uint8_t pid[2];

    pid[1] = ov2640_read_register(OV2640_PIDH_REG_ADDR);
    gpt_delay_ms(10);
    pid[0] = ov2640_read_register(OV2640_PIDL_REG_ADDR);
    gpt_delay_ms(10);
    
    uart_printf("PIDH:%#x PIDL:%#x\r\n",pid[1],pid[0]);
    uart_printf("slave id:%#x\r\n",ov2640_read_register(0x86));

    return;
}
代码块1234567891011121314151617
```



## 5.写入寄存器序列值



### (1)ov2640_reg.h

```c
/*
 * uHAL OmniVision OV2640 camera driver
 *
 * Copyright (C) 2016, Marek Koza, qyx@krtko.org
 *
 * This file is part of uMesh node firmware (http://qyx.krtko.org/projects/umesh)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

/**
 * The following part is borrowed from the linux ov2640 driver. Some of the
 * registers are named but still there are many without any documentation.
 * Another possible source is the ArduCam project but it is not documented
 * and there are long arrays of magic values only.
 */

/** @todo relicense to gplv3 or bsd */

/*
 * Copyright (C) 2010 Alberto Panizzo <maramaopercheseimorto@gmail.com>
 *
 * Based on ov772x, ov9640 drivers and previous non merged implementations.
 *
 * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
 * Copyright (C) 2006, OmniVision
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <stdint.h>
#include <stdlib.h>

#define VAL_SET(x, mask, rshift, lshift) ((((x) >> rshift) & mask) << lshift)

/*
 * DSP registers
 * register offset for BANK_SEL == BANK_SEL_DSP
 */
#define R_BYPASS 0x05           /* Bypass DSP */
#define R_BYPASS_DSP_BYPAS 0x01 /* Bypass DSP, sensor out directly */
#define R_BYPASS_USE_DSP 0x00   /* Use the internal DSP */
#define QS 0x44                 /* Quantization Scale Factor */
#define CTRLI 0x50
#define CTRLI_LP_DP 0x80
#define CTRLI_ROUND 0x40
#define CTRLI_V_DIV_SET(x) VAL_SET(x, 0x3, 0, 3)
#define CTRLI_H_DIV_SET(x) VAL_SET(x, 0x3, 0, 0)
#define HSIZE 0x51 /* H_SIZE[7:0] (real/4) */
#define HSIZE_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define VSIZE 0x52 /* V_SIZE[7:0] (real/4) */
#define VSIZE_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define XOFFL 0x53 /* OFFSET_X[7:0] */
#define XOFFL_SET(x) VAL_SET(x, 0xFF, 0, 0)
#define YOFFL 0x54 /* OFFSET_Y[7:0] */
#define YOFFL_SET(x) VAL_SET(x, 0xFF, 0, 0)
#define VHYX 0x55 /* Offset and size completion */
#define VHYX_VSIZE_SET(x) VAL_SET(x, 0x1, (8 + 2), 7)
#define VHYX_HSIZE_SET(x) VAL_SET(x, 0x1, (8 + 2), 3)
#define VHYX_YOFF_SET(x) VAL_SET(x, 0x3, 8, 4)
#define VHYX_XOFF_SET(x) VAL_SET(x, 0x3, 8, 0)
#define DPRP 0x56
#define TEST 0x57 /* Horizontal size completion */
#define TEST_HSIZE_SET(x) VAL_SET(x, 0x1, (9 + 2), 7)
#define ZMOW 0x5A /* Zoom: Out Width  OUTW[7:0] (real/4) */
#define ZMOW_OUTW_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define ZMOH 0x5B /* Zoom: Out Height OUTH[7:0] (real/4) */
#define ZMOH_OUTH_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define ZMHH 0x5C /* Zoom: Speed and H&W completion */
#define ZMHH_ZSPEED_SET(x) VAL_SET(x, 0x0F, 0, 4)
#define ZMHH_OUTH_SET(x) VAL_SET(x, 0x1, (8 + 2), 2)
#define ZMHH_OUTW_SET(x) VAL_SET(x, 0x3, (8 + 2), 0)
#define BPADDR 0x7C /* SDE Indirect Register Access: Address */
#define BPDATA 0x7D /* SDE Indirect Register Access: Data */
#define CTRL2 0x86  /* DSP Module enable 2 */
#define CTRL2_DCW_EN 0x20
#define CTRL2_SDE_EN 0x10
#define CTRL2_UV_ADJ_EN 0x08
#define CTRL2_UV_AVG_EN 0x04
#define CTRL2_CMX_EN 0x01
#define CTRL3 0x87 /* DSP Module enable 3 */
#define CTRL3_BPC_EN 0x80
#define CTRL3_WPC_EN 0x40
#define SIZEL 0x8C /* Image Size Completion */
#define SIZEL_HSIZE8_11_SET(x) VAL_SET(x, 0x1, 11, 6)
#define SIZEL_HSIZE8_SET(x) VAL_SET(x, 0x7, 0, 3)
#define SIZEL_VSIZE8_SET(x) VAL_SET(x, 0x7, 0, 0)
#define HSIZE8 0xC0 /* Image Horizontal Size HSIZE[10:3] */
#define HSIZE8_SET(x) VAL_SET(x, 0xFF, 3, 0)
#define VSIZE8 0xC1 /* Image Vertical Size VSIZE[10:3] */
#define VSIZE8_SET(x) VAL_SET(x, 0xFF, 3, 0)
#define CTRL0 0xC2 /* DSP Module enable 0 */
#define CTRL0_AEC_EN 0x80
#define CTRL0_AEC_SEL 0x40
#define CTRL0_STAT_SEL 0x20
#define CTRL0_VFIRST 0x10
#define CTRL0_YUV422 0x08
#define CTRL0_YUV_EN 0x04
#define CTRL0_RGB_EN 0x02
#define CTRL0_RAW_EN 0x01
#define CTRL1 0xC3 /* DSP Module enable 1 */
#define CTRL1_CIP 0x80
#define CTRL1_DMY 0x40
#define CTRL1_RAW_GMA 0x20
#define CTRL1_DG 0x10
#define CTRL1_AWB 0x08
#define CTRL1_AWB_GAIN 0x04
#define CTRL1_LENC 0x02
#define CTRL1_PRE 0x01
#define R_DVP_SP 0xD3 /* DVP output speed control */
#define R_DVP_SP_AUTO_MODE 0x80
#define R_DVP_SP_DVP_MASK 0x3F /* DVP PCLK = sysclk (48)/[6:0] (YUV0); \
                                *          = sysclk (48)/(2*[6:0]) (RAW);*/
#define IMAGE_MODE 0xDA        /* Image Output Format Select */
#define IMAGE_MODE_Y8_DVP_EN 0x40
#define IMAGE_MODE_JPEG_EN 0x10
#define IMAGE_MODE_YUV422 0x00
#define IMAGE_MODE_RAW10 0x04 /* (DVP) */
#define IMAGE_MODE_RGB565 0x08
#define IMAGE_MODE_HREF_VSYNC 0x02  /* HREF timing select in DVP JPEG output \
                                     * mode (0 for HREF is same as sensor) */
#define IMAGE_MODE_LBYTE_FIRST 0x01 /* Byte swap enable for DVP             \
                                     *    1: Low byte first UYVY (C2[4] =0) \
                                     *        VYUY (C2[4] =1)               \
                                     *    0: High byte first YUYV (C2[4]=0) \
                                     *        YVYU (C2[4] = 1) */
#define RESET 0xE0                  /* Reset */
#define RESET_MICROC 0x40
#define RESET_SCCB 0x20
#define RESET_JPEG 0x10
#define RESET_DVP 0x04
#define RESET_IPU 0x02
#define RESET_CIF 0x01
#define REGED 0xED /* Register ED */
#define REGED_CLK_OUT_DIS 0x10
#define MS_SP 0xF0   /* SCCB Master Speed */
#define SS_ID 0xF7   /* SCCB Slave ID */
#define SS_CTRL 0xF8 /* SCCB Slave Control */
#define SS_CTRL_ADD_AUTO_INC 0x20
#define SS_CTRL_EN 0x08
#define SS_CTRL_DELAY_CLK 0x04
#define SS_CTRL_ACC_EN 0x02
#define SS_CTRL_SEN_PASS_THR 0x01
#define MC_BIST 0xF9       /* Microcontroller misc register */
#define MC_BIST_RESET 0x80 /* Microcontroller Reset */
#define MC_BIST_BOOT_ROM_SEL 0x40
#define MC_BIST_12KB_SEL 0x20
#define MC_BIST_12KB_MASK 0x30
#define MC_BIST_512KB_SEL 0x08
#define MC_BIST_512KB_MASK 0x0C
#define MC_BIST_BUSY_BIT_R 0x02
#define MC_BIST_MC_RES_ONE_SH_W 0x02
#define MC_BIST_LAUNCH 0x01
#define BANK_SEL 0xFF /* Register Bank Select */
#define BANK_SEL_DSP 0x00
#define BANK_SEL_SENS 0x01

/*
 * Sensor registers
 * register offset for BANK_SEL == BANK_SEL_SENS
 */
#define GAIN 0x00 /* AGC - Gain control gain setting */
#define COM1 0x03 /* Common control 1 */
#define COM1_1_DUMMY_FR 0x40
#define COM1_3_DUMMY_FR 0x80
#define COM1_7_DUMMY_FR 0xC0
#define COM1_VWIN_LSB_UXGA 0x0F
#define COM1_VWIN_LSB_SVGA 0x0A
#define COM1_VWIN_LSB_CIF 0x06
#define REG04 0x04           /* Register 04 */
#define REG04_DEF 0x20       /* Always set */
#define REG04_HFLIP_IMG 0x80 /* Horizontal mirror image ON/OFF */
#define REG04_VFLIP_IMG 0x40 /* Vertical flip image ON/OFF */
#define REG04_VREF_EN 0x10
#define REG04_HREF_EN 0x08
#define REG04_AEC_SET(x) VAL_SET(x, 0x3, 0, 0)
#define REG08 0x08                           /* Frame Exposure One-pin Control Pre-charge Row Num */
#define COM2 0x09                            /* Common control 2 */
#define COM2_SOFT_SLEEP_MODE 0x10            /* Soft sleep mode */
                                             /* Output drive capability */
#define COM2_OCAP_Nx_SET(N) (((N)-1) & 0x03) /* N = [1x .. 4x] */
#define PID 0x0A                             /* Product ID Number MSB */
#define VER 0x0B                             /* Product ID Number LSB */
#define COM3 0x0C                            /* Common control 3 */
#define COM3_BAND_50H 0x04                   /* 0 For Banding at 60H */
#define COM3_BAND_AUTO 0x02                  /* Auto Banding */
#define COM3_SING_FR_SNAPSH 0x01             /* 0 For enable live video output after the \
                                              * snapshot sequence*/
#define AEC 0x10                             /* AEC[9:2] Exposure Value */
#define CLKRC 0x11                           /* Internal clock */
#define CLKRC_EN 0x80
#define CLKRC_DIV_SET(x) (((x)-1) & 0x1F) /* CLK = XVCLK/(x) */
#define COM7 0x12                         /* Common control 7 */
#define COM7_SRST 0x80                    /* Initiates system reset. All registers are \
                                           * set to factory default values after which \
                                           * the chip resumes normal operation */
#define COM7_RES_UXGA 0x00                /* Resolution selectors for UXGA */
#define COM7_RES_SVGA 0x40                /* SVGA */
#define COM7_RES_CIF 0x20                 /* CIF */
#define COM7_ZOOM_EN 0x04                 /* Enable Zoom mode */
#define COM7_COLOR_BAR_TEST 0x02          /* Enable Color Bar Test Pattern */
#define COM8 0x13                         /* Common control 8 */
#define COM8_DEF 0xC0                     /* Banding filter ON/OFF */
#define COM8_BNDF_EN 0x20                 /* Banding filter ON/OFF */
#define COM8_AGC_EN 0x04                  /* AGC Auto/Manual control selection */
#define COM8_AEC_EN 0x01                  /* Auto/Manual Exposure control */
#define COM9 0x14                         /* Common control 9 \
                                      * Automatic gain ceiling - maximum AGC value [7:5]*/
#define COM9_AGC_GAIN_2x 0x00             /* 000 :   2x */
#define COM9_AGC_GAIN_4x 0x20             /* 001 :   4x */
#define COM9_AGC_GAIN_8x 0x40             /* 010 :   8x */
#define COM9_AGC_GAIN_16x 0x60            /* 011 :  16x */
#define COM9_AGC_GAIN_32x 0x80            /* 100 :  32x */
#define COM9_AGC_GAIN_64x 0xA0            /* 101 :  64x */
#define COM9_AGC_GAIN_128x 0xC0           /* 110 : 128x */
#define COM10 0x15                        /* Common control 10 */
#define COM10_PCLK_HREF 0x20              /* PCLK output qualified by HREF */
#define COM10_PCLK_RISE 0x10            /* Data is updated at the rising edge of \
                                         * PCLK (user can latch data at the next \
                                         * falling edge of PCLK).                \
                                         * 0 otherwise. */
#define COM10_HREF_INV 0x08             /* Invert HREF polarity: \
                                         * HREF negative for valid data*/
#define COM10_VSINC_INV 0x02            /* Invert VSYNC polarity */
#define HSTART 0x17                     /* Horizontal Window start MSB 8 bit */
#define HEND 0x18                       /* Horizontal Window end MSB 8 bit */
#define VSTART 0x19                     /* Vertical Window start MSB 8 bit */
#define VEND 0x1A                       /* Vertical Window end MSB 8 bit */
#define MIDH 0x1C                       /* Manufacturer ID byte - high */
#define MIDL 0x1D            /* Manufacturer ID byte - low  */
#define AEW 0x24            /* AGC/AEC - Stable operating region (upper limit) */
#define AEB 0x25            /* AGC/AEC - Stable operating region (lower limit) */
#define VV 0x26             /* AGC/AEC Fast mode operating region */
#define VV_HIGH_TH_SET(x) VAL_SET(x, 0xF, 0, 4)
#define VV_LOW_TH_SET(x) VAL_SET(x, 0xF, 0, 0)
#define REG2A 0x2A            /* Dummy pixel insert MSB */
#define FRARL 0x2B            /* Dummy pixel insert LSB */
#define ADDVFL 0x2D           /* LSB of insert dummy lines in Vertical direction */
#define ADDVFH 0x2E           /* MSB of insert dummy lines in Vertical direction */
#define YAVG 0x2F             /* Y/G Channel Average value */
#define REG32 0x32            /* Common Control 32 */
#define REG32_PCLK_DIV_2 0x80 /* PCLK freq divided by 2 */
#define REG32_PCLK_DIV_4 0xC0 /* PCLK freq divided by 4 */
#define ARCOM2 0x34           /* Zoom: Horizontal start point */
#define REG45 0x45            /* Register 45 */
#define FLL 0x46              /* Frame Length Adjustment LSBs */
#define FLH 0x47              /* Frame Length Adjustment MSBs */
#define COM19 0x48            /* Zoom: Vertical start point */
#define ZOOMS 0x49            /* Zoom: Vertical start point */
#define COM22 0x4B            /* Flash light control */
#define COM25 0x4E            /* For Banding operations */
#define BD50 0x4F             /* 50Hz Banding AEC 8 LSBs */
#define BD60 0x50             /* 60Hz Banding AEC 8 LSBs */
#define REG5D 0x5D            /* AVGsel[7:0],   16-zone average weight option */
#define REG5E 0x5E            /* AVGsel[15:8],  16-zone average weight option */
#define REG5F 0x5F            /* AVGsel[23:16], 16-zone average weight option */
#define REG60 0x60            /* AVGsel[31:24], 16-zone average weight option */
#define HISTO_LOW 0x61        /* Histogram Algorithm Low Level */
#define HISTO_HIGH 0x62       /* Histogram Algorithm High Level */

#define MANUFACTURER_ID 0x7FA2
#define PID_OV2640 0x2642
#define VERSION(pid, ver) ((pid << 8) | (ver & 0xFF))

struct regval_list
{
    uint8_t reg_num;
    uint8_t value;
};

/* Supported resolutions */
enum ov2640_width
{
    W_QCIF = 176,
    W_QVGA = 320,
    W_CIF = 352,
    W_VGA = 640,
    W_SVGA = 800,
    W_XGA = 1024,
    W_SXGA = 1280,
    W_UXGA = 1600,
};

enum ov2640_height
{
    H_QCIF = 144,
    H_QVGA = 240,
    H_CIF = 288,
    H_VGA = 480,
    H_SVGA = 600,
    H_XGA = 768,
    H_SXGA = 1024,
    H_UXGA = 1200,
};

struct ov2640_win_size
{
    char *name;
    enum ov2640_width width;
    enum ov2640_height height;
    const struct regval_list *regs;
};

#define ENDMARKER  \
    {              \
        0xff, 0xff \
    }
#define OV2640_SIZE(n, w, h, r)                       \
    {                                                 \
        .name = n, .width = w, .height = h, .regs = r \
    }

extern const struct regval_list ov2640_init_regs[];
extern const struct regval_list ov2640_size_change_preamble_regs[];
extern const struct regval_list ov2640_qcif_regs[];
extern const struct regval_list ov2640_qvga_regs[];
extern const struct regval_list ov2640_cif_regs[];
extern const struct regval_list ov2640_vga_regs[];
extern const struct regval_list ov2640_lcd_regs[];
extern const struct regval_list ov2640_svga_regs[];
extern const struct regval_list ov2640_xga_regs[];
extern const struct regval_list ov2640_sxga_regs[];
extern const struct regval_list ov2640_uxga_regs[];
extern const struct ov2640_win_size ov2640_supported_win_sizes[];
extern const struct regval_list ov2640_format_change_preamble_regs[];
extern const struct regval_list ov2640_yuyv_regs[];
extern const struct regval_list ov2640_uyvy_regs[];
extern const struct regval_list ov2640_rgb565_be_regs[];
extern const struct regval_list ov2640_rgb565_le_regs[];
extern const struct regval_list ov2640_jpeg_regs[];
extern const struct regval_list ov2640_light_mode_sunny_regs[];
代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346
```



### (2)ov2640_reg.c

```c
/*
 * uHAL OmniVision OV2640 camera driver
 *
 * Copyright (C) 2016, Marek Koza, qyx@krtko.org
 *
 * This file is part of uMesh node firmware (http://qyx.krtko.org/projects/umesh)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * The following part is borrowed from the linux ov2640 driver. Some of the
 * registers are named but still there are many without any documentation.
 * Another possible source is the ArduCam project but it is not documented
 * and there are long arrays of magic values only.
 */

/*
 * Copyright (C) 2010 Alberto Panizzo <maramaopercheseimorto@gmail.com>
 *
 * Based on ov772x, ov9640 drivers and previous non merged implementations.
 *
 * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
 * Copyright (C) 2006, OmniVision
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "ov2640_reg.h"

const struct regval_list ov2640_init_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0x2c, 0xff},
    {0x2e, 0xdf},
    {BANK_SEL, BANK_SEL_SENS},
    {0x3c, 0x32},
    {CLKRC, CLKRC_DIV_SET(1)},
    {COM2, COM2_OCAP_Nx_SET(3)},
    {REG04, REG04_DEF | REG04_HREF_EN},
    {COM8, COM8_DEF | COM8_AGC_EN | COM8_AEC_EN},
    //~ { AEC,    0x00 },
    {COM9, COM9_AGC_GAIN_8x | 0x08},
    {0x2c, 0x0c},
    {0x33, 0x78},
    {0x3a, 0x33},
    {0x3b, 0xfb},
    {0x3e, 0x00},
    {0x43, 0x11},
    {0x16, 0x10},
    {0x39, 0x02},
    {0x35, 0x88},
    {0x22, 0x0a},
    {0x37, 0x40},
    {0x23, 0x00},
    {ARCOM2, 0xa0},
    {0x06, 0x02},
    {0x06, 0x88},
    {0x07, 0xc0},
    {0x0d, 0xb7},
    {0x0e, 0x01},
    {0x4c, 0x00},
    {0x4a, 0x81},
    {0x21, 0x99},
    {AEW, 0x40},
    {AEB, 0x38},
    {VV, VV_HIGH_TH_SET(0x08) | VV_LOW_TH_SET(0x02)},
    {0x5c, 0x00},
    {0x63, 0x00},
    {FLL, 0x22},
    {COM3, 0x38 | COM3_BAND_AUTO},
    {REG5D, 0x55},
    {REG5E, 0x7d},
    {REG5F, 0x7d},
    {REG60, 0x55},
    {HISTO_LOW, 0x70},
    {HISTO_HIGH, 0x80},
    {0x7c, 0x05},
    {0x20, 0x80},
    {0x28, 0x30},
    {0x6c, 0x00},
    {0x6d, 0x80},
    {0x6e, 0x00},
    {0x70, 0x02},
    {0x71, 0x94},
    {0x73, 0xc1},
    {0x3d, 0x34},
    {COM7, COM7_RES_UXGA | COM7_ZOOM_EN},
    {0x5a, 0x57},
    {BD50, 0xbb},
    {BD60, 0x9c},
    {BANK_SEL, BANK_SEL_DSP},
    {0xe5, 0x7f},
    {MC_BIST, MC_BIST_RESET | MC_BIST_BOOT_ROM_SEL},
    {0x41, 0x24},
    {RESET, RESET_JPEG | RESET_DVP},
    {0x76, 0xff},
    {0x33, 0xa0},
    {0x42, 0x20},
    {0x43, 0x18},
    {0x4c, 0x00},
    {CTRL3, CTRL3_BPC_EN | CTRL3_WPC_EN | 0x10},
    {0x88, 0x3f},
    {0xd7, 0x03},
    {0xd9, 0x10},
    {R_DVP_SP, R_DVP_SP_AUTO_MODE | 0x2},
    {0xc8, 0x08},
    {0xc9, 0x80},
    {BPADDR, 0x00},
    {BPDATA, 0x00},
    {BPADDR, 0x03},
    {BPDATA, 0x48},
    {BPDATA, 0x48},
    {BPADDR, 0x08},
    {BPDATA, 0x20},
    {BPDATA, 0x10},
    {BPDATA, 0x0e},
    {0x90, 0x00},
    {0x91, 0x0e},
    {0x91, 0x1a},
    {0x91, 0x31},
    {0x91, 0x5a},
    {0x91, 0x69},
    {0x91, 0x75},
    {0x91, 0x7e},
    {0x91, 0x88},
    {0x91, 0x8f},
    {0x91, 0x96},
    {0x91, 0xa3},
    {0x91, 0xaf},
    {0x91, 0xc4},
    {0x91, 0xd7},
    {0x91, 0xe8},
    {0x91, 0x20},
    {0x92, 0x00},
    {0x93, 0x06},
    {0x93, 0xe3},
    {0x93, 0x03},
    {0x93, 0x03},
    {0x93, 0x00},
    {0x93, 0x02},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x96, 0x00},
    {0x97, 0x08},
    {0x97, 0x19},
    {0x97, 0x02},
    {0x97, 0x0c},
    {0x97, 0x24},
    {0x97, 0x30},
    {0x97, 0x28},
    {0x97, 0x26},
    {0x97, 0x02},
    {0x97, 0x98},
    {0x97, 0x80},
    {0x97, 0x00},
    {0x97, 0x00},
    {0xa4, 0x00},
    {0xa8, 0x00},
    {0xc5, 0x11},
    {0xc6, 0x51},
    {0xbf, 0x80},
    {0xc7, 0x10}, /* white balance */
    {0xb6, 0x66},
    {0xb8, 0xA5},
    {0xb7, 0x64},
    {0xb9, 0x7C},
    {0xb3, 0xaf},
    {0xb4, 0x97},
    {0xb5, 0xFF},
    {0xb0, 0xC5},
    {0xb1, 0x94},
    {0xb2, 0x0f},
    {0xc4, 0x5c},
    {0xa6, 0x00},
    {0xa7, 0x20},
    {0xa7, 0xd8},
    {0xa7, 0x1b},
    {0xa7, 0x31},
    {0xa7, 0x00},
    {0xa7, 0x18},
    {0xa7, 0x20},
    {0xa7, 0xd8},
    {0xa7, 0x19},
    {0xa7, 0x31},
    {0xa7, 0x00},
    {0xa7, 0x18},
    {0xa7, 0x20},
    {0xa7, 0xd8},
    {0xa7, 0x19},
    {0xa7, 0x31},
    {0xa7, 0x00},
    {0xa7, 0x18},
    {0x7f, 0x00},
    {0xe5, 0x1f},
    {0xe1, 0x77},
    {0xdd, 0x7f},
    {CTRL0, CTRL0_YUV422 | CTRL0_YUV_EN},
    ENDMARKER,
};

/*
 * Register settings for window size
 * The preamble, setup the internal DSP to input an UXGA (1600x1200) image.
 * Then the different zooming configurations will setup the output image size.
 */
const struct regval_list ov2640_size_change_preamble_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {RESET, RESET_DVP},
    {HSIZE8, HSIZE8_SET(W_UXGA)},
    {VSIZE8, VSIZE8_SET(H_UXGA)},
    {CTRL2, CTRL2_DCW_EN | CTRL2_SDE_EN |
                CTRL2_UV_AVG_EN | CTRL2_CMX_EN | CTRL2_UV_ADJ_EN},
    {HSIZE, HSIZE_SET(W_UXGA)},
    {VSIZE, VSIZE_SET(H_UXGA)},
    {XOFFL, XOFFL_SET(0)},
    {YOFFL, YOFFL_SET(0)},
    {VHYX, VHYX_HSIZE_SET(W_UXGA) | VHYX_VSIZE_SET(H_UXGA) |
               VHYX_XOFF_SET(0) | VHYX_YOFF_SET(0)},
    {TEST, TEST_HSIZE_SET(W_UXGA)},
    ENDMARKER,
};

#define PER_SIZE_REG_SEQ(x, y, v_div, h_div, pclk_div) \
    {CTRLI, CTRLI_LP_DP | CTRLI_V_DIV_SET(v_div) |     \
                CTRLI_H_DIV_SET(h_div)},               \
        {ZMOW, ZMOW_OUTW_SET(x)},                      \
        {ZMOH, ZMOH_OUTH_SET(y)},                      \
        {ZMHH, ZMHH_OUTW_SET(x) | ZMHH_OUTH_SET(y)},   \
        {R_DVP_SP, pclk_div},                          \
    {                                                  \
        RESET, 0x00                                    \
    }

const struct regval_list ov2640_qcif_regs[] = {
    PER_SIZE_REG_SEQ(W_QCIF, H_QCIF, 3, 3, 4),
    ENDMARKER,
};

const struct regval_list ov2640_qvga_regs[] = {
    PER_SIZE_REG_SEQ(W_QVGA, H_QVGA, 2, 2, 4),
    ENDMARKER,
};

#define LCD_WIDTH 480
#define LCD_HEIGHT 272

const struct regval_list ov2640_lcd_regs[] = {
    PER_SIZE_REG_SEQ(LCD_WIDTH, LCD_HEIGHT, 0, 0, 2),
    ENDMARKER,
};

const struct regval_list ov2640_cif_regs[] = {
    PER_SIZE_REG_SEQ(W_CIF, H_CIF, 2, 2, 8),
    ENDMARKER,
};

const struct regval_list ov2640_vga_regs[] = {
    PER_SIZE_REG_SEQ(W_VGA, H_VGA, 0, 0, 2),
    ENDMARKER,
};

const struct regval_list ov2640_svga_regs[] = {
    PER_SIZE_REG_SEQ(W_SVGA, H_SVGA, 1, 1, 2),
    ENDMARKER,
};

const struct regval_list ov2640_xga_regs[] = {
    PER_SIZE_REG_SEQ(W_XGA, H_XGA, 0, 0, 2),
    {CTRLI, 0x00},
    ENDMARKER,
};

const struct regval_list ov2640_sxga_regs[] = {
    PER_SIZE_REG_SEQ(W_SXGA, H_SXGA, 0, 0, 2),
    {CTRLI, 0x00},
    {R_DVP_SP, 2 | R_DVP_SP_AUTO_MODE},
    ENDMARKER,
};

const struct regval_list ov2640_uxga_regs[] = {
    PER_SIZE_REG_SEQ(W_UXGA, H_UXGA, 0, 0, 0),
    {CTRLI, 0x00},
    {R_DVP_SP, 0 | R_DVP_SP_AUTO_MODE},
    ENDMARKER,
};

const struct ov2640_win_size ov2640_supported_win_sizes[] = {
    OV2640_SIZE("QCIF", W_QCIF, H_QCIF, ov2640_qcif_regs),
    OV2640_SIZE("QVGA", W_QVGA, H_QVGA, ov2640_qvga_regs),
    OV2640_SIZE("CIF", W_CIF, H_CIF, ov2640_cif_regs),
    OV2640_SIZE("VGA", W_VGA, H_VGA, ov2640_vga_regs),
    OV2640_SIZE("SVGA", W_SVGA, H_SVGA, ov2640_svga_regs),
    OV2640_SIZE("XGA", W_XGA, H_XGA, ov2640_xga_regs),
    OV2640_SIZE("SXGA", W_SXGA, H_SXGA, ov2640_sxga_regs),
    OV2640_SIZE("UXGA", W_UXGA, H_UXGA, ov2640_uxga_regs),
};

/*
 * Register settings for pixel formats
 */
const struct regval_list ov2640_format_change_preamble_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_yuyv_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_YUV422},
    {0xd7, 0x03},
    {0x33, 0xa0},
    {0xe5, 0x1f},
    {0xe1, 0x67},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_uyvy_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_YUV422},
    {0xd7, 0x01},
    {0x33, 0xa0},
    {0xe1, 0x67},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_rgb565_be_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_RGB565},
    {0xd7, 0x03},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_rgb565_le_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_RGB565},
    {0xd7, 0x03},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_jpeg_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0xe0, 0x14},
    {0xe1, 0x77},
    {0xe5, 0x1f},
    {0xd7, 0x03},
    {IMAGE_MODE, IMAGE_MODE_JPEG_EN},
    {0xe0, 0x00},
    {BANK_SEL, BANK_SEL_SENS},
    {0x04, 0x08},
    //~ { RESET,  RESET_DVP | RESET_JPEG },
    ENDMARKER,
};

const struct regval_list ov2640_light_mode_sunny_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0xff, 0x00},
    {0xc7, 0x40},
    {0xcc, 0x5e},
    {0xcd, 0x41},
    {0xce, 0x54},
    ENDMARKER,
};
代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384
```



### (3)需要写入的寄存器值

```c
struct regval_list
{
    uint8_t reg_num;
    uint8_t value;
};
static void ov2640_write_array(const struct regval_list *vals)
{
    while ((vals->reg_num != 0xff) || (vals->value != 0xff))
    {
        ov2640_write_register(vals->reg_num, vals->value);
        vals++;
        gpt_delay_ms(1);
    }

    return;
}
ov2640_write_array(ov2640_init_regs);
ov2640_write_array(ov2640_size_change_preamble_regs);
// ov2640_write_array(ov2640_qvga_regs);
ov2640_write_array(ov2640_lcd_regs);

ov2640_write_array(ov2640_format_change_preamble_regs);
ov2640_write_array(ov2640_rgb565_be_regs);
ov2640_write_array(ov2640_light_mode_sunny_regs);
代码块123456789101112131415161718192021222324
```



# 五、OV2640初始化

```c
void ov2640_init(void)
{
    ov2640_pin_init();
    ov2640_hardware_reset();
    iic_con_init(I2C2);

    read_ov2640_pid();

    ov2640_write_array(ov2640_init_regs);
    ov2640_write_array(ov2640_size_change_preamble_regs);
    // ov2640_write_array(ov2640_qvga_regs);
    ov2640_write_array(ov2640_lcd_regs);

    ov2640_write_array(ov2640_format_change_preamble_regs);
    ov2640_write_array(ov2640_rgb565_be_regs);
    ov2640_write_array(ov2640_light_mode_sunny_regs);

    return;
}
代码块12345678910111213141516171819
```



# 六、完整代码

```c
#include "imx6ull.h"
#include "ov2640_reg.h"

#define OV2640_SLAVE_ADDR_WRITE 0x60
#define OV2640_SLAVE_ADDR_READ  0x61
#define OV2640_PIDH_REG_ADDR  0x0a
#define OV2640_PIDL_REG_ADDR  0x0b

void ov2640_pin_init(void)
{
    /*SCL*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);
    
    /*SDA*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);

    IOMUXC_I2C2_SCL_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT |= (0x2 << 0);

    IOMUXC_I2C2_SDA_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SDA_SELECT_INPUT |= (0x2 << 0);

    /*RESET*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 |= (0x5 << 0);

    return;
}

void ov2640_hardware_reset(void)
{
    //output low level for reset
    GPIO1->GDIR |= (1 << 18);
    GPIO1->DR &= ~(1 << 18);
    gpt_delay_ms(500);

    //reset over
    GPIO1->DR |= (1 << 18);
    gpt_delay_ms(500);

    return;
}

void ov2640_write_register(uint8_t regaddr,uint8_t regval)
{
    int ret;
    uint8_t tx_buf[] = {regaddr,regval};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,OV2640_SLAVE_ADDR_WRITE);
    
    //3.发送寄存器地址和数据
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.发送stop信号
    iic_con_send_stop(I2C2);

    return;
}

uint8_t ov2640_read_register(uint8_t regaddr)
{
    int ret;
    uint8_t rx_buf[1];
    uint8_t tx_buf[] = {regaddr};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,OV2640_SLAVE_ADDR_WRITE);

    //3.发送寄存器地址
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.重新发送开始信号
    iic_con_send_repeat_start(I2C2);
    
    //7.发送从机地址 + read
    iic_con_send_slave_addr(I2C2,OV2640_SLAVE_ADDR_READ);

    //8.读取从机数据
    iic_con_read_data(I2C2,rx_buf,sizeof(rx_buf));

    //9.发送stop信号
    iic_con_send_stop(I2C2);

    return rx_buf[0];
}

static void ov2640_write_array(const struct regval_list *vals)
{
    while ((vals->reg_num != 0xff) || (vals->value != 0xff))
    {
        ov2640_write_register(vals->reg_num, vals->value);
        vals++;
        gpt_delay_ms(1);
    }

    return;
}
void read_ov2640_pid(void)
{
    uint8_t pid[2];

    pid[1] = ov2640_read_register(OV2640_PIDH_REG_ADDR);
    gpt_delay_ms(10);
    pid[0] = ov2640_read_register(OV2640_PIDL_REG_ADDR);
    gpt_delay_ms(10);
    
    uart_printf("PIDH:%#x PIDL:%#x\r\n",pid[1],pid[0]);

    return;
}

void ov2640_init(void)
{
    ov2640_pin_init();
    ov2640_hardware_reset();
    iic_con_init(I2C2);

    read_ov2640_pid();

    ov2640_write_array(ov2640_init_regs);
    ov2640_write_array(ov2640_size_change_preamble_regs);
    // ov2640_write_array(ov2640_qvga_regs);
    ov2640_write_array(ov2640_lcd_regs);

    ov2640_write_array(ov2640_format_change_preamble_regs);
    ov2640_write_array(ov2640_rgb565_be_regs);
    ov2640_write_array(ov2640_light_mode_sunny_regs);

    return;
}

void ov2640_test(void)
{
    ov2640_init();

    while(1){
        read_ov2640_pid();
        gpt_delay_sec(1);
    }

    return;
}

```