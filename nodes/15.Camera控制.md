# <font color="#fd6f01">1.理论篇</font>

# 一、生活中的摄像头

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/23d9fcba46d3415197d283405a47d65c.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/436ff06da3f84bcfb386a86a0d425dcf.png)

# 二、摄像头工作原理剖析

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/62c424ac84f947ddaddc38e10c6fb0d3.png)

摄像头工作原理:拍摄景物通过镜头(LENS)，<font color=green>**将生成的光学图像投射到传感器上**，**然后光学图像被转换成电信号，电信号再经过A/D(模数转换)变成数字信号**，**数字信号经过DSP加工处理**，</font>再被送到手机处理器中进行处理，最终转换成手机屏幕上能够看到的图像。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c5cbe789be9a4bada8a7080901bb5f1f.png)

> **CCD (Charge Couple Device)** : **电荷耦合器件 **
>
> **CMOS (Complementary Metal Oxide Semiconductor):互补金属氧化物半导体**

## 1.图像传感器(Sensor)

**图像传感器**：是一种半导体芯片，其表面包含有几十万到几百万个感光二极管，<font color=green>**这些感光二极管受到照射时，就会产生电荷(光信号->电信号)**</font>

## 2.CCD和CMOS比较

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dd2a539dc9024e64ac0950774d47733b.png)

## 3.ISP(Image Signal Processor)

**ISP(Image Signal Processor)即图像信号处理**， 主要作用是对前端图像传感器输出的信号做后期处理，依赖于 ISP 才能在不同的光学条件下都能较好的还原现场细节。

ISP一般用来处理Image Sensor（图像传感器）的输出数据，如做`AEC`（自动曝光控制）、`AGC`（自动增益控制）、`AWB`（自动白平衡）、色彩校正、`Gamma` 校正、`Auto Black Level`、`Auto White Level` 等等功能的处理。

### (1)AEC(Automatic Exposure Control)

AEC(Automatic Exposure Control)自动曝光；

- 当外界光线较弱时, CMOS成像芯片工作电流较小,所成图像偏暗,这时要**适当增加曝光时间进行背光补偿**;
- 光线充足或较强时,要适当减少曝光时间,防止曝光过度,图像发白。

### (2)AWB(Automatic White Balance)

AWB(Automatic White Balance) 自动白平衡；

- 对色温环境所造成的颜色偏差和拍摄一起本身所固有的色彩通道增益的偏差进行统一补偿，从而让获得的图像能**正确反映物体的真实色彩**。

### (3)AGC(Automatic Gain Control)

AGC(Automatic Gain Control)自动增益控制；

- **使放大电路的增益自动地随信号强度而增强的自动控制**方法；
- 当弱信号输入，线性放大电路工作；反之启动压缩放大电路。

### (4)色彩校正(Color Correction)

色彩校正(Color Correction)；颜色饱和度(Saturation)、亮度(Brightness)的调整;

### (5)ABL、AWL(Auto Black Level、Auto White Level)

ABL、AWL(Auto Black Level、Auto White Leve)自动黑、白电平;

- 向上调节黑电平(**黑电平是指图像数据为0时对应的信号电平**)，图片将变暗；
- 低于黑电平的像素会全部显示成黑色以遮盖暗场噪点；
- 一般来说黑电平数值越低说明屏幕在暗场的显示效果越好。

### (6)Gamma 校正

Gamma矫正，原因是人眼睛的非线性特性，亮度发生变化时，人眼感受到的不是成倍的关系

## 4.DSP(Digital Signal Processing)

**DSP(Digital Signal Processing)**:

- 通过一系列复杂的数学算法运算，**对数字图像信号参数进行优化处理**(**RGB/YUV->JPEG**),并把处理后的信号传输到存储或显示部件

# 三、Camera常用参数介绍

## **1.图像解析度/分辨率(Resolution)**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/49134a9d4c5c48e2a9045a3df872d104.png)

## 2.**图像格式(imageFormat/Colorspace)**

像素格式，比如:RGB565，YUV4:2:2等。

## 3.**自动白平衡调整(AWB)**

白平衡指不管在任何光源下，**都能将白色物体还原为白色**。

白平衡是描述显示器或相机中红、绿、蓝三基色混合生成后白色精确度的一项指标。

## 4.**色彩深度**

色彩深度在计算机图形学领域中表示在位图或者视频帧缓冲区中**储存1像素的颜色所用的位数**，它也称为位/像素（bpp）。

- **色彩深度越高，可用的颜色就越多。现在市场上的摄像头均已达到24位，有的甚至是32位。**

## 5.**图像噪音**

指的是图像中的杂点干扰。

## 6.**帧率**

帧率指的就是1秒钟时间里传输、显示图片的帧数，每一帧就是一个画面，快速连续的多帧就形成了运动的动态效果。

- 高的帧率可以得到更加流畅，更加逼真的画面。

## 7.**码流**

码流(Data Rate)是指视频文件单位时间内使用的数据流量，也叫码率或码流率，**单位是kb/s或者Mb/s**。

- 同样分辨率下，视频文件的码流越大，画面质量就越高。

## 8.**曝光**

**曝光就是图像的明暗程度** ，照片太暗称为曝光不足 ，照片太亮称为曝光过度

# 四、Camera常用接口

Camera接口实在多种多样，总的来说分为三大类：

- **Parallel（并口）/DVP接口/CSI接口**、
- **Serial（串口）/MIPI-CSI2接口**
- **USB口**。

## 1.DVP接口

并口一般称**DVP接口(Digital Video Port)**，也称为**CSI(CMOS Sensor Interface)接口**,

- 就是将图像信号按照8bit ,12bit等数据格式，在时钟的作用下，一次性传输8位或者12位，
- 这种方式最大的特点就是需要的数据线较多，
- 时钟PCLK极限约在96MHZ左右，且走线长度不能过长，**所以DVP的最大速率最好控制在72M以下**。
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/afb9946ade9841739acab08af4075bf4.png)

### (1) 输入总线介绍

- **PWDN:camera的使能管脚**,
  - 有两种配置方式,一种为standby,一种为normal work,
  - 当设置为standby时,一切对于camea的操作都是无效的,包括复位,**所以一定要将PWDN管脚设置为normal模式,否则RESET无效**

- **RESET:camera的复位管脚**,此方式为硬复位模式,camera的各个IO口恢复到出厂默认状态,
  - **只有当XCLK开启后,将RESET置为低,硬复位才有效,否则复位无效**

- **XCLK:是camera的工作时钟管脚**,此管脚为SOC提供camera的工作时钟，
  - 也可以外接一个晶振给Camera提供时钟信号

- **IIC:`是camera和SOC通信的I2C总线`**，
  - 主要用来对Camera Sensor进行一些参数的配置，**如分辨率、数据格式**等。


### (2)输出总线介绍

- **DATA :camera数据管脚**,此数据脚可以输出的格式为YUV,RGB,JPEG等
- **VSYNC:camera的帧同步信号管脚**。一个VYSNC信号结束表示一帧（即一个画面）的数据已经输出完毕
- **HSYNC:camera行同步信号管脚**。一个HSYNC信号结束表示一行的数据已经输出完毕。
- **PCLK:像素同步信号管脚**。一个PCLK信号结束表示**一个像素点的数据已经输出完毕**。

### (3)注意点

<font color="#fd6f01">**XCLK(MCLK)是由SOC提供给摄像头到工作时钟，从而使摄像头工作**</font>，

**PCLK是摄像头自己产生的时钟信号，通过摄像头sensor的内部PLL电路可以产生不同频率的PCLK**。

## 2.MIPI-CSI2接口

MIPI接口：移动产业处理器接口(Mobile Industry Processor Interface：简称MIPI ),

- 1对时钟线，1~4 lane对数据线，且都是差分走线，有比较强的抗干扰性。
- 这种接口多用于手机接口，一些监控用的CMOS如SONY IMX185,OV5640等传感器接口；

> `4lane`的意思是有四组`DATAP/DATAN`线,
>
> `2lane`的意思是2组`DATAP/DATAN`线,最大支持4通道数据传输,单线传输速度高达2Gb/s

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/539537e6dafa41f591baf8f885d7d9d6.png)

> **CCI（Camera Control Interface）摄像头控制接口**。在MIPI中，充当着控制接口的作用，提供mipi接口sensor的控制传输通道。

## 3.USB接口

> - 我们先介绍一下**UVC**是什么，UVC全称 USB video class或者USB device class,是Microsoft 与另外几家设备厂联合推出的**USB视频捕获设备定义的协议标准**，目前已经成为USB ORG标准之一。
>
> - 如今的**主流操作系统都已经提供UVC设备驱动**，因此符合UVC规格的硬件设备在不需要安装任何驱动程序下就可以在主机中正常使用。

# 五、Camera 输出的数据格式

## 1.**RAW data** 格式

CMOS 在将光信号转换为电信号时的高低电平的原始记录，**单纯地将没有进行任何处理的图像数据进行存储**，即摄像元件直接得到的电信号进行数字化处理而得到的。每个pixel只能感光R光或者B光或者G光，每个像素此时存贮的是单色的，即RAW DATA。后续需要ISP处理还原成三基色。

## 2.RGB格式

采用这种编码方法，每种颜色都可用三个变量来表示红色、绿色以及蓝色的强度。每一个像素有三原色 R 红色、G 绿色、B 蓝色组成。

## 3.YUV格式

其中“Y”表示明亮度(Luminance 或 Luma),就是灰阶值；而“U”和“V”表示色度(Chrominance 或 Chroma),是描述影像色彩及饱和度，用于指定像素的颜色。

## 4.JPEG格式

有些sensor，特别是低分辨率的，其自带JPEG engine，可以直接输出压缩后的jpg格式的数据

# 六、**数字视频信号标准ITU-R BT.601和ITU-R BT.656**

## 1.标准命名解析

ITU = International Telecommunication Union (联合国)国际电信联盟

R = Radio communication Sector 无线电部

BT = Broadcasting service (television) 广播服务(电视)

> **ITU-R BT601/656和CCIR601/656的前世今生**
>
> CCIR (Consultative Committee of International Radio，国际无线电咨询委员会) 是国际无线电咨询委员会的简称。成立于1927年，是国际电信联盟（ITU）的常设机构之一。主要职责是研究无线电通信和技术业务问题，并对这类问题通过建议书。从1993年3月1日起，与国际频率登记委员会（IFRB）合并，成为现今国际电信联盟（ITU）无线电通信部门，简称ITU-R。之后更新的CCIR601/656建议书就正式更名为ITU-RBT601和ITU-R BT656。

## 2.**ITU-R BT.601与ITU-R BT.656 标准区别**

ITU601与ITU656都具有8根数据线并行传输数据，**差别在于前者还需要场频和行频传输线**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/300ee35f488546c487d7a792c191dfd4.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b4ee0d8ae0d6449bbb10f875397a19f8.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/13e600dae83e4cf9a9019efd5fc413bf.png)

> **EVA代表有效视频结束**,**SAV代表有效视频开始**。

- 两者的区别在于：这两种标准都是video transmission 的 interface，在video frame format 的规格应该是相同的。
- 两者的差别在于interface 规格的不同，
  - **在CCIR656中，有8bit 的data bus和clock 的信号，也就是说CCIR656 是同步传输的，decoder端不用自己产生clock。**
  - 在CCIR601中，**信号內还包含了其它两个同步信号：Horizontal Synchronization 和 Vertical Synchronization**，decoder 要自己去锁定這个同步信号，再自己产生clock 來解。
  - **CCIR 656需从DATA 中解出VS、HS**, **CCIR 601 則直接使用输入的VS、HS 即可**。

# <font color="#fd6f01">2.实战篇1-通过IIC对摄像头配置</font>

# 一、硬件原理图阅读



## 1.原理图

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1a489929a96440d7a34bbb2e61da9013.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/86569e2f2f774f26b853158a2693a6ad.png)



## 2.OV2640接口定义

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/73294eb909d04be784b8bfbc05d6bd81.png)

# 二、OV2640摄像头

The OV2640 CAMERACHIPTM is a **low voltage CMOS image sensor** that provides the full functionality of a single-chip UXGA (1632x1232) camera and image processor i**n a small footprint package**. 

The OV2640 provides **full-frame**, sub-sampled, **scaled** or windowed 8-bit/10-bit images in a wide range of formats, controlled through the **Serial Camera Control Bus (SCCB) interface**.

> - OV2640 CAMERACHIPTM是一款低电压互补式金属氧化物半导体图像传感器，采用小型封装，提供单芯片UXGA（1632x1232）相机和图像处理器的全部功能。
> - OV2640通过串行相机控制总线（SCCB）接口控制，提供各种格式的全帧、子采样、**缩放**或窗口化8位/10位图像。

This product has an image array capable of operating at **up to 15 frames per second (fps)** in UXGA resolution with complete user control over **image quality, formatting and output data transfer**. 

All required image processing functions, including **exposure control, gamma, white balance, color saturation, hue control, white pixel canceling, noise canceling,** and more, **are also programmable through the SCCB interface**. 

The OV2640 also includes a **compression engine** for increased processing power. In addition, **OmniVision CAMERACHIPS** use proprietary sensor technology to improve image quality by reducing or eliminating common lighting/electrical sources of image contamination, such as fixed pattern noise, smearing, etc., to produce a clean, fully stable color image.

> - 该产品具有一个图像阵列，能够以高达每秒15帧（fps）的UXGA分辨率运行，用户可以完全控制画质、格式化和输出数据搬迁。
> - 所有必需的图像处理功能，包括曝光控制、伽马、白平衡、色彩饱和度、色调控制、白像素消除、噪声消除等，也可通过SCCB接口进行编程。
> - OV2640还包括一个**压缩引擎**，以提高处理能力。此外，OmniVision CAMERACHIPS使用专有的传感器技术，通过减少或消除图像污染的常见照明/电气来源（如固定图案噪声、涂抹等）来提高画质，以产生干净、完全稳定的彩色图像。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ee11a11bfff146daabe433ea92819098.png)

## 1.控制寄存器

控制寄存器配置摄像头的相关参数，如**对比度、曝光参数**等，**通过SCCB(Serial Camera Control Bus)（与I2C类似）外设的SIO_C和SIO_D引脚写入**。



## 2.通信、控制信号及时钟

其中**PCLK、HREF及VSYNC**分别是像素同步时钟、行同步信号以及帧同步信号。RESETB引脚为低电平时，用于复位整个传感器芯片，PWDN用于控制芯片进入低功耗模式。

`XCLK`是用于驱动整个传感器芯片的时钟信号，由**外部时钟源**（**外接晶振或由外部控制器提供**）输入到OV2640；

而**PCLK是OV2640输出数据时的同步信号，由OV2640输出**。



## 3.**感光矩阵**

The OV2640 sensor has an **image array of 1632 columns by 1232 rows (2,010,624 pixels).**

> - OV2640传感器具有1632列乘1232行（2,010,624像素）的图像阵列。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c9be0c77989149a7bf3d124a21c9f003.png)

The color filters are arranged in a **Bayer pattern**. The primary color BG/GR array is arranged in **line-alternating fashion.** 

Of the 2,010,624 pixels, **1,991,040 (1632x1220) are active**. The other pixels are used for **black level calibration and interpolation.**

> - 滤色片以**拜耳模式排列**。原色BG/GR阵列以线交替方式排列。
> - 在2,010,624个像素中，1,991,040（1632x1220）是活动的。其他像素用于黑色电平校准和插值。



## 4.数据采集



### (1)**Analog Amplifier**

When the column sample/hold circuit has sampled **one row of pixels**, the pixel data will **shift out one-by-one into an analog amplifier.**

> 当列采样/保持电路对一行像素进行采样时，像素数据将逐一 移出到模拟放大器中。

#### **Gain Control**

The **amplifier gain** can either be programmed by the user or controlled by the internal automatic gain control circuit (AGC).

> 放大器增益可以由用户编程或由内部自动增益控制电路（AGC）控制。



### (2)**10-Bit A/D Converters**

After the **analog amplifier**, the bayer pattern Raw signal is fed to two 10-bit analog-to-digital (A/D) converters, one for G channel and one shared by the BR channels. 

These A/D converters operate at **speeds up to 20 MHz and are fully synchronous to the pixel rate** (actual conversion rate is related to the frame rate).

> 在**模拟放大器**之后，拜耳模式原始信号被馈送到两个10位模数转换器，一个用于G通道，一个由BR通道共享。
>
> 这些A/D转换器以高达20 MHz的速度工作，并且与像素速率完全同步（实际转换速率与帧率有关）。



### (3)**Channel Balance**

The amplified signals are then balanced with a channel balance block. In this block, the Red/Blue channel gain is increased or decreased to match Green channel luminance level.

> 然后用通道平衡块平衡放大的信号。在这个块中，红/蓝通道增益被增加或减少以匹配绿色通道亮度水平。

#### **Balance Control**

Channel Balance can be done manually by the user or by the internal automatic white balance (AWB) controller.

> 通道平衡可以由用户手动完成，也可以由内部自动白平衡（AWB）控制器完成。



### (4)**Black Level Compensation**

After the pixel data has been digitized, **black level Calibration can be applied before the data is output**. 

The black level calibration block subtracts the average signal level of optical black pixels to compensate for the dark current in the pixel output. The user can disable black level calibration.

> 像素数据数字化后，**可以在数据输出之前应用黑色电平校准**。
>
> 黑色电平校准块减去光学黑色像素的平均信号电平以补偿像素输出中的暗电流。用户可以禁用黑色电平校准。



## 5.**数据输出**

包含了`DSP`处理单元，它会根据控制寄存器的配置做一些基本的图像处理运算，**如色彩饱和度调整、边缘增强**等。这部分还包含了**图像格式转换单元及压缩单元**，转换出的数据最终通过Y0-Y9引脚输出。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/43808f9d4b794282aa06308311d92545.png)



# 三、SCCB协议



## 1. 介绍

OmniVision Technologies, Inc. has **defined and deployed the Serial Camera Control Bus (SCCB)**, a 3-wire serial bus, for control of most of the functions in OmniVision’s family of CAMERACHIPSTM. 

In reduced pin package parts, the SCCB operates in a modified 2-wire serial mode.

> - OmniVision Technologies， Inc.已经**定义并部署了串行摄像机控制总线（SCCB）**，这是一种3线串行总线，用于控制OmniVision CAMERACHIPSTM系列中的大多数功能。
> - 在减少引脚封装部件中，SCCB以修改后的2线串行模式运行。

OmniVision CAMERACHIPS **will only operate as slave devices** and the companion **back-end interface must assert as the master**. 

One SCCB master device can be connected to the SCCB to control at least one SCCB slave device. An optional suspend-control signal provides the **capability for the SCCB master device to power down the SCCB system**. Refer to Figure 1-1 for the SCCB functional diagram illustrating the 3-wire connection.

> - OmniVision CAMERACHIPS只能作为从设备运行，配套的后端接口必须作为主设备断言。
> - 一个SCCB主设备可以连接到SCCB以控制至少一个SCCB从设备。可选的挂起控制信号提供了SCCB主设备关闭SCCB系统电源的能力。有关说明3线连接的SCCB功能图，请参阅图1-1。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/88f77ab5dca7470bb512512b6bd510ce.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/54bbc74035d545bdbd3326674f8bc52b.png)



## 2. **2-Wire SCCB Interface**

The **modified 2-wire** implementation allows for a SCCB **master device to interface with only one slave device**. 

This 2-wire application is implemented in the CAMERACHIP reduced pin package products **where the SCCB_E signal is not available externally**. Refer to Figure 1-2 for the functional diagram of the 2-wire implementation for the SCCB interface.

> - 修改后的双线实现允许SCCB主设备仅与一个从设备接口。
> - 此双线应用程序在CAMERACHIP缩减引脚封装产品中实现，其中外部SCCB_E信号不可用。有关SCCB接口的双线实现的功能图，请参阅图1-2。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5ac2561319944b1e90c07c8373713b28.png)



## **3.Transmission Phases**

A phase contains a total of 9 bits. **The 9 bits consist of an 8-bit sequential data transmission followed by a ninth bit.** 

**The ninth bit is a Don’t-Care bit or an NA bit,** depending on whether the data transmission is a write or read. 

The **maximum number of phases** that can be included in a transmission is **three**. The Most Significant Bit **(MSB)** is always asserted first for each phase.

> - 一个相位总共包含9位。这9位包括8位顺序数据传输，然后是第9位。
> - 第9位是不关心位还是NA位，具体取决于数据传输是写入还是读取。<font color=green>**(即，与IIC不同的是，第9位应答位不起作用，只是作为一个字节传输结束的标志)**</font>
> - 传输中可以包含的最大相位数为3个。对于每个相位，始终首先声明最高有效位（MSB）。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/91633ad2e58747c786b7a2025730b415.png)



### (1)**Phase 1 — ID Address**

Phase 1 is asserted by the master to **identify the selected slave** to which the data is read or written. 

**Each slave has a unique ID address**. The ID address is comprised of seven bits, ordered from bit 7 to bit 1, and can identify up to 128 slaves. **The eighth bit, bit 0, is the read/write selector bit** that specifies the transmission direction of the current cycle. 

**A logical 0 represents a write cycle and a logical 1 represents a read cycle**.

> - 阶段1由主服务器断言，以识别读取或写入数据的选定从服务器。
> - 每个从服务器都有一个唯一的ID地址。ID地址由7位组成，从第7位到第1位排序，最多可识别128个从服务器。第八位，第0位，是读/写选择器位，指定当前周期的传输方向。
> - 逻辑0代表一个写周期，逻辑1代表一个读周期。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5f593fd2e8ff4049ad8def0aab87eeb9.png)

### (2)**Phase 2 — Sub-address/Read Data**

**Either the master or the slave(s)** may assert a phase 2 transmission. 

A phase 2 transmission asserted by the **master identifies the sub-address of the slave(s) the master intends to access**.

 A phase 2 transmission asserted by **the slave(s) indicates the read data that the master will receive**. The slave(s) recognize the **sub-address of this read data according to the previous 3-phase or 2-phase write transmission cycles.**

> - 主站或从站可以断言第二阶段传输。
> - 主站断言的第二阶段传输标识主站打算访问的从站的子地址。
> - 从站断言的第二阶段传输指示主站将接收的读取数据。从站根据之前的3阶段或2阶段写入传输周期识别此读取数据的子地址。
> - <font color=green>**（即，主端通过这个字节找到要写到从设备寄存器的地址，从设备通过这个字节放入主设备要读的数据的寄存器，下个字节是用来往指定寄存器中放数据的）**</font>



### (3) **Phase 3 — Write Data**

Only the master may assert the phase 3 transmission. T**he phase 3 transmission contains the actual data the master intends to write to the slave(s)**.

> 只有主机可以断言第3阶段传输。第3阶段传输包含主机打算写入从属设备的实际数据。



### (4) **Don’t-Care Bit**

The Don’t-Care bit is the ninth bit of a **master-issued transmission** (ID address, sub-address, and write data). 

The master will continue to assert transmission phases until the transmission cycle is complete. The master also assumes that there is no transmission error during data transmissions. **The purpose of the Don’t-Care bit is to indicate the completion of the transmission.**

> - 不关心位是主设备发出的传输（ID地址、子地址和写入数据）的第九位。
> - 主设备将继续断言传输阶段，直到传输周期完成。**主设备还假定在数据传输过程中没有传输错误。不关心位的目的是指示传输完成。**



# 四、OV2640摄像头编程思路介绍



## 1.IIC控制器GPIO口初始化

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/17b3515cee4b4b12852c47b686e59719.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/66fbf5d7e3824cd994e142fce4f4a34e.png)

> <font color="#fd6f01">**注意：I2c2管脚复用，因有三个管脚都可以作为控制管脚，需要经过菊花链选择**</font>
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bfb4c9849a534d3291759bc8117a18bd.png)
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/231b041396c249ffb052c9885b8de33b.png)

```c
void ov2640_pin_init() {
    /* 1. i2c SDl SAL */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);

    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);

    /* 2. daisy chain select 
        DAISY [1-0] 10 UART5_RX_DATA_ALT2 
     */
    // IOMUXC_I2C2_SCL_SELECT_INPUT = (2 << 0);
    // IOMUXC_I2C2_SDA_SELECT_INPUT = (2 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT |= (0x2 << 0);

    IOMUXC_I2C2_SDA_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SDA_SELECT_INPUT |= (0x2 << 0);

    /* 3. RESET IO*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 |=  (0x5 << 0);

}
```



## 2.IIC控制器初始化

```c
iic_con_init(I2C2);
```



## 3.重置OV2640摄像头模块

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1b7f5cf0844645f8a46ff97934141a2b.png)

```c
void ov2640_hardware_reset() {
    //output low level for reset(先拉低复位，再拉高还原)
    GPIO1->GDIR |= (1 << 18);
    GPIO1->DR &= ~(1 << 18);
    gpt_delay_ms(500);

    GPIO1->DR |= (1 << 18);
    gpt_delay_ms(500);
}
```



## 4.编写OV2640内部寄存器读写函数



### (1)内部寄存器读函数

```c
#define OV2640_SLAVE_ADDR_READ  0x61

uint8_t ov2640_read_register(uint8_t regaddr) {
    int ret;
    uint8_t rx_buf[1];
    uint8_t tx_buf[] = {regaddr};

    /* 1. start */
    iic_con_start(I2C2);

    /* 2. send slave + write bit*/
    iic_con_send_slave_addr(I2C2, OV2640_SLAVE_ADDR_WRITE);

    /* 3. send regaddr*/
    iic_con_send_data(I2C2, tx_buf, sizeof(tx_buf));

    /* 4. restart */
    iic_con_restart(I2C2);

    /* 5. send slave + read bit*/
    iic_con_send_slave_addr(I2C2, OV2640_SLAVE_ADDR_READ);

    /* 6. read regaddr */
    iic_con_read_data(I2C2, rx_buf, sizeof(rx_buf));

    /* 7. stop */
    iic_con_stop(I2C2);

    return rx_buf[0];
}
```



### (2)内部寄存器写函数

```c
#define OV2640_SLAVE_ADDR_WRITE 0x60

void ov2640_write_register(uint8_t ragaddr, uint8_t regval) {
    uint8_t tx_buf[] = {ragaddr, regval};
    /* 1. start */
    iic_con_start(I2C2);

    /* 2. send slave + write bit*/
    iic_con_send_slave_addr(I2C2, OV2640_SLAVE_ADDR_WRITE);

    /* 3. send regaddr + data*/
    iic_con_send_data(I2C2, tx_buf, sizeof(tx_buf));

    /* 4. stop */
    iic_con_stop(I2C2);
}
```



### (3)读取产品ID

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/deb9970bd6464f3a993192341f1b0105.png)

```c
#define OV2640_PIDH_REG_ADDR  0x0a
#define OV2640_PIDL_REG_ADDR  0x0b

void read_ov2640_pid() {
     uint8_t pid[2];

    pid[1] = ov2640_read_register(OV2640_PIDH_REG_ADDR);
    gpt_delay_ms(10);
    pid[0] = ov2640_read_register(OV2640_PIDL_REG_ADDR);
    gpt_delay_ms(10);
    
    uart_printf("PIDH:%#x PIDL:%#x\r\n",pid[1],pid[0]);

}
```

#### 测试结果

```c
void ov2640_test(void)
{
    ov2640_init();

    while(1){
        read_ov2640_pid();
        gpt_delay_sec(1);
    }

    return;
}
```

> 注意：
>
> <font color="#fd6f01">**1，控制器初始化，需要强制选择**</font>
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9bb4f6d1521e478187594f36b3aaa300.png)
>
> ```c
> /*1.SCL*/
>     IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
>     IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);
>      
>     /*SDA*/
>     IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
>     IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);
> ```
>
> 
>
> <font color="#fd6f01">**2，此硬件连续读取两个寄存器，不能太快，要延时一点时间（其它芯片可能不需要）**</font>
>
> ```c
> pid[1] = ov2640_read_register(OV2640_PIDH_REG_ADDR);
> gpt_delay_ms(10);
> pid[0] = ov2640_read_register(OV2640_PIDL_REG_ADDR);
> gpt_delay_ms(10);
> ```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4e5792fe25f14d2fbd588560c0a17e73.png)

## 5.写入寄存器序列值



### (1)ov2640_reg.h

```c
/*
 * uHAL OmniVision OV2640 camera driver
 *
 * Copyright (C) 2016, Marek Koza, qyx@krtko.org
 *
 * This file is part of uMesh node firmware (http://qyx.krtko.org/projects/umesh)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

/**
 * The following part is borrowed from the linux ov2640 driver. Some of the
 * registers are named but still there are many without any documentation.
 * Another possible source is the ArduCam project but it is not documented
 * and there are long arrays of magic values only.
 */

/** @todo relicense to gplv3 or bsd */

/*
 * Copyright (C) 2010 Alberto Panizzo <maramaopercheseimorto@gmail.com>
 *
 * Based on ov772x, ov9640 drivers and previous non merged implementations.
 *
 * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
 * Copyright (C) 2006, OmniVision
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include <stdint.h>
#include <stdlib.h>

#define VAL_SET(x, mask, rshift, lshift) ((((x) >> rshift) & mask) << lshift)

/*
 * DSP registers
 * register offset for BANK_SEL == BANK_SEL_DSP
 */
#define R_BYPASS 0x05           /* Bypass DSP */
#define R_BYPASS_DSP_BYPAS 0x01 /* Bypass DSP, sensor out directly */
#define R_BYPASS_USE_DSP 0x00   /* Use the internal DSP */
#define QS 0x44                 /* Quantization Scale Factor */
#define CTRLI 0x50
#define CTRLI_LP_DP 0x80
#define CTRLI_ROUND 0x40
#define CTRLI_V_DIV_SET(x) VAL_SET(x, 0x3, 0, 3)
#define CTRLI_H_DIV_SET(x) VAL_SET(x, 0x3, 0, 0)
#define HSIZE 0x51 /* H_SIZE[7:0] (real/4) */
#define HSIZE_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define VSIZE 0x52 /* V_SIZE[7:0] (real/4) */
#define VSIZE_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define XOFFL 0x53 /* OFFSET_X[7:0] */
#define XOFFL_SET(x) VAL_SET(x, 0xFF, 0, 0)
#define YOFFL 0x54 /* OFFSET_Y[7:0] */
#define YOFFL_SET(x) VAL_SET(x, 0xFF, 0, 0)
#define VHYX 0x55 /* Offset and size completion */
#define VHYX_VSIZE_SET(x) VAL_SET(x, 0x1, (8 + 2), 7)
#define VHYX_HSIZE_SET(x) VAL_SET(x, 0x1, (8 + 2), 3)
#define VHYX_YOFF_SET(x) VAL_SET(x, 0x3, 8, 4)
#define VHYX_XOFF_SET(x) VAL_SET(x, 0x3, 8, 0)
#define DPRP 0x56
#define TEST 0x57 /* Horizontal size completion */
#define TEST_HSIZE_SET(x) VAL_SET(x, 0x1, (9 + 2), 7)
#define ZMOW 0x5A /* Zoom: Out Width  OUTW[7:0] (real/4) */
#define ZMOW_OUTW_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define ZMOH 0x5B /* Zoom: Out Height OUTH[7:0] (real/4) */
#define ZMOH_OUTH_SET(x) VAL_SET(x, 0xFF, 2, 0)
#define ZMHH 0x5C /* Zoom: Speed and H&W completion */
#define ZMHH_ZSPEED_SET(x) VAL_SET(x, 0x0F, 0, 4)
#define ZMHH_OUTH_SET(x) VAL_SET(x, 0x1, (8 + 2), 2)
#define ZMHH_OUTW_SET(x) VAL_SET(x, 0x3, (8 + 2), 0)
#define BPADDR 0x7C /* SDE Indirect Register Access: Address */
#define BPDATA 0x7D /* SDE Indirect Register Access: Data */
#define CTRL2 0x86  /* DSP Module enable 2 */
#define CTRL2_DCW_EN 0x20
#define CTRL2_SDE_EN 0x10
#define CTRL2_UV_ADJ_EN 0x08
#define CTRL2_UV_AVG_EN 0x04
#define CTRL2_CMX_EN 0x01
#define CTRL3 0x87 /* DSP Module enable 3 */
#define CTRL3_BPC_EN 0x80
#define CTRL3_WPC_EN 0x40
#define SIZEL 0x8C /* Image Size Completion */
#define SIZEL_HSIZE8_11_SET(x) VAL_SET(x, 0x1, 11, 6)
#define SIZEL_HSIZE8_SET(x) VAL_SET(x, 0x7, 0, 3)
#define SIZEL_VSIZE8_SET(x) VAL_SET(x, 0x7, 0, 0)
#define HSIZE8 0xC0 /* Image Horizontal Size HSIZE[10:3] */
#define HSIZE8_SET(x) VAL_SET(x, 0xFF, 3, 0)
#define VSIZE8 0xC1 /* Image Vertical Size VSIZE[10:3] */
#define VSIZE8_SET(x) VAL_SET(x, 0xFF, 3, 0)
#define CTRL0 0xC2 /* DSP Module enable 0 */
#define CTRL0_AEC_EN 0x80
#define CTRL0_AEC_SEL 0x40
#define CTRL0_STAT_SEL 0x20
#define CTRL0_VFIRST 0x10
#define CTRL0_YUV422 0x08
#define CTRL0_YUV_EN 0x04
#define CTRL0_RGB_EN 0x02
#define CTRL0_RAW_EN 0x01
#define CTRL1 0xC3 /* DSP Module enable 1 */
#define CTRL1_CIP 0x80
#define CTRL1_DMY 0x40
#define CTRL1_RAW_GMA 0x20
#define CTRL1_DG 0x10
#define CTRL1_AWB 0x08
#define CTRL1_AWB_GAIN 0x04
#define CTRL1_LENC 0x02
#define CTRL1_PRE 0x01
#define R_DVP_SP 0xD3 /* DVP output speed control */
#define R_DVP_SP_AUTO_MODE 0x80
#define R_DVP_SP_DVP_MASK 0x3F /* DVP PCLK = sysclk (48)/[6:0] (YUV0); \
                                *          = sysclk (48)/(2*[6:0]) (RAW);*/
#define IMAGE_MODE 0xDA        /* Image Output Format Select */
#define IMAGE_MODE_Y8_DVP_EN 0x40
#define IMAGE_MODE_JPEG_EN 0x10
#define IMAGE_MODE_YUV422 0x00
#define IMAGE_MODE_RAW10 0x04 /* (DVP) */
#define IMAGE_MODE_RGB565 0x08
#define IMAGE_MODE_HREF_VSYNC 0x02  /* HREF timing select in DVP JPEG output \
                                     * mode (0 for HREF is same as sensor) */
#define IMAGE_MODE_LBYTE_FIRST 0x01 /* Byte swap enable for DVP             \
                                     *    1: Low byte first UYVY (C2[4] =0) \
                                     *        VYUY (C2[4] =1)               \
                                     *    0: High byte first YUYV (C2[4]=0) \
                                     *        YVYU (C2[4] = 1) */
#define RESET 0xE0                  /* Reset */
#define RESET_MICROC 0x40
#define RESET_SCCB 0x20
#define RESET_JPEG 0x10
#define RESET_DVP 0x04
#define RESET_IPU 0x02
#define RESET_CIF 0x01
#define REGED 0xED /* Register ED */
#define REGED_CLK_OUT_DIS 0x10
#define MS_SP 0xF0   /* SCCB Master Speed */
#define SS_ID 0xF7   /* SCCB Slave ID */
#define SS_CTRL 0xF8 /* SCCB Slave Control */
#define SS_CTRL_ADD_AUTO_INC 0x20
#define SS_CTRL_EN 0x08
#define SS_CTRL_DELAY_CLK 0x04
#define SS_CTRL_ACC_EN 0x02
#define SS_CTRL_SEN_PASS_THR 0x01
#define MC_BIST 0xF9       /* Microcontroller misc register */
#define MC_BIST_RESET 0x80 /* Microcontroller Reset */
#define MC_BIST_BOOT_ROM_SEL 0x40
#define MC_BIST_12KB_SEL 0x20
#define MC_BIST_12KB_MASK 0x30
#define MC_BIST_512KB_SEL 0x08
#define MC_BIST_512KB_MASK 0x0C
#define MC_BIST_BUSY_BIT_R 0x02
#define MC_BIST_MC_RES_ONE_SH_W 0x02
#define MC_BIST_LAUNCH 0x01
#define BANK_SEL 0xFF /* Register Bank Select */
#define BANK_SEL_DSP 0x00
#define BANK_SEL_SENS 0x01

/*
 * Sensor registers
 * register offset for BANK_SEL == BANK_SEL_SENS
 */
#define GAIN 0x00 /* AGC - Gain control gain setting */
#define COM1 0x03 /* Common control 1 */
#define COM1_1_DUMMY_FR 0x40
#define COM1_3_DUMMY_FR 0x80
#define COM1_7_DUMMY_FR 0xC0
#define COM1_VWIN_LSB_UXGA 0x0F
#define COM1_VWIN_LSB_SVGA 0x0A
#define COM1_VWIN_LSB_CIF 0x06
#define REG04 0x04           /* Register 04 */
#define REG04_DEF 0x20       /* Always set */
#define REG04_HFLIP_IMG 0x80 /* Horizontal mirror image ON/OFF */
#define REG04_VFLIP_IMG 0x40 /* Vertical flip image ON/OFF */
#define REG04_VREF_EN 0x10
#define REG04_HREF_EN 0x08
#define REG04_AEC_SET(x) VAL_SET(x, 0x3, 0, 0)
#define REG08 0x08                           /* Frame Exposure One-pin Control Pre-charge Row Num */
#define COM2 0x09                            /* Common control 2 */
#define COM2_SOFT_SLEEP_MODE 0x10            /* Soft sleep mode */
                                             /* Output drive capability */
#define COM2_OCAP_Nx_SET(N) (((N)-1) & 0x03) /* N = [1x .. 4x] */
#define PID 0x0A                             /* Product ID Number MSB */
#define VER 0x0B                             /* Product ID Number LSB */
#define COM3 0x0C                            /* Common control 3 */
#define COM3_BAND_50H 0x04                   /* 0 For Banding at 60H */
#define COM3_BAND_AUTO 0x02                  /* Auto Banding */
#define COM3_SING_FR_SNAPSH 0x01             /* 0 For enable live video output after the \
                                              * snapshot sequence*/
#define AEC 0x10                             /* AEC[9:2] Exposure Value */
#define CLKRC 0x11                           /* Internal clock */
#define CLKRC_EN 0x80
#define CLKRC_DIV_SET(x) (((x)-1) & 0x1F) /* CLK = XVCLK/(x) */
#define COM7 0x12                         /* Common control 7 */
#define COM7_SRST 0x80                    /* Initiates system reset. All registers are \
                                           * set to factory default values after which \
                                           * the chip resumes normal operation */
#define COM7_RES_UXGA 0x00                /* Resolution selectors for UXGA */
#define COM7_RES_SVGA 0x40                /* SVGA */
#define COM7_RES_CIF 0x20                 /* CIF */
#define COM7_ZOOM_EN 0x04                 /* Enable Zoom mode */
#define COM7_COLOR_BAR_TEST 0x02          /* Enable Color Bar Test Pattern */
#define COM8 0x13                         /* Common control 8 */
#define COM8_DEF 0xC0                     /* Banding filter ON/OFF */
#define COM8_BNDF_EN 0x20                 /* Banding filter ON/OFF */
#define COM8_AGC_EN 0x04                  /* AGC Auto/Manual control selection */
#define COM8_AEC_EN 0x01                  /* Auto/Manual Exposure control */
#define COM9 0x14                         /* Common control 9 \
                                      * Automatic gain ceiling - maximum AGC value [7:5]*/
#define COM9_AGC_GAIN_2x 0x00             /* 000 :   2x */
#define COM9_AGC_GAIN_4x 0x20             /* 001 :   4x */
#define COM9_AGC_GAIN_8x 0x40             /* 010 :   8x */
#define COM9_AGC_GAIN_16x 0x60            /* 011 :  16x */
#define COM9_AGC_GAIN_32x 0x80            /* 100 :  32x */
#define COM9_AGC_GAIN_64x 0xA0            /* 101 :  64x */
#define COM9_AGC_GAIN_128x 0xC0           /* 110 : 128x */
#define COM10 0x15                        /* Common control 10 */
#define COM10_PCLK_HREF 0x20              /* PCLK output qualified by HREF */
#define COM10_PCLK_RISE 0x10            /* Data is updated at the rising edge of \
                                         * PCLK (user can latch data at the next \
                                         * falling edge of PCLK).                \
                                         * 0 otherwise. */
#define COM10_HREF_INV 0x08             /* Invert HREF polarity: \
                                         * HREF negative for valid data*/
#define COM10_VSINC_INV 0x02            /* Invert VSYNC polarity */
#define HSTART 0x17                     /* Horizontal Window start MSB 8 bit */
#define HEND 0x18                       /* Horizontal Window end MSB 8 bit */
#define VSTART 0x19                     /* Vertical Window start MSB 8 bit */
#define VEND 0x1A                       /* Vertical Window end MSB 8 bit */
#define MIDH 0x1C                       /* Manufacturer ID byte - high */
#define MIDL 0x1D            /* Manufacturer ID byte - low  */
#define AEW 0x24            /* AGC/AEC - Stable operating region (upper limit) */
#define AEB 0x25            /* AGC/AEC - Stable operating region (lower limit) */
#define VV 0x26             /* AGC/AEC Fast mode operating region */
#define VV_HIGH_TH_SET(x) VAL_SET(x, 0xF, 0, 4)
#define VV_LOW_TH_SET(x) VAL_SET(x, 0xF, 0, 0)
#define REG2A 0x2A            /* Dummy pixel insert MSB */
#define FRARL 0x2B            /* Dummy pixel insert LSB */
#define ADDVFL 0x2D           /* LSB of insert dummy lines in Vertical direction */
#define ADDVFH 0x2E           /* MSB of insert dummy lines in Vertical direction */
#define YAVG 0x2F             /* Y/G Channel Average value */
#define REG32 0x32            /* Common Control 32 */
#define REG32_PCLK_DIV_2 0x80 /* PCLK freq divided by 2 */
#define REG32_PCLK_DIV_4 0xC0 /* PCLK freq divided by 4 */
#define ARCOM2 0x34           /* Zoom: Horizontal start point */
#define REG45 0x45            /* Register 45 */
#define FLL 0x46              /* Frame Length Adjustment LSBs */
#define FLH 0x47              /* Frame Length Adjustment MSBs */
#define COM19 0x48            /* Zoom: Vertical start point */
#define ZOOMS 0x49            /* Zoom: Vertical start point */
#define COM22 0x4B            /* Flash light control */
#define COM25 0x4E            /* For Banding operations */
#define BD50 0x4F             /* 50Hz Banding AEC 8 LSBs */
#define BD60 0x50             /* 60Hz Banding AEC 8 LSBs */
#define REG5D 0x5D            /* AVGsel[7:0],   16-zone average weight option */
#define REG5E 0x5E            /* AVGsel[15:8],  16-zone average weight option */
#define REG5F 0x5F            /* AVGsel[23:16], 16-zone average weight option */
#define REG60 0x60            /* AVGsel[31:24], 16-zone average weight option */
#define HISTO_LOW 0x61        /* Histogram Algorithm Low Level */
#define HISTO_HIGH 0x62       /* Histogram Algorithm High Level */

#define MANUFACTURER_ID 0x7FA2
#define PID_OV2640 0x2642
#define VERSION(pid, ver) ((pid << 8) | (ver & 0xFF))

struct regval_list
{
    uint8_t reg_num;
    uint8_t value;
};

/* Supported resolutions */
enum ov2640_width
{
    W_QCIF = 176,
    W_QVGA = 320,
    W_CIF = 352,
    W_VGA = 640,
    W_SVGA = 800,
    W_XGA = 1024,
    W_SXGA = 1280,
    W_UXGA = 1600,
};

enum ov2640_height
{
    H_QCIF = 144,
    H_QVGA = 240,
    H_CIF = 288,
    H_VGA = 480,
    H_SVGA = 600,
    H_XGA = 768,
    H_SXGA = 1024,
    H_UXGA = 1200,
};

struct ov2640_win_size
{
    char *name;
    enum ov2640_width width;
    enum ov2640_height height;
    const struct regval_list *regs;
};

#define ENDMARKER  \
    {              \
        0xff, 0xff \
    }
#define OV2640_SIZE(n, w, h, r)                       \
    {                                                 \
        .name = n, .width = w, .height = h, .regs = r \
    }

extern const struct regval_list ov2640_init_regs[];
extern const struct regval_list ov2640_size_change_preamble_regs[];
extern const struct regval_list ov2640_qcif_regs[];
extern const struct regval_list ov2640_qvga_regs[];
extern const struct regval_list ov2640_cif_regs[];
extern const struct regval_list ov2640_vga_regs[];
extern const struct regval_list ov2640_lcd_regs[];
extern const struct regval_list ov2640_svga_regs[];
extern const struct regval_list ov2640_xga_regs[];
extern const struct regval_list ov2640_sxga_regs[];
extern const struct regval_list ov2640_uxga_regs[];
extern const struct ov2640_win_size ov2640_supported_win_sizes[];
extern const struct regval_list ov2640_format_change_preamble_regs[];
extern const struct regval_list ov2640_yuyv_regs[];
extern const struct regval_list ov2640_uyvy_regs[];
extern const struct regval_list ov2640_rgb565_be_regs[];
extern const struct regval_list ov2640_rgb565_le_regs[];
extern const struct regval_list ov2640_jpeg_regs[];
extern const struct regval_list ov2640_light_mode_sunny_regs[];
```



### (2)ov2640_reg.c

```c
/*
 * uHAL OmniVision OV2640 camera driver
 *
 * Copyright (C) 2016, Marek Koza, qyx@krtko.org
 *
 * This file is part of uMesh node firmware (http://qyx.krtko.org/projects/umesh)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * The following part is borrowed from the linux ov2640 driver. Some of the
 * registers are named but still there are many without any documentation.
 * Another possible source is the ArduCam project but it is not documented
 * and there are long arrays of magic values only.
 */

/*
 * Copyright (C) 2010 Alberto Panizzo <maramaopercheseimorto@gmail.com>
 *
 * Based on ov772x, ov9640 drivers and previous non merged implementations.
 *
 * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
 * Copyright (C) 2006, OmniVision
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "ov2640_reg.h"

const struct regval_list ov2640_init_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0x2c, 0xff},
    {0x2e, 0xdf},
    {BANK_SEL, BANK_SEL_SENS},
    {0x3c, 0x32},
    {CLKRC, CLKRC_DIV_SET(1)},
    {COM2, COM2_OCAP_Nx_SET(3)},
    {REG04, REG04_DEF | REG04_HREF_EN},
    {COM8, COM8_DEF | COM8_AGC_EN | COM8_AEC_EN},
    //~ { AEC,    0x00 },
    {COM9, COM9_AGC_GAIN_8x | 0x08},
    {0x2c, 0x0c},
    {0x33, 0x78},
    {0x3a, 0x33},
    {0x3b, 0xfb},
    {0x3e, 0x00},
    {0x43, 0x11},
    {0x16, 0x10},
    {0x39, 0x02},
    {0x35, 0x88},
    {0x22, 0x0a},
    {0x37, 0x40},
    {0x23, 0x00},
    {ARCOM2, 0xa0},
    {0x06, 0x02},
    {0x06, 0x88},
    {0x07, 0xc0},
    {0x0d, 0xb7},
    {0x0e, 0x01},
    {0x4c, 0x00},
    {0x4a, 0x81},
    {0x21, 0x99},
    {AEW, 0x40},
    {AEB, 0x38},
    {VV, VV_HIGH_TH_SET(0x08) | VV_LOW_TH_SET(0x02)},
    {0x5c, 0x00},
    {0x63, 0x00},
    {FLL, 0x22},
    {COM3, 0x38 | COM3_BAND_AUTO},
    {REG5D, 0x55},
    {REG5E, 0x7d},
    {REG5F, 0x7d},
    {REG60, 0x55},
    {HISTO_LOW, 0x70},
    {HISTO_HIGH, 0x80},
    {0x7c, 0x05},
    {0x20, 0x80},
    {0x28, 0x30},
    {0x6c, 0x00},
    {0x6d, 0x80},
    {0x6e, 0x00},
    {0x70, 0x02},
    {0x71, 0x94},
    {0x73, 0xc1},
    {0x3d, 0x34},
    {COM7, COM7_RES_UXGA | COM7_ZOOM_EN},
    {0x5a, 0x57},
    {BD50, 0xbb},
    {BD60, 0x9c},
    {BANK_SEL, BANK_SEL_DSP},
    {0xe5, 0x7f},
    {MC_BIST, MC_BIST_RESET | MC_BIST_BOOT_ROM_SEL},
    {0x41, 0x24},
    {RESET, RESET_JPEG | RESET_DVP},
    {0x76, 0xff},
    {0x33, 0xa0},
    {0x42, 0x20},
    {0x43, 0x18},
    {0x4c, 0x00},
    {CTRL3, CTRL3_BPC_EN | CTRL3_WPC_EN | 0x10},
    {0x88, 0x3f},
    {0xd7, 0x03},
    {0xd9, 0x10},
    {R_DVP_SP, R_DVP_SP_AUTO_MODE | 0x2},
    {0xc8, 0x08},
    {0xc9, 0x80},
    {BPADDR, 0x00},
    {BPDATA, 0x00},
    {BPADDR, 0x03},
    {BPDATA, 0x48},
    {BPDATA, 0x48},
    {BPADDR, 0x08},
    {BPDATA, 0x20},
    {BPDATA, 0x10},
    {BPDATA, 0x0e},
    {0x90, 0x00},
    {0x91, 0x0e},
    {0x91, 0x1a},
    {0x91, 0x31},
    {0x91, 0x5a},
    {0x91, 0x69},
    {0x91, 0x75},
    {0x91, 0x7e},
    {0x91, 0x88},
    {0x91, 0x8f},
    {0x91, 0x96},
    {0x91, 0xa3},
    {0x91, 0xaf},
    {0x91, 0xc4},
    {0x91, 0xd7},
    {0x91, 0xe8},
    {0x91, 0x20},
    {0x92, 0x00},
    {0x93, 0x06},
    {0x93, 0xe3},
    {0x93, 0x03},
    {0x93, 0x03},
    {0x93, 0x00},
    {0x93, 0x02},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x93, 0x00},
    {0x96, 0x00},
    {0x97, 0x08},
    {0x97, 0x19},
    {0x97, 0x02},
    {0x97, 0x0c},
    {0x97, 0x24},
    {0x97, 0x30},
    {0x97, 0x28},
    {0x97, 0x26},
    {0x97, 0x02},
    {0x97, 0x98},
    {0x97, 0x80},
    {0x97, 0x00},
    {0x97, 0x00},
    {0xa4, 0x00},
    {0xa8, 0x00},
    {0xc5, 0x11},
    {0xc6, 0x51},
    {0xbf, 0x80},
    {0xc7, 0x10}, /* white balance */
    {0xb6, 0x66},
    {0xb8, 0xA5},
    {0xb7, 0x64},
    {0xb9, 0x7C},
    {0xb3, 0xaf},
    {0xb4, 0x97},
    {0xb5, 0xFF},
    {0xb0, 0xC5},
    {0xb1, 0x94},
    {0xb2, 0x0f},
    {0xc4, 0x5c},
    {0xa6, 0x00},
    {0xa7, 0x20},
    {0xa7, 0xd8},
    {0xa7, 0x1b},
    {0xa7, 0x31},
    {0xa7, 0x00},
    {0xa7, 0x18},
    {0xa7, 0x20},
    {0xa7, 0xd8},
    {0xa7, 0x19},
    {0xa7, 0x31},
    {0xa7, 0x00},
    {0xa7, 0x18},
    {0xa7, 0x20},
    {0xa7, 0xd8},
    {0xa7, 0x19},
    {0xa7, 0x31},
    {0xa7, 0x00},
    {0xa7, 0x18},
    {0x7f, 0x00},
    {0xe5, 0x1f},
    {0xe1, 0x77},
    {0xdd, 0x7f},
    {CTRL0, CTRL0_YUV422 | CTRL0_YUV_EN},
    ENDMARKER,
};

/*
 * Register settings for window size
 * The preamble, setup the internal DSP to input an UXGA (1600x1200) image.
 * Then the different zooming configurations will setup the output image size.
 */
const struct regval_list ov2640_size_change_preamble_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {RESET, RESET_DVP},
    {HSIZE8, HSIZE8_SET(W_UXGA)},
    {VSIZE8, VSIZE8_SET(H_UXGA)},
    {CTRL2, CTRL2_DCW_EN | CTRL2_SDE_EN |
                CTRL2_UV_AVG_EN | CTRL2_CMX_EN | CTRL2_UV_ADJ_EN},
    {HSIZE, HSIZE_SET(W_UXGA)},
    {VSIZE, VSIZE_SET(H_UXGA)},
    {XOFFL, XOFFL_SET(0)},
    {YOFFL, YOFFL_SET(0)},
    {VHYX, VHYX_HSIZE_SET(W_UXGA) | VHYX_VSIZE_SET(H_UXGA) |
               VHYX_XOFF_SET(0) | VHYX_YOFF_SET(0)},
    {TEST, TEST_HSIZE_SET(W_UXGA)},
    ENDMARKER,
};

#define PER_SIZE_REG_SEQ(x, y, v_div, h_div, pclk_div) \
    {CTRLI, CTRLI_LP_DP | CTRLI_V_DIV_SET(v_div) |     \
                CTRLI_H_DIV_SET(h_div)},               \
        {ZMOW, ZMOW_OUTW_SET(x)},                      \
        {ZMOH, ZMOH_OUTH_SET(y)},                      \
        {ZMHH, ZMHH_OUTW_SET(x) | ZMHH_OUTH_SET(y)},   \
        {R_DVP_SP, pclk_div},                          \
    {                                                  \
        RESET, 0x00                                    \
    }

const struct regval_list ov2640_qcif_regs[] = {
    PER_SIZE_REG_SEQ(W_QCIF, H_QCIF, 3, 3, 4),
    ENDMARKER,
};

const struct regval_list ov2640_qvga_regs[] = {
    PER_SIZE_REG_SEQ(W_QVGA, H_QVGA, 2, 2, 4),
    ENDMARKER,
};

#define LCD_WIDTH 480
#define LCD_HEIGHT 272

const struct regval_list ov2640_lcd_regs[] = {
    PER_SIZE_REG_SEQ(LCD_WIDTH, LCD_HEIGHT, 0, 0, 2),
    ENDMARKER,
};

const struct regval_list ov2640_cif_regs[] = {
    PER_SIZE_REG_SEQ(W_CIF, H_CIF, 2, 2, 8),
    ENDMARKER,
};

const struct regval_list ov2640_vga_regs[] = {
    PER_SIZE_REG_SEQ(W_VGA, H_VGA, 0, 0, 2),
    ENDMARKER,
};

const struct regval_list ov2640_svga_regs[] = {
    PER_SIZE_REG_SEQ(W_SVGA, H_SVGA, 1, 1, 2),
    ENDMARKER,
};

const struct regval_list ov2640_xga_regs[] = {
    PER_SIZE_REG_SEQ(W_XGA, H_XGA, 0, 0, 2),
    {CTRLI, 0x00},
    ENDMARKER,
};

const struct regval_list ov2640_sxga_regs[] = {
    PER_SIZE_REG_SEQ(W_SXGA, H_SXGA, 0, 0, 2),
    {CTRLI, 0x00},
    {R_DVP_SP, 2 | R_DVP_SP_AUTO_MODE},
    ENDMARKER,
};

const struct regval_list ov2640_uxga_regs[] = {
    PER_SIZE_REG_SEQ(W_UXGA, H_UXGA, 0, 0, 0),
    {CTRLI, 0x00},
    {R_DVP_SP, 0 | R_DVP_SP_AUTO_MODE},
    ENDMARKER,
};

const struct ov2640_win_size ov2640_supported_win_sizes[] = {
    OV2640_SIZE("QCIF", W_QCIF, H_QCIF, ov2640_qcif_regs),
    OV2640_SIZE("QVGA", W_QVGA, H_QVGA, ov2640_qvga_regs),
    OV2640_SIZE("CIF", W_CIF, H_CIF, ov2640_cif_regs),
    OV2640_SIZE("VGA", W_VGA, H_VGA, ov2640_vga_regs),
    OV2640_SIZE("SVGA", W_SVGA, H_SVGA, ov2640_svga_regs),
    OV2640_SIZE("XGA", W_XGA, H_XGA, ov2640_xga_regs),
    OV2640_SIZE("SXGA", W_SXGA, H_SXGA, ov2640_sxga_regs),
    OV2640_SIZE("UXGA", W_UXGA, H_UXGA, ov2640_uxga_regs),
};

/*
 * Register settings for pixel formats
 */
const struct regval_list ov2640_format_change_preamble_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_yuyv_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_YUV422},
    {0xd7, 0x03},
    {0x33, 0xa0},
    {0xe5, 0x1f},
    {0xe1, 0x67},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_uyvy_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_YUV422},
    {0xd7, 0x01},
    {0x33, 0xa0},
    {0xe1, 0x67},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_rgb565_be_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_RGB565},
    {0xd7, 0x03},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_rgb565_le_regs[] = {
    {IMAGE_MODE, IMAGE_MODE_LBYTE_FIRST | IMAGE_MODE_RGB565},
    {0xd7, 0x03},
    {RESET, 0x00},
    {R_BYPASS, R_BYPASS_USE_DSP},
    ENDMARKER,
};

const struct regval_list ov2640_jpeg_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0xe0, 0x14},
    {0xe1, 0x77},
    {0xe5, 0x1f},
    {0xd7, 0x03},
    {IMAGE_MODE, IMAGE_MODE_JPEG_EN},
    {0xe0, 0x00},
    {BANK_SEL, BANK_SEL_SENS},
    {0x04, 0x08},
    //~ { RESET,  RESET_DVP | RESET_JPEG },
    ENDMARKER,
};

const struct regval_list ov2640_light_mode_sunny_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0xff, 0x00},
    {0xc7, 0x40},
    {0xcc, 0x5e},
    {0xcd, 0x41},
    {0xce, 0x54},
    ENDMARKER,
};
```



### (3)需要写入的寄存器值

```c
// 1.初始化参数-相关寄存器设置
ov2640_write_array(ov2640_init_regs);
// 2.改变分辨率大小：480x270  先触发大小改变状态，再写实际大小值
ov2640_write_array(ov2640_size_change_preamble_regs);
// ov2640_write_array(ov2640_qvga_regs);
ov2640_write_array(ov2640_lcd_regs);
// 3.改变RGB格式，RGB565
ov2640_write_array(ov2640_format_change_preamble_regs);
ov2640_write_array(ov2640_rgb565_be_regs);
// 4.拍照的一些灯光模式等设置  
ov2640_write_array(ov2640_light_mode_sunny_regs);
```

```c
// 每个序列用一个结构体封装
struct regval_list
{
    uint8_t reg_num; // 寄存器编号
    uint8_t value;   // 寄存器的值 
};
// 写序列函数-每个序列封装成一个数值连续地址
static void ov2640_write_array(const struct regval_list *vals)
{
    // 判断写是否结束
    while ((vals->reg_num != 0xff) || (vals->value != 0xff))
    {
        ov2640_write_register(vals->reg_num, vals->value);
        vals++;
        gpt_delay_ms(1); // 仿真程序卡住
    }

    return;
}

```

```c
const struct regval_list ov2640_jpeg_regs[] = {
    {BANK_SEL, BANK_SEL_DSP},
    {0xe0, 0x14},
    {0xe1, 0x77},
    {0xe5, 0x1f},
    {0xd7, 0x03},
    {IMAGE_MODE, IMAGE_MODE_JPEG_EN},
    {0xe0, 0x00},
    {BANK_SEL, BANK_SEL_SENS},
    {0x04, 0x08},
    //~ { RESET,  RESET_DVP | RESET_JPEG },
    ENDMARKER, //写结束标志
};
```

```c
#define ENDMARKER  
    {              
        0xff, 0xff 
    }
```

### 测试写入ov2640芯片中寄存器序列是否成功

>  Ov2640有两个ID，当序列号完成后，开始DSP，读取的是DSP地址中的ID
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f4d89154e3ab4d05851ef63700c74122.png)

```c
 void ov2640_init() {
    ov2640_pin_init();
    iic_con_init(I2C2);
    ov2640_hardware_reset();

    read_ov2640_pid(); // 再序列化之前读取ID
    // 1.初始化参数-相关寄存器设置
    ov2640_write_array(ov2640_init_regs);
    // 2.改变分辨率大小：480x270  先触发大小改变状态，再写实际大小值
    ov2640_write_array(ov2640_size_change_preamble_regs);
    // ov2640_write_array(ov2640_qvga_regs);
    ov2640_write_array(ov2640_lcd_regs);
    // 3.改变RGB格式，RGB565
    ov2640_write_array(ov2640_format_change_preamble_regs);
    ov2640_write_array(ov2640_rgb565_be_regs);
    // 4.拍照的一些灯光模式等设置  
    ov2640_write_array(ov2640_light_mode_sunny_regs);
}

static void ov2640_write_array(const struct regval_list *vals)
{
    while ((vals->reg_num != 0xff) || (vals->value != 0xff))
    {
        ov2640_write_register(vals->reg_num, vals->value);
        vals++;
        gpt_delay_ms(1); // 加间隔时间，防止程序卡住
    }

    return;
}

void ov2640_test(void)
{
    ov2640_init();

    while(1){
        read_ov2640_pid();
        gpt_delay_sec(1);
    }

    return;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/511740da9862477199ace8cd1316b259.png)

## 6.完整代码

```c
#include "imx6ull.h"
#include "ov2640_reg.h"

#define OV2640_SLAVE_ADDR_WRITE 0x60
#define OV2640_SLAVE_ADDR_READ  0x61
#define OV2640_PIDH_REG_ADDR  0x0a
#define OV2640_PIDL_REG_ADDR  0x0b

#include "ov2640.h"

void ov2640_pin_init() {
    /* 1. i2c SDl SAL */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);

    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);

    /* 2. daisy chain select 
        DAISY [1-0] 10 UART5_RX_DATA_ALT2 
     */
    // IOMUXC_I2C2_SCL_SELECT_INPUT = (2 << 0);
    // IOMUXC_I2C2_SDA_SELECT_INPUT = (2 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT |= (0x2 << 0);

    IOMUXC_I2C2_SDA_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SDA_SELECT_INPUT |= (0x2 << 0);

    /* 3. RESET IO*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO18 |=  (0x5 << 0);

}

void ov2640_hardware_reset() {
    //output low level for reset(先拉低复位，再拉高还原)
    GPIO1->GDIR |= (1 << 18);
    GPIO1->DR &= ~(1 << 18);
    gpt_delay_ms(500);

    GPIO1->DR |= (1 << 18);
    gpt_delay_ms(500);
}

void ov2640_write_register(uint8_t ragaddr, uint8_t regval) {
    uint8_t tx_buf[] = {ragaddr, regval};
    /* 1. start */
    iic_con_start(I2C2);

    /* 2. send slave + write bit*/
    iic_con_send_slave_addr(I2C2, OV2640_SLAVE_ADDR_WRITE);

    /* 3. send regaddr + data*/
    iic_con_send_data(I2C2, tx_buf, sizeof(tx_buf));

    /* 4. stop */
    iic_con_stop(I2C2);
}

uint8_t ov2640_read_register(uint8_t regaddr) {
    int ret;
    uint8_t rx_buf[1];
    uint8_t tx_buf[] = {regaddr};

    /* 1. start */
    iic_con_start(I2C2);

    /* 2. send slave + write bit*/
    iic_con_send_slave_addr(I2C2, OV2640_SLAVE_ADDR_WRITE);

    /* 3. send regaddr*/
    iic_con_send_data(I2C2, tx_buf, sizeof(tx_buf));

    /* 4. restart */
    iic_con_restart(I2C2);

    /* 5. send slave + read bit*/
    iic_con_send_slave_addr(I2C2, OV2640_SLAVE_ADDR_READ);

    /* 6. read regaddr */
    iic_con_read_data(I2C2, rx_buf, sizeof(rx_buf));

    /* 7. stop */
    iic_con_stop(I2C2);

    return rx_buf[0];
}

void read_ov2640_pid() {
     uint8_t pid[2];

    pid[1] = ov2640_read_register(OV2640_PIDH_REG_ADDR);
    gpt_delay_ms(10);
    pid[0] = ov2640_read_register(OV2640_PIDL_REG_ADDR);
    gpt_delay_ms(10);
    
    uart_printf("PIDH:%#x PIDL:%#x\r\n",pid[1],pid[0]);

}

// 写序列函数-每个序列封装成一个数值连续地址
static void ov2640_write_array(const struct regval_list *vals) {
    // 判断写是否结束
    while ((vals->reg_num != 0xff) || (vals->value != 0xff))
    {
        ov2640_write_register(vals->reg_num, vals->value);
        vals++;
        gpt_delay_ms(1); // 仿真程序卡住
    }
}

void ov2640_init() {
    ov2640_pin_init();
    iic_con_init(I2C2);
    ov2640_hardware_reset();

    read_ov2640_pid(); // 再序列化之前读取ID
    // 1.初始化参数-相关寄存器设置
    ov2640_write_array(ov2640_init_regs);
    // 2.改变分辨率大小：480x270  先触发大小改变状态，再写实际大小值
    ov2640_write_array(ov2640_size_change_preamble_regs);
    // ov2640_write_array(ov2640_qvga_regs);
    ov2640_write_array(ov2640_lcd_regs);
    // 3.改变RGB格式，RGB565
    ov2640_write_array(ov2640_format_change_preamble_regs);
    ov2640_write_array(ov2640_rgb565_be_regs);
    // 4.拍照的一些灯光模式等设置  
    ov2640_write_array(ov2640_light_mode_sunny_regs);
}

void ov2640_test() {
    ov2640_init();

    while(1){
        read_ov2640_pid();
        gpt_delay_sec(1);
    }
}
```

# <font color="#fd6f01">3.实战篇2-CSI</font>

# 一、IMX6ull CSI控制器



## 1.CMOS Sensor Interface (CSI)  控制器介绍

The CSI enables the chip to connect directly to external **CMOS** image sensors. 

CMOS image sensors are separated into two classes, **dumb and smart.** 

- **Dumb sensors are those that support only traditional sensor timing** (Vertical SYNC and Horizontal SYNC) and output only Bayer and statistics data,
-  **while smart sensors support CCIR656 video decoder formats and perform additional processing of the image** (for example, image compression, image pre-filtering, and various data output formats).

> - CSI使芯片能够直接连接到外部互补式金属氧化物半导体图像传感器。
> - 互补式金属氧化物半导体图像传感器分为两类，**哑式(ITU601)和智能(ITU656)**。
>   - **哑式传感器是那些仅支持传统传感器时序**（垂直SYNC和水平SYNC）并仅输出拜耳和统计数据的传感器，
>   - **而智能传感器支持CCIR656视频解码器格式并对图像进行额外处理**（例如，图像压缩、图像预滤波和各种数据输出格式）。

> ITU601与ITU656都具有8根数据线并行传输数据，**差别在于前者还需要场频和行频传输线**
>
> 
>
> > **EVA代表有效视频结束**,**SAV代表有效视频开始**。
>
> - 两者的区别在于：这两种标准都是video transmission 的 interface，在video frame format 的规格应该是相同的。
>- 两者的差别在于interface 规格的不同，
>   - **在CCIR656中，有8bit 的data bus和clock 的信号，也就是说CCIR656 是同步传输的，decoder端不用自己产生clock。**
>  - 在CCIR601中，**信号內还包含了其它两个同步信号：Horizontal Synchronization 和 Vertical Synchronization**，decoder 要自己去锁定這个同步信号，再自己产生clock 來解。
>   - **CCIR 656需从DATA 中解出VS、HS**, **CCIR 601 則直接使用输入的VS、HS 即可**。

The capabilities of the CSI include:

- Configurable interface logic to support most commonly available CMOS sensors. (可配置接口逻辑，支持最常用的互补式金属氧化物半导体传感器)
- Support for CCIR656 video interface as well as traditional sensor interface.(支持CCIR656视频接口以及传统的传感器接口)
- 8-bit / 16-bit / 24-bit data port for YCbCr, YUV, or **RGB data input**.(8位/16位/24位数据端口，用于YCbCr、YUV或RGB数据输入)
- **8-bit / 10-bit / 16-bit data port** for Bayer data input(8位/10位/16位数据端口，<font color=green>**用于拜耳数据(原始数据）输入**</font>).
- Full control of 8-bit/pixel, 10-bit/pixel or **16-bit / pixel data format to receive FIFO packing(**完全控制8位/像素、10位/像素或16位/像素数据格式，以接收FIFO打包).
- 256 x 64 FIFO to store received image pixel data(256 x 64FIFO存储接收到的图像像素数据).
- Reveive FIFO overrun protection mechanism(接收FIFO超限保护机制).
- <font color="#fd6f01">**Embedded DMA controllers to transfer data from receive FIFO or statistic FIFO through AHB bus.**</font>(嵌入式DMA控制器，通过AHB总线从接收FIFO或统计FIFO传输数据，<font color=green>（即，无需CPU参与，硬件直接将FIFO缓存采集的摄像头数据传递到LCD屏内存中）</font>)
- **Support 2D DMA** transfer from the receive FIFO to the frame buffers in the external memory(支持2D DMA从接收FIFO传输到外部存储器中的帧缓冲区).
- **Support double bufferring** two frames in the external memory(支持双缓冲外部存储器中的两个帧).
- **Single interrupt source to interrupt controller from maskable interrupt sources**: Start of Frame, End of Frame, Change of Field, FIFO full, FIFO overrun, DMA transfer done, CCIR error and AHB bus response error.(从屏蔽中断源到中断控制器的单个中断源：帧开始、帧结束、字段更改、FIFO满、FIFO溢出、DMA传输完成、CCIR错误和AHB总线响应错误)
- **Configurable master clock frequency output to sensor**(可配置的主时钟频率输出到传感器).



## 2.Clocks

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dce6c8f9004648059a1c57d39d12afd3.png)



## 3.**Principles of Operation**

The CSI is designed to **support generic sensor interface timing** as well as **CCIR656** video interface timing. 

Traditional CMOS sensors typically use VSYNC (SOF), HSYNC (BLANK), and PIXCLK signals to output Bayer or YUV data. 

**Smart CMOS sensors, that come with on-chip imaging processing**, usually support video mode transfer. **They use an embedded timing codec to replace the VSYNC and HSYNC signal. The timing codec is defined by the CCIR656 standard**.

> - 该CSI旨在支持通用传感器接口时序以及CCIR656视频接口时序。
> - 传统的互补式金属氧化物半导体传感器通常使用VSYNC（SOF）、HSYNC（BLANK）和PIXCLK信号来输出拜耳或YUV数据。
> - 带有片上成像处理的智能互补式金属氧化物半导体传感器通常支持视频模式传输。它们使用嵌入式时序编解码器来取代VSYNC和HSYNC信号。时序编解码器由CCIR656标准定义。

The CSI can support connection with the sensor as follows.

- **To connect with one 8-bit sensor**, the sensor data interface should connect to CSI_DATA[9:2] (要连接一个8位传感器，传感器数据接口应连接到CSI_DATA[9:2])
- To connect with one 10-bit sensor, the sensor data interface should connect to CSI_DATA[9:0](https://www.imooc.com/wiki/要连接一个10位传感器，传感器数据接口应连接到CSI_DATA[9:0])
- To connect with one 16-bit sensor, the sensor data interface should connect to CSI_DATA[15:0](https://www.imooc.com/wiki/要连接一个16位传感器，传感器数据接口应连接到CSI_DATA[15:0])
- To connect with one 24-bit sensor, connect either the video pass-through, TV Decoder input, or the sensor data interface to CSI_DATA[23:0](https://www.imooc.com/wiki/要连接一个24位传感器，请将视频直通、电视解码器输入或传感器数据接口连接到CSI_DATA[23:0])
- To connect with two 8-bit sensors, the sensor data interfaces should connect to CSI_DATA[7:0] and CSI_DATA[15:8](https://www.imooc.com/wiki/要连接两个8位传感器，传感器数据接口应连接到CSI_DATA[7:0]和CSI_DATA[15:8])



## 4.**Data Transfer with the Embedded DMA Controllers**

The CSI has two embedded DMA controllers, **one for the receive FIFO and the other for the statistic FIFO.** 

It supports **2D DMA transfer from the receive FIFO to the frame buffers in the external memory** and linear DMA transfer from the statistic FIFO.

> - CSI有两个嵌入式DMA控制器，
> - 一个用于接收FIFO，另一个用于统计FIFO，
> - 它支持从接收FIFO到外部存储器帧缓冲区的2DDMA传输和从统计FIFO的线性DMA传输。

To transfer data from the RxFIFO to the external memory, the user should set the **start address in the frame buffer** where the transferred data is stored, t**he parameters of the frame buffers, and the parameters of the image** coming from the sensor. 

The user can have **two frame buffers** in the external memory. Each one will store a frame of image coming from the sensor. The embedded DMA controller will **first write the frame buffer1 and then frame buffer2.** These two frame buffers will be written by turns. 

The start address should **be aligned in and set in the CSIDMASA-FB1 and CSIDMASA-FB2 registers**. 

In the **CSIFBUF_PARA** register, the user should set the **stride of the frame buffer** to show how many to **skip before starting to write the next row of the image**. 

In the **CSIIMAG_PARA register,** the user should **set the width and height of the image coming from the sensor**. The RxFF_LEVEL and DMA_REQ_EN_RFF bits in CSICR3 registers also need to be set before the data transfer starts. 

When the number of the data in the **RxFIFO reaches the trigger level**（阀值）, a DMA request will be **sent to the embedded DMA controller and the data will be read out from the RxFIFO and written through AHB bus** into the external frame buffers. 

The **burst type of transfer can be INCR4, INCR8 and INCR16 by setting DMA_BURST_TYPE_RFF bits in CSICR2 register**. 

- > INCR4 (4个节拍的增量突发传输) 
  >
  > INCR8 (8个节拍的增量突发传输) 
  >
  > INCR16 (16个节拍的增量突发传输) 
  >
  > <font color=green>**一个节拍即一个单位（如字节(8bit)、半字(16bit)、字(32bit)）**</font>

After all data in an **image frame are transferred, the DMA_TSF_DONE_FB1 or DMA_TSF_DONE_FB2 bit will be set in CSISR register** and the **interrupt** can be triggered if the corresponding enable bit is set in CSICR1 register. 

The **DMA_REFLASH_RFF bit in CSICR3 can be used to activate or restart the embedded DMA controller.**

> - 要将数据从RxFIFO传输到外部存储器，用户应在存储传输数据的帧缓冲区中设置起始地址、帧缓冲区的参数以及来自传感器的图像的参数。
> - 用户可以在外部存储器中设置两个帧缓冲区。每个帧缓冲区将存储来自传感器的图像帧。嵌入式DMA控制器将首先写入帧缓冲区1，然后写入帧缓冲区2。
> - 这两个帧缓冲区将轮流写入。起始地址应在CSIDMASA-FB1和CSIDMASA-FB2寄存器中对齐和设置。
> - 在CSIFBUF_PARA寄存器中，用户应该设置帧缓冲区的步幅，以显示在开始写入图像的下一行之前要跳过多少。
> - 在CSIIMAG_PARA寄存器中，用户应该设置来自传感器的图像的宽度和高度。CSICR3寄存器中的RxFF_LEVEL和DMA_REQ_EN_RFF位也需要在数据搬迁开始之前设置。
> - 当RxFIFO中的数据数量达到触发级别时，将向嵌入式DMA控制器发送DMA请求，并将数据从RxFIFO中读出并通过AHB总线写入外部帧缓冲区。
> - 通过在CSICR2寄存器中设置DMA_BURST_TYPE_RFF位，突发类型的传输可以是INCR4、INCR8和INCR16。
> - 图像帧中的所有数据传输后，将在CSISR寄存器中设置DMA_TSF_DONE_FB1或DMA_TSF_DONE_FB2位，如果在CSICR1寄存器中设置相应的使能位，则可以触发中断。
> - CSICR3中的DMA_REFLASH_RFF位可用于激活或重新启动嵌入式DMA控制器。

The RxFIFO has the **overrun protection mechanism** in case the **RxFIFO is overrun during data transfer**. 

If the RxFIFO is full and more data needs to be received during the data transfer, the RxFIFO will be **overwritten continuously and all 128 words of data in the RxFIFO before overrun occurred will be discarded**;

 the c**orresponding 128 words memory space in the frame buffer will keep the previous values.**

> - RxFIFO具有在数据搬迁过程中RxFIFO溢出时的溢出保护机制。
> - 如果RxFIFO已满并且在数据搬迁过程中需要接收更多数据，则RxFIFO将被连续覆盖，并且RxFIFO中发生溢出之前的所有128字数据将被丢弃；
> - **帧缓冲区中相应的128字内存空间将保留先前的值**。<font color=green>**(在被覆盖前，已经通过DMA传递到外部内存中)**</font>



## 5.**RGB565 Data**

**RGB565 data is processed data** from the image sensor, which can be put directly into the display buffer. 

<font color="#fd6f01">**The data is 16 bits wide**. **The data path is from CSI to memory to the display controller.** </font>

On the sensor side, **data must be transmitted as P0 first,** followed by P1, and so on. **For each pixel, whether the MSB or LSB** is sent first depends on the endianness of the sensor. 

Data is 16 bits wide with the **MSB labeled RG, and the LSB labeled GB.** P0 is represented as RG0 and GB0.

> - RGB565数据是经过处理的来自图像传感器的数据，可以直接放入显示缓冲区。
> - 数据为16位宽。数据通路是从CSI到内存到显示控制器。
> - 在传感器端，数据必须先作为P0传输，其次是P1，以此类推。对于每个像素，先发送MSB还是LSB取决于传感器的endianness。
> - 数据为16位宽，MSB标记为RG，LSB标记为GB。P0表示为RG0和GB0。

CSI receives data in one of the following sequence(CSI按以下顺序之一接收数据):

- **RG0, GB0, RG1, GB1**, while RG0 comes out at time slot 0 (first data), and GB1 comes out at time slot 3 (last data) (RG0、GB0、RG1、GB1，而RG0在时隙0（第一个数据）出来，GB1在时隙3（最后一个数据）出来)
- GB0, RG0, GB1, RG1

Using the first sequence as an example, and assuming the system is running in **little endian**, the data is presented as: (以第一个序列为例，**假设系统字节序在小端运行**，数据呈现为)

- 8-bit data from sensor: RG0, GB0, RG1, GB1, … (来自传感器的8位数据：RG0、GB0、RG1、GB1、…)
- data before storage in the CSI RX FIFO (PACK_DIR bit = 1): (存储在CSIRXFIFO之前的数据（PACK_DIR位=1)
- data in CSI RX FIFO (SWAP16_EN bit enabled): (存储在CSIRXFIFO之前的数据（PACK_DIR位=1))
- transfer to system memory: (转移到系统内存)
- 16-bit read by display controller: RG0GB0, RG1GB1 (显示控制器读取16位：RG0GB0、RG1GB1)



# 二、IMX6ull 重点寄存器介绍



## 1.**CSI Control Register 1 (CSI_CSICR1)**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4ce2d7a98dda4ec6bc1194a3de500feb.png)



## 2.**CSI Control Register 2 (CSI_CSICR2)**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a1fea100fbc4000a6e34f29eb09ae23.png)



## 3.**CSI Control Register 3 (CSI_CSICR3)**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9ddc6a6472ea4ec6b25a014b70325436.png)

## 4.**CSI Image Parameter Register (CSI_CSIIMAG_PARA)**

This register provides the **width and the height** of the image from the sensor. 

The width and height should be **aligned in pixel**. The **width of the image multiplied by the height is the total pixel size that will be transfered in a frame** by the embedded DMA controller. 

This register should be configured before activating or restarting the embedded DMA controller.

> - 此寄存器提供来自传感器的图像的宽度和高度。
> - 宽度和高度应**以像素为单位对齐**。
> - 图像的**宽度乘以高度即为嵌入式DMA控制器在帧中传输的总像素大小**。<font color=green>**（注意，宽度要乘以像素字节数，例如RGB565，每个像素是2字节，要乘以2）**</font>
> - 应在激活或重新启动嵌入式DMA控制器之前配置此寄存器。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/84174f12c84b420ba1d186f5d3e4d699.png)



## 5.**CSI Frame Buffer Parameter Register (CSI_CSIFBUF_PARA)**

This register provides the **stride of the frame buffer** to show **how many words to skip** before starting to write the next row of the image. 

**The width of the frame buffer minus the width of the image is the stride**. This register should be configured before activating or restarting the embedded DMA controller.

> - 此寄存器提供帧缓冲区的步幅，以显示在开始写入图像的下一行之前要跳过多少字。
> - 帧缓冲区的宽度减去图像的宽度就是步幅。应在激活或重新启动嵌入式DMA控制器之前配置此寄存器。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ee1822962ae348f4988b91af0c05f652.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/05c96726194d48ebb3dff3b1e07ef7e8.png)



## 6.**CSI Control Register 18 (CSI_CSICR18)**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a84b87c63c3a45f89bb2fed17a37307b.png)



## 7.**CSI DMA Start Address Register - for Frame Buffer1 (CSI_CSIDMASA_FB1)**

This register provides the s**tart address** in the **frame buffer1** for the embedded DMA controller of RxFIFO. 

The embedded DMA controller will read data from RxFIFO and write it to the frame buffer1 from the start address. **This register should be configured before activating or restarting the embedded DMA controller.**

> - 此寄存器在RxFIFO的嵌入式DMA控制器的帧缓冲区1中提供起始地址。
> - 嵌入式DMA控制器将从RxFIFO读取数据并从起始地址将其写入帧缓冲区1。此寄存器应在激活或重新启动嵌入式DMA控制器之前配置。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9dbd17db2083474cb018a434ad977d4a.png)



## 8.**CSI DMA Transfer Size Register - for Frame Buffer2 (CSI_CSIDMASA_FB2)**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5142ef344cf3419eb5a1c6f93b1bcd2d.png)



# 三、编程思路介绍

> <font color="#fd6f01">核心思想:将**CSI控制器**从**OV2640的视频流**在**LCD屏上进行显示**，**数据格式采用RGB565**</font>



## 1.CSI控制器GPIO口初始化

**1.初始化8根数据线**

> **To connect with one 8-bit sensor, the sensor data interface should connect to CSI_DATA[9:2]** (要连接一个8位传感器，传感器 数据接口应连接到CSI_DATA[9:2])
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2253d8914e3a4a9d8844d8057429e5c1.png)
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c30b48e25f73437eace1c89d544f5373.png)
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cd26d6dd24914f6ca462f4c1cf75ae00.png)

**2.初始化其它信号线**

> ![image-20240324173801842](C:\Users\ls2690069470\AppData\Roaming\Typora\typora-user-images\image-20240324173801842.png)

```c
void csi_gpio_init(void)
{
    uint32_t *p;

    //0000 ALT0 — Select mux mode: ALT0 mux port: CSI_MCLK of instance: csi
    IOMUXC_SW_MUX_CTL_PAD_CSI_MCLK &= ~(0xf << 0);

    //0000 ALT0 — Select mux mode: ALT0 mux port: CSI_PIXCLK of instance: csi
    IOMUXC_SW_MUX_CTL_PAD_CSI_PIXCLK &= ~(0xf << 0);
    //1 CSI_PIXCLK_ALT0 — Selecting Pad: CSI_PIXCLK for Mode: ALT0
    IOMUXC_CSI_PIXCLK_SELECT_INPUT |= (1 << 0);

    //0000 ALT0 — Select mux mode: ALT0 mux port: CSI_VSYNC of instance: csi，菊花链默认0，选择CSI_VSYNC
    IOMUXC_SW_MUX_CTL_PAD_CSI_VSYNC &= ~(0xf << 0);

    //0000 ALT0 — Select mux mode: ALT0 mux port: CSI_HSYNC of instance: csi
    IOMUXC_SW_MUX_CTL_PAD_CSI_HSYNC &= ~(0xf << 0);

    //CSI DATA[0-7]
    for(p = IOMUXC_SW_MUX_CTL_PAD_CSI_DATA_START;
        p <= IOMUXC_SW_MUX_CTL_PAD_CSI_DATA_END;
        p ++){
         *p &= ~(0xf << 0);
    }
    // 菊花链设置
    IOMUXC_CSI_DATA02_SELECT_INPUT &= ~(1 << 0);
    IOMUXC_CSI_DATA03_SELECT_INPUT &= ~(1 << 0);
    IOMUXC_CSI_DATA04_SELECT_INPUT |= (1 << 0);
    IOMUXC_CSI_DATA05_SELECT_INPUT &= ~(1 << 0);
    IOMUXC_CSI_DATA06_SELECT_INPUT |= (1 << 0);
    IOMUXC_CSI_DATA07_SELECT_INPUT |= (1 << 0);
    IOMUXC_CSI_DATA08_SELECT_INPUT |= (1 << 0);
    IOMUXC_CSI_DATA09_SELECT_INPUT |= (1 << 0);

    return;
}
```



## 2.CSI控制器初始化

> 
>
> ```c
> /*
>      EXT_VSYNC    [30] 1 External VSYNC mode
>      VIDEO_MODE   [27] 0 Progressive mode is selected
>      FB2_DMA_DONE_INTEN [20] 1 Frame Buffer2 DMA Transfer Done interrupt enable
>      FB1_DMA_ONE_INTEN  [19] 1 Frame Buffer1 DMA Transfer Done interrupt enable
>      HSYNC_POL    [11] 1 HSYNC is active high
>      CCIR_EN      [10] 0 Traditional interface is selected. 
>      FCC          [8]  0 Asynchronous FIFO clear is selected.
>      PACK_DIR     [7]  1 Pack from MSB first.
>      GCLK_MODE    [4]  1 Gated clock mode. Pixel clock signal is valid only when HSYNC is active.
>      REDGE        [1]  1 Pixel data is latched at the rising edge of CSI_PIXCLK
>      PIXEL_BIT    [0]  0 8-bit data for each pixel
>     */
>     CSI->CSICR1 = (1 << 30) | (0 << 27) | (1 << 11) | (1 << 7) | (1 << 4) | (1 << 1) | (1 << 20) | (1 << 19);
> 
>     /*Clear RXFIFO
>     CLR_RXFIFO [5] Writing 1 clears the RXFIFO immediately,
>                    RXFIFO restarts immediately after that.
>                    The bit is restored to 0 automatically after finish.
>     */
>     CSI->CSICR1 |= (1 << 5);
>     while( CSI->CSICR1 & (1 << 5))
>     {}
> 
> ```
>
> 

> 
>
> ```c
>  /*
>     DMA_BURST_TYPE_RFF [31-30] 11 INCR16
>     */
>    CSI->CSICR2 = (0x3 << 30);
> 
> ```

> 
>
> ```c
>  /*
>    FRMCNT_RST [15] 1 Reset frame counter immediately
>    Frame Count Reset. Resets the Frame Counter. (Cleared automatically after reset is done)
>    */
>    CSI->CSICR3 |= (1 << 15);
>    while(CSI->CSICR3 & (1 << 15))
>    { }
> 
>    /*
>    DMA_REFLASH_RFF [14] 1 Reflash the embedded DMA controller
>     It should be reflashed before the embedded DMA controller 
>     starts to work. (Cleared automatically after reflashing is done)
>    */
>    CSI->CSICR3 |= (1 << 14);
>    while(CSI->CSICR3 & (1 << 14))
>    { }
> 
>    /*
>    RxFF_LEVEL   [6–4] 011 24
>    ECC_AUTO_EN  [0]  1 Auto Error correction is enabled.
>    */
>    CSI->CSICR3 = (0x3 << 4) | (1 << 0);
> ```
>
> ```c
> void reflash_dma(void)
> {
>     /*
>     DMA_REFLASH_RFF [14] 1 Reflash the embedded DMA controller
>     It should be reflashed before the embedded DMA controller 
>     starts to work. (Cleared automatically after reflashing is done)
>    */
>    CSI->CSICR3 |= (1 << 14);
>    while(CSI->CSICR3 & (1 << 14))
>    { }
> 
>    return;
> }
> ```
>
> 
>
> 

```c
void csi_init(void)
{
    /*
     EXT_VSYNC    [30] 1 External VSYNC mode
     VIDEO_MODE   [27] 0 Progressive mode is selected
     FB2_DMA_DONE_INTEN [20] 1 Frame Buffer2 DMA Transfer Done interrupt enable
     FB1_DMA_ONE_INTEN  [19] 1 Frame Buffer1 DMA Transfer Done interrupt enable
     HSYNC_POL    [11] 1 HSYNC is active high
     CCIR_EN      [10] 0 Traditional interface is selected. 
     FCC          [8]  0 Asynchronous FIFO clear is selected.
     PACK_DIR     [7]  1 Pack from MSB first.
     GCLK_MODE    [4]  1 Gated clock mode. Pixel clock signal is valid only when HSYNC is active.
     REDGE        [1]  1 Pixel data is latched at the rising edge of CSI_PIXCLK
     PIXEL_BIT    [0]  0 8-bit data for each pixel
    */
    CSI->CSICR1 = (1 << 30) | (0 << 27) | (1 << 11) | (1 << 7) | (1 << 4) | (1 << 1) | (1 << 20) | (1 << 19);

    /*Clear RXFIFO
    CLR_RXFIFO [5] Writing 1 clears the RXFIFO immediately,
                   RXFIFO restarts immediately after that.
                   The bit is restored to 0 automatically after finish.
    */
    CSI->CSICR1 |= (1 << 5);
    while( CSI->CSICR1 & (1 << 5))
    {}

    /*
    DMA_BURST_TYPE_RFF [31-30] 11 INCR16
    */
   CSI->CSICR2 = (0x3 << 30);

   /*
   FRMCNT_RST [15] 1 Reset frame counter immediately
   Frame Count Reset. Resets the Frame Counter. (Cleared automatically after reset is done)
   */
   CSI->CSICR3 |= (1 << 15);
   while(CSI->CSICR3 & (1 << 15))
   { }

   /*
   DMA_REFLASH_RFF [14] 1 Reflash the embedded DMA controller
    It should be reflashed before the embedded DMA controller 
    starts to work. (Cleared automatically after reflashing is done)
   */
   CSI->CSICR3 |= (1 << 14);
   while(CSI->CSICR3 & (1 << 14))
   { }

   /*
   RxFF_LEVEL   [6–4] 011 24
   ECC_AUTO_EN  [0]  1 Auto Error correction is enabled.
   */
   CSI->CSICR3 = (0x3 << 4) | (1 << 0);

   return;
}

void reflash_dma(void)
{
    /*
    DMA_REFLASH_RFF [14] 1 Reflash the embedded DMA controller
    It should be reflashed before the embedded DMA controller 
    starts to work. (Cleared automatically after reflashing is done)
   */
   CSI->CSICR3 |= (1 << 14);
   while(CSI->CSICR3 & (1 << 14))
   { }

   return;
}

```



## 3.刷新DMA控制器

```c
void csi_reflash_fifo_dma(void)
{
    /*
    Reflash DMA Controller for RxFIFO. This bit reflash the embedded
    DMA controller for RxFIFO. It should be reflashed before the embedded
    DMA controller starts to work. (Cleared automatically after reflashing is done)
     
    [14] DMA_REFLASH_RFF 1 Reflash the embedded DMA controller
    
    */
    CSI->CSICR3 |= (1 << 14);

    /* Wait clear completed. */
    while (CSI->CSICR3 & (1 << 14))
    {
    }

    return;
}
```



## 4.设置CSI DMA传输地址



```c

void csi_dma_transfer_addr_init(uint32_t buffer_addr)
{
    CSI->CSIDMASA_FB1 = buffer_addr;
    CSI->CSIDMASA_FB2 = buffer_addr;
}
```



## 5.设置摄像头采集的图片参数



```c
void csi_image_parm_init(uint32_t width,uint32_t height,uint32_t pix_bytes)
{
    uint32_t line_pix_bytes = width * pix_bytes;
    /*
      IMAGE_WIDTH  [31–16]  the IMAGE_WIDTH should be a multiple of pixels.
      IMAGE_HEIGHT [15-0 ]   Image Height
    */
    CSI->CSIIMAG_PARA = (line_pix_bytes << 16) | (height << 0);

    /*FBUF_STRIDE
     Indicates the stride of the frame buffer.
     The width of the frame buffer(in ) minus
     the width of the image(in ) is the stride. 
     The stride should be aligned. The embedded DMA controller will
     skip the stride before starting to write the next row of the image.
    */
    CSI->CSIFBUF_PARA = 0x0;

    return;
}
```



## 6.开启CSI控制器开始接收摄像头数据

```c
void csi_start(void)
{
    /*DMA_REQ_EN_RFF [12] 1 Enable the dma request*/
    CSI->CSICR3 |= (1 << 12) | (0x3 << 4);

    /*CSI_ENABLE [31] CSI global enable signal. Only when this bit is 1, 
     CSI can start to receive the data and store to memory.*/
    CSI->CSICR18 |= (1 << 31) | (0x2 << 16);

    return;
}
```



## 7.关闭CSI控制器停止接收摄像头数据

```c
void csi_stop(void)
{
    /*
    [12] DMA_REQ_EN_RFF 0 Disable the dma request 
    */
    CSI->CSICR3 &= ~(1 << 12);

    /*
     [31] CSI_ENABLE CSI global enable signal. Only when this bit is 1,
                     CSI can start to receive the data and store to memory.
    */
    CSI->CSICR18 &= ~(1 << 31);
    
    return;
}

```



# 四、将ov2640的摄像头数据在LCD屏上面显示

```c
uint32_t get_lcd_rgb565_framebuffer(void)
{
    return (uint32_t)framebuffer_16;
}
```

```c
void ov2640_to_csi_to_lcd(void)
{
    lcd_rgb565_init();

    ov2640_init();

    csi_gpio_init();
    csi_init();
    uint32_t framebuffer_addr = get_lcd_rgb565_framebuffer();
    csi_dma_transfer_addr_init(framebuffer_addr);
    csi_image_parm_init(480,272,2);
    
    reflash_dma();
    csi_start();
    
    return;
}
```

