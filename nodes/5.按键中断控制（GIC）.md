# 1. 中断原理
## 1.1 中断概念
- 中断是指计算机运行过程中，出现某些意外情况需主机干预时，
- 机器**`能自动停止正在运行的程序并转入处理新情况的程序`**，**`处理完毕后又返回原被暂停的程序继续运行`**。
## 1.2 CPU处理事情的方式
### 1.2.1 轮询方式
- 不断查询是否有事情需要处理，如果有则处理。由于需要不断的轮询，效率较低。
### 1.2.2 中断方式
- 当需要CPU处理的时候，产生一个信号，打断CPU正在做的事情，让CPU处理另一件事情，等另一件事情处理完以后，回到打断之前的地方接着执行。

- 中断处理需要**注意**的地方

	- 中断打断了其他程序的执行，所以**`中断处理的时候需要尽可能的快`**，不能在中断处理过程中做耗时很长的事情。
	- 中断打断了其他程序的执行，所以在中断处理的时候，**`需要先保存现场(CPU的状态和CPU内部寄存器的值:压栈保存),`**在中断处理结束的时候，**需要`恢复现场`**。

## 1.3 ARM核中断处理过程
- 在`ARM核中中断是异常的一种`，处理过程异常的处理过程类似
### 1.3.1 异常处理

```apl
当异常产生的时候，ARM核自动做的事情
(1)CPSR的值拷贝到异常模式的SPSR
(2)设置CPSR相应位
    [1]进入ARM状态
    [2]进入对应的异常模式
    [3]禁止中断
(3)保存pc的值到异常模式的lr
(4)将pc设置异常向量表的相应位置

程序员需要做的事情:
(1)设置异常向量表 (在异常向量表中写跳转指令，跳转指定异常处理函数)
(2)告诉ARM核异常向量表的基地址
   [1]cortex-A系列之前，异常向量表可以存放在0x0000,0000(低地址) 或0xffff,0000(高地址)
        cp15(协处理器).c1(寄存器) 决定异常向量存放在高地址还是低地址
   [2]cortex-A系列之后，异常向量表可以存放在任意位置
        cp15(协处理器).c12(寄存器)保存异常向量表的基地址
                   
(3)编写异常处理函数
     [1]设置sp寄存器
     [2]将通用的寄存器(r0-12)进行压栈保护
     [3]异常处理的事情
     [4]异常返回
          A.恢复r0-r12 (出栈)
          B.恢复cpsr   (spsr->cpsr)
          C.恢复pc     (lr  ->pc)

```
### 1.3.2 IRQ异常指令流水线
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/13fca6f7ca3242349762872038c4e1a6.png)

> 注意：`lr返回pc值时，要减4`
>
> ![image-20240812171406610](C:\Users\ls2690069470\AppData\Roaming\Typora\typora-user-images\image-20240812171406610.png)
>
> ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4b36d4ac0156419f9d4e3f846a274135.png)

### 1.3.3 中断处理过程分析

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5c2300bf52fa463e93bcd511a8064345.png)

```assembly
.global _start

_start:
    b reset
    ldr pc,_undefined_instruction
    ldr pc,_software_interrupt  @B   software_interrupt
    ldr pc,_prefetch_abort
    ldr pc,_data_abort
    ldr pc,_not_used
    ldr pc,_irq
    ldr pc,_fiq
_undefined_instruction:.word _undefined_instruction
_software_interrupt:.word software_interrupt
_prefetch_abort:.word _prefetch_abort
_data_abort:.word _data_abort
_not_used:.word _not_used
_irq:.word irq
_fiq:.word _fiq

reset:
    @告诉ARM核异常向量表所在的基地址
    adr r0,_start 			@获得异常向量表所在的地址
    mcr p15,0,r0,c12, c0, 0     @将异常向量表的基地址写入cp15.c12

    ldr sp,=0x87800000
    bl  main

stop:
    b stop

software_interrupt:
    ldr sp,=0x81000000     @指定栈顶位置
    stmfd sp!,{r0-r12,lr}

    ldr r0,[lr,#-4]            @指向软中断执行位置
    mov r1,#0xff          
    bic r0,r0,r1,lsl #24   @获取低24位中断号

    ldmfd sp!,{r0-r12,pc}^ @出栈，并将SPSR的值写回CPSR中

irq:
    ldr sp,=0x82000000
    sub lr,lr,#4   @ 保存lr-4的地址，返回时赋值给pc
    stmfd sp!,{r0-r12,lr}

    bl do_irq      @ 跳转到中断处理函数

    ldmfd sp!,{r0-r12,pc}^
void do_irq(void)    // 中断异常处理函数封装
{
    1.获取中断号
    2.根据中断号获取中断处理函数入口地址
    3.调用中断处理函数
    
    return;
}

```
## 1.4 中断相关的概念
### 1.中断源
- 产生中断的源头
### 2.中断号
- 是SOC芯片厂家**对SOC芯片内部中断源的编号**
### 3.中断处理函数
- 中断产生之后，**需要调用的函数**

### 4.中断控制器
- 控制中断的**`优先级`**、**`中断是否允许被处理`**

### 5.内部中断和外部中断
#### (1)内部中断
- SOC芯片**`内部控制器产生的中断`**

#### (2)外部中断
- SOC芯**片`外部管脚通过电平触发产生的中断`**
	- 高电平触发
	- 低电平触发
	- 上升沿触发
	- 下降沿触发
	- 双边沿触发
# 2 GIC中断控制器
## 2.1 介绍
- GIC 全称是为**`Generic Interrupt Controller`**是 ARM 公司给 Cortex-A/R 内核提供的一个中断控制器,
- 目前 GIC 有 4 个版本:
	- V1~V4,V1 是最老的版本，已经被废弃了。
	- GIC **V2 是给 ARMv7-A 架构使用的**，比如 Cortex-A7、Cortex-A9、Cortex-A15 等,
	- **V3 和 V4 是给 ARMv8-A/R 架构使用**的，也就是 64 位芯片使用的。

> 在Cortex-M 内核中，ARM设计了NVIC(Nested Vectored Interrupt Controller:内嵌向量中断控制器)中断控制器.

==defines:==
- the architectural requirements for handling all interrupt sources for any processor connected to a GIC (处理连**`接到GIC的任何处理器的所有中断源`**的体系结构要求)
- a common interrupt controller programming interface applicable to uniprocessor or multiprocessor systems(一种通用的**`中断控制器编程接口`**，适用于单处理器或多处理器系统)

==**It provides:**==
- registers for managing interrupt sources, interrupt behavior, and interrupt routing to one or more processors(用于管理**`中断源`**、**`中断行为`**和**`中断路由`**到一个或多个处理器的**寄存器**)
- support for:
	- — the ARM architecture Security Extensions (ARM架构安全扩展)
	- — the ARM architecture Virtualization Extensions(ARM架构虚拟化扩展)
	- — enabling, disabling, and generating processor interrupts from hardware (peripheral) interrupt sources (**硬件外设中断源**`启用、禁用并产生处理器中断)`
	- — Software-generated Interrupts (SGIs) (**`软件产生中断`**（SGI））
	- — interrupt masking and prioritization (**`中断屏蔽和优先级`**)
	- — uniprocessor and multiprocessor environments(单处理器和多处理器环境)
	- — wakeup events in power-management environments(电源管理环境中的唤醒事件)

## 2.2 构成
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bcd709e9d12c43a7b82f4a8fcacdedee.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/517f4e6ff0fd437fa9ca87f719fd953c.jpeg)

### (1)GIC支持的中断类型
#### Peripheral interrupt (外设中断)
- **Private** Peripheral Interrupt (**`PPI`**) (**专用**外设中断)
	- This is a peripheral interrupt that is **specific to a single processor**(这是一个特定于单个处理器的外围中断)

-  **Shared** Peripheral Interrupt (**`SPI`**)
	- This is a peripheral interrupt that the Distributor can route to **any of a specified combination of processors**.(这是一个外设中断，分发服务器可以将其**路由到任何指定的处理器组合**)

#### **Software-generated** interrupt (`SGI`) (软件产生中断)
- This is an interrupt generated by software writing to a `GICD_SGIR register` in the GIC. The system **uses SGIs for interprocessor communication.**(通过软件向GIC中的GICD_SGIR寄存器写入数据产生的中断。系统**使用SGIs进行处理器间通信**)
#### **Virtual** interrupt (虚拟中断)
- In a GIC that implements the GIC Virtualization Extensions, an interrupt that **targets** a virtual machine running **on** a processor, and is **typically signaled to** the processor by the connected virtual CPU interface. (在实现GIC虚拟化扩展的GIC中，一种**针对在处理器上运行的虚拟机的中断**，通常**由连接的虚拟CPU接口向处理器发出信号**)
#### **Maintenance** interrupt(维护中断)
-  In a GIC that implements the GIC Virtualization Extensions, a level-sensitive interrupt that is used to **signal key events**, such as a particular group of interrupts becoming enabled or disabled. (在实现GIC虚拟化扩展的GIC中，一种对级别敏感的中断，用于向关键事件发出信号，例如一组特定的中断被启用或禁用)

### (2)GIC支持的中断源个数
- The GIC assigns interrupt ID numbers `ID0-ID1019` as follows(GIC分配中断ID号**ID0-ID1019**如下):

- Interrupt numbers `ID32-ID1019` are used for `SPIs`. (中断号**ID32-ID1019用于SPI**)
- Interrupt numbers `ID0-ID31` are used for interrupts that are `private to a CPU interface`. These interrupts are **banked in the Distributor**. (中断号ID0-ID31用于CPU接口专用的中断。这些中断**`存储在中断分发器中`**)
	- — `ID0-ID15` are used for `SGIs` （ID0-ID15用于SGI）
	- —` ID16-ID31` are used for` PPIs`（ID16-ID31用于PPI）
### (3)`Distributor`(中断分发器)
- The Distributor **centralizes all interrupt sources**, determines the **priority** of each interrupt, and for each CPU interface **forwards the interrupt** with the highest priority to the interface, for **priority masking** and **preemption handling**. (分发器`集中所有中断源`，确定每个中断的`优先级`，并为每个CPU接口转发具有最高优先级的中断到接口，以进行优先级屏蔽和抢占处理)

- The Distributor provides a **programming interface** for(分发器提供了一个编程接口):

	- **`Globally enabling`** the forwarding of **`interrupts to the CPU interfaces`**(全局启用将中断转发到CPU接口). ==第一把钥匙==
	- **`Enabling or disabling`** each interrupt(启用或禁用每个中断).
	- Setting the **`priority`** level of each interrupt(设置每个中断的优先级).
	- Setting the **`target processor`** list of each interrupt(设置每个中断的**目标处理器**列表)
	- Setting each peripheral interrupt to be **`level-sensitive`** or **`edge-triggered`**(将每个外设中断设置为**电平敏感或边缘触发**).
	- Setting each interrupt as either **`Group 0 or Group 1`**(将每个中断设置为组0或组1).
	- **Forwarding** an SGI to one or more target processors(**将SGI转发**到一个或多个目标处理器).
### (4)`CPU interface` block(CPU接口单元)
- Each `CPU interface block` provides the interface for a processor that is connected to the GIC. Each CPU interface provides a **programming interface** for(每个CPU接口块都为连接到GIC的处理器提供接口。每个CPU接口都为以下方面提供编程接口):

	- **`enabling the signaling`** of interrupt requests to the processor (允许向处理器发送中断请求信号)，==**第二把钥匙**==
	- **`acknowledging`** an interrupt (确认一个中断)
	- **`indicating completion`** of the processing of an interrupt (表示中断处理的完成)
	- setting an interrupt **`priority mask`** for the processor (为处理器设置中断优先级掩码)
	- defining the **`preemption policy`** for the processor (为处理器定义**抢占策略**)
	- determining the **`highest priority pending interrupt`** for the processor(为处理器确定触发中断中的最高优先级)
- When enabled, a CPU interface `takes the highest priority pending` interrupt for its connected processor and determines whether the interrupt has `sufficient priority` for it to signal the interrupt request to the processor(启用时，CPU接口为其连接的处理器获取最高优先级的`挂起中断，并确定中断是否有足够优先级向处理器发出中断请求信号`)
## 2.3 中断分组
- The GIC includes interrupt grouping functionality that supports(GIC包括中断分组功能支持):

	- configuring each interrupt as either **`Group 0 or Group 1`** (将每个中断配置为组0或组1)
	- signaling Group 0 interrupts to the target processor using either the **IRQ or the FIQ** **exception request** (`使用IRQ或FIQ异常请求向目标处理器发送第0组中断信号`)
	- `signaling Group 1 interrupts to the target processor using the IRQ exception request only` (仅使用IRQ异常请求向目标处理器发送第1组信号中断)
	- a **unified scheme** for handling the priority of Group 0 and Group 1 interrupts (对于`中断优先级的处理，GIC对Group0 和 Group1使用同样的方案)`
	- **optional lockdown** of the configuration of some Group 0 interrupts.(对于一些Group 0 的中断，可以将其配置锁定)
		- — `Group 0 interrupts are Secure interrupts` (第0组的中断都是安全中断)
		- — `Group 1 interrupts are Non-secure interrupts`(第1组的中断都是非安全中断)

- `By default, all interrupts are Group 0 interrupts`, and are signaled to a connected processor using the` IRQ` interrupt request。(`默认情况下所有中断都在第0组`，产生的中断的信号`使用IRQ`向处理器发出中断请求)
- each interrupt can be configured as Group 1 interrupt, or as a Group 0 interrupt (每个中断都可以配置为第1组中断或第0组中断)
- a CPU interface can be configured to signal Group 0 interrupts to a connected processor using the FIQ interrupt request.(CPU接口可以配置为使用FIQ中断请求向连接的处理器发出组0中断信号)
## 2.4 中断优先级
- Software configures interrupt prioritization in the GIC by assigning a priority value to each interrupt source. `Priority values are 8-bit unsigned binary.` A GIC supports a `minimum of 16 and a maximum of 256 `priority levels.(可以通过软件为每个中断源分配优先级值来配置GIC中的中断优先级。`优先级值是8位无符号二进制`。GIC`支持最小16个和最大256个优先级`。)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3ef4cca5af1144b097c2fc861c737b13.png)

- In the GIC prioritization scheme, `lower numbers have higher priority`, that is, the lower the assigned priority value the higher the priority of the interrupt. `Priority field value 0 always indicates the highest possible interrupt priority`, and the lowest priority value depends on the number of implemented priority levels。(在GIC优先级设计方案中，`较低的数字具有较高的优先级`，即分配的优先级值越低，中断的优先级越高。`优先级字段值0总是表示可能的最高中断优先级`，而最低优先级值取决于实现的优先级级别的数量)

- `Priority masking` (优先屏蔽)

	- The `GICC_PMR` for a CPU interface defines a `priority threshold` for the target processor. The GIC only signals pending interrupts with a higher priority than this threshold value to the target processor. `A value of zero, the register reset value, masks all interrupts` from being signaled to the associated processor. (CPU接口单元的GICC_PMR定义了目标处理器的`优先级阈值`。GIC只向目标处理器发出优先级高于该阈值的挂起中断的信号。`零值，即寄存器重置值，屏蔽了所有被发信号通知相关处理器的中断`)
## 2.5 中断状态
- The following states apply at each interface `between the GIC and a connected processor`(以下状态适用于GIC和连接的处理器之间的每个接口):
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a79677cfff6e43988c032bf5a19f3cc8.png)
- **`Inactive`**(不活动)
	- An interrupt that is not active (非活动的中断).

- **`Pending`**(待定)
	- An interrupt from a source to the GIC that is recognized as asserted in hardware, or generated by software, and `is waiting to be serviced by a target processor`.
	(硬件设备产生 或 由软件生成一个中断到达GIC，**`并等待由目标处理器处理`**)

- **`Active `**(活跃)
	-  An interrupt from a source to the GIC that has been `acknowledged` by a processor, and `is being serviced but has not completed`.(一个中断到达GIC，已被处理器**`确认`**，并且是`正在处理但尚未完成`)

- **`Active and pending`**(活动和待定)
	- A processor is servicing the interrupt and the `GIC has a pending interrupt from the same source`.(处理器正在处理中断这个中断源，并且来了一个同类的中断源处于待定状态)

# 3. GIC重点寄存器分析
## 1.中断分发器寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/67f3d6aca6fe40eba8732c4bc6a1e9ac.png)
### (1)Distributor Control Register, `GICD_CTLR`
-  **Enables** the forwarding of pending interrupts from the Distributor to the CPU interfaces.(**允许**将待定中断从中断分发器**转发**到CPU接口单元,==第一把钥匙（从分发器到CPU接口单元的总开关）==)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c3307539a13a429f87ac791cd927e846.png)
- 可以在第0组和第1组设置，==默认在第0组==

### (2)Interrupt Group Registers, `GICD_IGROUPRn`
- The `GICD_IGROUPR `registers provide a `status bit for each interrupt `supported by the GIC.
- `Each bit controls whether the corresponding interrupt is in Group 0 or Group 1`.
- (GICD_IGROUPR寄存器为GIC支持的每个中断提供一个状态位,每个位控制相应的中断是在组0还是组1中)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/06426789d5ca4931b14b08976ee447cc.png)
### (3)Interrupt Set-Enable Registers, `GICD_ISENABLERn`
- The `GICD_ISENABLERs `provide a Set-enable bit for `each interrup`t supported by the GIC. 
- Writing `1 to a Set-enable bit enables` forwarding of the corresponding interrupt from the Distributor to the CPU interfaces. 
- `Reading a bit identifies whether the interrupt is enabled`.
- (GICD_ISENABLERs为GIC支持的每个中断提供一个设置启用位。将1写入设置启用位可以将相应的中断从中断分发器转发到CPU接口。读取位可以识别中断是否启用),==即，每一个中断源对应一位，相应位写1，可使能该中断能转发到CPU接口，读取相应位知道状态==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8ad13c711b61478b9d7e7dda37b9639d.png)
### (4)Interrupt Clear-Enable Registers, `GICD_ICENABLERn`
- The `GICD_ICENABLERs `provide a Clear-enable bit for each interrupt supported by the GIC.
- `Writing 1 to a Clear-enable bit disables` forwarding of the corresponding interrupt from the Distributor to the CPU interfaces. 
- Reading a bit identifies whether the interrupt is enabled. 
- (GICD_ICENABLERs为GIC支持的每个中断提供一个清除使能位。`将1写入清除使能位将禁止相应的中断从中断分发器转发到CPU接口`。读取一位标识中断是否启用)。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/589588c24c14421e9f5604637930f30c.png)
### (5)Interrupt Priority Registers, `GICD_IPRIORITYRn`
- The `GICD_IPRIORITYRs` provide an `8-bit priority field `for each interrupt supported by the GIC. 
- This field stores the priority of the corresponding interrupt.(GICD_IPRIORITYRs为GIC支持的每个中断提供一个8位优先级字段。该字段存储相应中断的优先级)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d4984e8febcf4e36af20edc3a43f1458.png)
> 1,先根据中断源m,计算落到哪个寄存器：n = m /4
> 2,确定目标寄存器的偏移地址：（0x400 + 4 * n)
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9bec6ac54fcf42c58f375423ec3c9542.png)
> 3,确定寄存器落到目标寄存器中哪个区段：m 对4取余（一个寄存器可以放四个中断源）

### (6)Interrupt Processor Targets Registers, `GICD_ITARGETSRn`
- The `GICD_ITARGETSRs `provide an 8-bit CPU targets field for each interrupt supported by the GIC. 
- This field `stores the list of target processors` for the interrupt. 
- That is, it holds the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and has sufficient priority.
- (GICD_ITARGETSRs为GIC支持的每个中断提供一个8位CPU目标字段。该字段存储中断的目标处理器列表。也就是说，`如果中断已经产生并具有足够的优先级，中断分发器将中断转发到的CPU接口列表`)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d30ba449b3414988a87526e9cbbef641.png)
## 2.CPU接口单元寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/94ceb60a1d41449fafbca1d63084a170.png)
### (1)CPU Interface Control Register, `GICC_CTLR`
- Enables the signaling of interrupts by the CPU interface to the connected processor
- (启用CPU接口向连接的处理器发送中断信号),==打开CPU接口单元到处理器的总开关，第二把钥匙==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/15558cae39c04431b3fef7e20625a597.png)
### (2) Interrupt Priority Mask Register, `GICC_PMR`
- The `GICC_PMR` for a CPU interface defines a `priority threshold` for the target processor.
- The `GIC only signals pending interrupts with a higher priority than this threshold value` to the target processor.
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/55937317654042ebab33176bfba16554.png)
### (3)Interrupt Acknowledge Register, `GICC_IAR`
- The processor reads this register to `obtain the interrupt ID` of the signaled interrupt. 
- This `read acts as an acknowledge` for the interrupt.(处理器读取该寄存器以获得信号中断的中断ID。该读取充当中断的确认)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fdd6fbc77dc44cfaac8cd9cf7b75fc7c.png)
### (4) End of Interrupt Register, `GICC_EOIR`
- A processor writes to this register to inform the CPU interface that it `has completed` the processing of the specified interrupt (处理器写入此寄存器以通知CPU接口它已完成对指定中断的处理)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5160f17011734fc387d587ce38dac359.png)
# 4. I.MX6ULL中断处理
## 1.GIC控制器寄存器地址
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d279d716010248848de976f0044acb96.png)
## 2.支持的中断源个数
- The `Global Interrupt Controller (GIC)` collects up to `128 interrupt requests` from all `chip sources `and provides an interface to the Cortex A7 CPU. 
- The `first 32 interrupts are private to the CPUs’ interface`. These interrupts are `not included in the table below`. 
- (全局中断控制器（GIC）从所有**芯片源**收集多达128个中断请求，并为Cortex A7 CPU提供接口。<font color=red>前32个中断是CPU接口的私有中断。这些中断不包括在下表中</font>)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3958c407a9ac4121ae0791f4290d04a8.png)
> 对于 Cortex-A7 内核来说中断 ID 只使用了 `512 `个,imx6ull芯片支持`160`个中断源

## 3.中断处理
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/517f4e6ff0fd437fa9ca87f719fd953c.jpeg)
- **`GPIO控制器初始化(外部中断需要)`**
- **`GIC中断控制器初始化`**
- **`CPSR初始化`**
# 5. 按键中断
## 5.1 按键原理图
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4ed0e3567a0c4dd8ae83b4961cd806e9.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ac096565d5d346ac88a3fe80b0bdc971.png)
**`需求:`**
==按键按下的时候，UART3_CTS管脚处于低电平，产生中断请求==

- 以前的处理方式是轮循，现在改成使用中断请求

## 5.2 编程思路
### 1.`GPIO中断控制器`初始化
#### (1)设置UART3_CTS管脚为`GPIO工作模式`
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/730590862b6148a496f637bffab2ce07.png)
```c
   /*Mux PAD GPIO Mode*/
    IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO26 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO26 |=  (0x5 << 0);
```
#### (2)设置管脚中断电平触发方式
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a60203d45c814eeaa8557f58ba228ea4.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fcf45abdafb5489291e223f503f6b1e6.png)

```c
    /*Interrupt n is low-level sensitive*/
    GPIO1->ICR2 &= ~(0x3 << 20);
```
#### (3)取消管脚中断屏蔽
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7f7d64f9fb6f4b9d95622a06a78ac62b.png)

```c
    /*UNMASKED — Interrupt n is enabled*/
    GPIO1->IMR |= (1 << 26);
```
#### (4)清除中断挂起状态
- The `GPIO_ISR` functions as an `interrupt status indicator`. 
- Each bit indicates whether an interrupt condition has been `met for the corresponding input signal`. 
- When an interrupt condition is met the corresponding bit in `this register is set`. 
- (GPIO_ISR用作中断状态指示器。每个位指示**`相应输入信号是否满足中断条件`**。当满足中断条件时，该寄存器中的相应位被设置)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/df74f9cf3965460cbd49b77e245b8dce.png)

```c
    /*clear interrupt first to avoid unexpected event */
    GPIO1->ISR |= (1 << 26);
```
### 2.GIC中断控制器初始化

```c
#include "imx6ull.h"

typedef unsigned int uint32_t;
typedef int (*handler_t)(int id); // 函数指针，本质是个指针，指向函数基地址

/*用来记录，每个中断源对应的中断处理函数入口地址
#define NUMBER_OF_INT_VECTORS 160 //< Number of interrupts in the Vector table 
imx6ull芯片支持160个中断源
*/
handler_t function_table[NUMBER_OF_INT_VECTORS]; // 中断源对应的中断函数处理基地址

//只能向CPU0注册中断
void request_irq(int irq_num,handler_t handler) // 传入中断ID,中断处理函数基地址
{
    int index,nbit;

    //1.使能GIC中断分发器转发给CPU接口单元
    GIC->D_CTLR |= (1 << 0);

    // 2.使能每个中断ID,让中断分发器转发到CPU接口
    // __IOM uint32_t D_ISENABLER[16] -->16x32= 512个中断源
    index  = irq_num >> 5;//index = irq_num / 32
    nbit   = irq_num - 32 * index;//nbit = irq_num % 32
    GIC->D_ISENABLER[index] |= (1 << nbit); 

    //3.中断分发器收到中断后，转发给CPU0
    // __IOM uint8_t D_ITARGETSR[512]; -->定义成连续数组，每个中断对应8位，[cpu7-cpu0]
    GIC->D_ITARGETSR[irq_num] |= (1 << 0);
    
    //允许任意优先级的中断到达CPU,优先级的值越大，级别越低
    GIC->C_PMR = (0x1f << 3); // 使用[7:3]共5位32种优先级
    
    //使能 CPU interface转发给CPU核
    GIC->C_CTLR |= (1 << 0);

    //记录中断处理函数
    function_table[irq_num] = handler;

    return;
}

void do_irq(void) {
    int irq_num;
    handler_t handler;

    // 1.获取中断号
    irq_num = (GIC->C_IAR & 0x3FF); // [9:0]
   
 	
    //2.根据中断号获取中断处理函数入口地址
    handler = function_table[irq_num]; // 前提是已经向GIC控制器注册过了，GIC才会记录中断处理函数向量表
    //3.调用中断处理函数
    handler(irq_num);
    
    //4.通知中断结束
    GIC->C_EOIR = (GIC->C_EOIR & ~(0x3FF)) | irq_num;
    return;
}

```
### 3.ARM核使能IRQ

<font color=red>**需要将中断异常禁止位清空，允许中断产生**</font>

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c91725d6f9c44eb6a6cc8bfe8824884f.png)

```c
int enable_irq(void)
{
    int status;

    asm(
        "mrs r0,cpsr\n" 	     @ 指令1：读取cpsr中的值到r0
        "mov r1,#1\n"
        "bic r0,r0,r1,lsl #7\n"       @ 将r0中的第7位清零-不禁止
        "msr cpsr,r0\n"                @ 将r0再次写到CPSR中，从而改变CPSR的I位
        "mov %0,r0\n"          	     @ 将r0写到C语言变量中进行返回
        :"=r"(status)           @ 输出列表:将内嵌汇编中的寄存器值输出到c变量
        :                             @ 输入列表:将c变量输入到内联汇编中使用的寄存器
        :"r0","r1"                @ 修改列表:内联汇编中修改的寄存器
    );

    return status;
}

int disable_irq(void)
{
    int status;

    asm(
        "mrs r0,cpsr\n"
        "mov r1,#1\n"
        "orr r0,r0,r1,lsl #7\n"
        "msr cpsr,r0\n"
        "mov %0,r0\n"
        :"=r"(status)
        :
        :"r0","r1"
    );

    return status;
}
```
# 6.实验代码
## 1.异常处理

```assembly
.global _start

_start:
    b reset
    ldr pc,_undefined_instruction
    ldr pc,_software_interrupt  @B   software_interrupt
    ldr pc,_prefetch_abort
    ldr pc,_data_abort
    ldr pc,_not_used
    ldr pc,_irq
    ldr pc,_fiq
_undefined_instruction:.word _undefined_instruction
_software_interrupt:.word software_interrupt
_prefetch_abort:.word _prefetch_abort
_data_abort:.word _data_abort
_not_used:.word _not_used
_irq:.word irq
_fiq:.word _fiq

reset:
    @告诉ARM核异常向量表所在的基地址
    adr r0,_start @获得异常向量表所在的地址
    mcr p15,0,r0,c12, c0, 0 @将异常向量表的基基地址写入cp15.c12

    ldr sp,=0x87800000
    bl  main

stop:
    b stop

software_interrupt:
    ldr sp,=0x81000000
    stmfd sp!,{r0-r12,lr}

    ldr r0,[lr,#-4]
    mov r1,#0xff
    bic r0,r0,r1,lsl #24

    ldmfd sp!,{r0-r12,pc}^

irq:
    ldr sp,=0x82000000
    sub lr,lr,#4
    stmfd sp!,{r0-r12,lr}

    bl do_irq

    ldmfd sp!,{r0-r12,pc}^

```
## 2.中断处理

```c
#include "imx6ull.h"

typedef unsigned int uint32_t;
typedef int (*handler_t)(int id); // 函数指针，本质是个指针，指向函数基地址

/*用来记录，每个中断源对应的中断处理函数入口地址
#define NUMBER_OF_INT_VECTORS 160 //< Number of interrupts in the Vector table 
imx6ull芯片支持160个中断源
*/
handler_t function_table[NUMBER_OF_INT_VECTORS]; // 中断源对应的中断函数处理基地址

//只能向CPU0注册中断
void request_irq(int irq_num,handler_t handler) // 传入中断ID,中断处理函数基地址
{
    int index,nbit;

    //1.使能GIC中断分发器转发给CPU接口单元
    GIC->D_CTLR |= (1 << 0);

    // 2.使能每个中断ID,让中断分发器转发到CPU接口
    // __IOM uint32_t D_ISENABLER[16] -->16x32= 512个中断源
    index  = irq_num >> 5;//index = irq_num / 32
    nbit   = irq_num - 32 * index;//nbit = irq_num % 32
    GIC->D_ISENABLER[index] |= (1 << nbit); 

    //3.中断分发器收到中断后，转发给CPU0
    // __IOM uint8_t D_ITARGETSR[512]; -->定义成连续数组，每个中断对应8位，[cpu7-cpu0]
    GIC->D_ITARGETSR[irq_num] |= (1 << 0);
    
    //允许任意优先级的中断到达CPU,优先级的值越大，级别越低
    GIC->C_PMR = (0x1f << 3); // 使用[7:3]共5位32种优先级
    
    //使能 CPU interface转发给CPU核
    GIC->C_CTLR |= (1 << 0);

    //记录中断处理函数
    function_table[irq_num] = handler;

    return;
}

void do_irq(void) {
    int irq_num;
    handler_t handler;

    // 1.获取中断号
    irq_num = (GIC->C_IAR & 0x3FF); // [9:0]
   
 	
    //2.根据中断号获取中断处理函数入口地址
    handler = function_table[irq_num]; // 前提是已经向GIC控制器注册过了，GIC才会记录中断处理函数向量表
    //3.调用中断处理函数
    handler(irq_num);
    
    //4.通知中断结束
    GIC->C_EOIR = (GIC->C_EOIR & ~(0x3FF)) | irq_num;
    return;
}

int enable_irq(void)
{
    int status;

    asm(
        "mrs r0,cpsr\n"
        "mov r1,#1\n"
        "bic r0,r0,r1,lsl #7\n"
        "msr cpsr,r0\n"
        "mov %0,r0\n"
        :"=r"(status)
        :
        :"r0","r1"
    );

    return status;
}

int disable_irq(void)
{
    int status;

    asm(
        "mrs r0,cpsr\n"
        "mov r1,#1\n"
        "orr r0,r0,r1,lsl #7\n"
        "msr cpsr,r0\n"
        "mov %0,r0\n"
        :"=r"(status)
        :
        :"r0","r1"
    );

    return status;
}

```
## 3.按键处理

```c
#include "imx6ull.h"
#include "device.h"

// 中断处理函数
int key_interrupt_handler(int id) {
    // 中断处理：打印信息
    uart_printf("key press,irq number:%d\r\n",id);
    
    /*Clear GPIO1_26 Interrupt Statu*/
    // 中断调用结束后，清除GPIO的中断标志，否则GPIO一直发送外部中断信号
    GPIO1->ISR |= (1 << 26);
    
    return 0;
}

void key_gpio_interrupt_init(void)
{
    /*GPIO Mode*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO26 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO26 |=  (0x5 << 0);

    /*interrupt trigger level:low*/
    GPIO1->ICR2 &= ~(0x3 << 20);

    /*Enable GPIO1_26 Interrupt*/
    GPIO1->IMR |= (1 << 26);

    /*Clear GPIO1_26 Interrupt Statu*/
    GPIO1->ISR |= (1 << 26);

    return;
}

void key_interrupt_test(void)
{
    // GIC控制器初始化，准备工作
    key_gpio_interrupt_init(); // GPIO初始化
    request_irq(GPIO1_Combined_16_31_IRQn,key_interrupt_handler); // 注册中断，中断号67+32=99
    enable_irq(); // arm核使能IRQ中断
   // 按下按键时，产生IRQ中断异常->CPSR位与PC->异常向量表->
    return;
}

```
## 4.按键中断测试

```c
void key_interrupt_test(void)
{
    // GIC控制器初始化，准备工作
    key_gpio_interrupt_init(); // GPIO初始化
    request_irq(GPIO1_Combined_16_31_IRQn,key_interrupt_handler); // 注册中断，中断号67+32=99
    enable_irq(); // arm核使能IRQ中断
   // 按下按键时，产生IRQ中断异常->CPSR位与PC->异常向量表->异常处理函数->获取中断号->调用已经注册好的中断处理函数
    return;
}
```



```c
int main(void)
{
    key_interrupt_test(); // 中断打开-GIC初始化工作
      // 按键按下后，低电平触发中断，CPU执行中断函数，执行后再继续执行灯闪烁操作
    led_test();         
    
    return 0;
}
```
# 7. 实验结果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3c98318087a94cf9bc32dbb5826f51fc.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1b91e989b506425aa8bafa2cfd155a1d.gif)