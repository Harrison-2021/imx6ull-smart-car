# 1.IIC总线介绍
`IIC`(`Inter-Integrated Circuit`,集成电路)总线是一种由PHILIPS公司开发的==串行总线==，用于==连接微控制器及其外围设备==，它具有如下特点。

- (1)只有==两条总线线路==:一条==串行数据线(`SDA`)==,一条==串行时钟线(`SCL`)==
- (2)每个连接到总线的器件都可以使用软件==根据它的唯一的地址来识别==
- (3)传输数据的设备间是简单的==主/从关系==
- (4)主机可以用作主机发送器或主机接收器
- (5)它是一个真正的==多主机总线==，两个或多个主机同时发起数据传输时，可以==通过冲突检测和仲裁==来防止数据被破坏
- (6)串行的==8位双向数据传输==，位速率在**标准模式**下可达`100kbit/s`,在**快速模式**下可达`400kbit/s`,在**高速模式**下可达`3.4Mbit/s`
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/594d25d3b6b7495aab8ff63b2e04903f.png)
# 2.IIC总线的信号类型
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5e4b6b2238e34c87992cdf26995ae61b.png)
## 开始信号(S)和结束信号(P)
- ==开始信号==:`SCL` 为高电平时，`SDA`由**高电平向低电平跳变**，开始传送数据
- ==结束信号==:`SCL` 为高电平时，`SDA`由**低电平向高电平跳变**，结束传送数据
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/15401eaf3e714b38b9cf49dd1b9c41f0.png)
## 响应信号(ACK)
- **接收器**在接收到`8位`数据后，在**第9个时钟周期**，**拉低SDA电平**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/be1451856605456c86d99351fd23d44b.png)
> 注意:`SDA`上**传输的数据**必须==在SCL为高电平期间保持稳定==，==SDA上的数据只能在SCL为低电平期间变化==

# 3.IIC总线的数据传输格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c0b54d425273416483aa59ada1df9ca6.png)
- 发送到`SDA`线上的**每个字节必须是8位的**，
- 每次传输可以发送的**字节数量不受限制**。
- 首先传输的是数据的最高位(`MSB`)。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c82918f7628d405fa44bf90b568d77f9.png)
> 启动一个传输时，==主机先发送S信号==，然后发出8位数据。这8位数据中==前7位为从机的地址，第8位表示传输的方向(0表示写操作，1表示读操作)。从机收到后会发出一个ACK信号==.

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ed0a21550eb744b081b7ddcff82078a5.png)
> 注意:==主机接收器在接收到最后一个字节后，也不会发出ACK信号==。于是，==从机发送器释放SDA线，以允许主机发出P信号结束传输==.
# 4.光环境传感器硬件原理图分析
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4f0631963f3248ababcf743097e44ae5.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/542213c2ca1a46e1abf7a012b535a90f.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b305b062c70f47d695f2f661a4331c9a.png)
# 5.GPIO模拟IIC时序
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b92400bf1ff24359b70f6f54f0b6ae8c.png)
## 1.初始化管脚工作模式
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fca07a0a4eb34b81bdfc8cb89068a625.png)

```c
void software_iic_init()
{
    //设置管脚为GPIO功能
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 &= ~(0xf << 0);//SCL
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 |=  (0x5 << 0);

    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO29 &= ~(0xf << 0);//SDA
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO29 |=  (0x5 << 0);

    gpt_delay_sec(1);

    return;
}

```
## 2.管脚输入输出电平控制

```c
#define     SDA_OUT_MODE()    do{GPIO1->GDIR |= (1 << 29);}while(0)
#define     SCL_OUT_MODE()    do{GPIO1->GDIR |= (1 << 28);}while(0)
#define     SDA_IN_MODE()     do{GPIO1->GDIR &= ~(1 << 29);}while(0)

#define     SDA_INPUT_LEVEL() ((GPIO1->DR & (1 << 29)) ? 1 : 0)  

#define     SDA_OUTPUT_LEVEL(LEVEL)\
  do{GPIO1->DR &= ~(1 << 29);GPIO1->DR |= (LEVEL << 29);}while(0)
  
#define     SCL_OUTPUT_LEVEL(LEVEL)\
  do{GPIO1->DR &= ~(1 << 28);GPIO1->DR |= (LEVEL << 28);}while(0)

#define     HIGH        1
#define     LOW         0

```
## 3.产生IIC开始信号

```c
/*IIC START:SCL = 1,SDA = 1->0*/
void software_iic_start()
{
    //SDA/SCL 输出模式
    SDA_OUT_MODE();
    SCL_OUT_MODE();

    //开始的时候，SDA和SCL都是高电平状态
    SDA_OUTPUT_LEVEL(HIGH);
    SCL_OUTPUT_LEVEL(HIGH);

    IIC_delay(1);

    //在SCL为高电平状态时，SDA从高变成低，产生开始信号
    SDA_OUTPUT_LEVEL(LOW);
    IIC_delay(1);

    return;
}

```
## 4.产生IIC停止信号

```c
/*IIC STOP:SCL = 1,SDA = 0->1*/
void software_iic_stop()
{
    //SDA/SCL 输出模式
    SDA_OUT_MODE();
    SCL_OUT_MODE();

    //此时将SCL拉低，让为了让SDA可以改变电平状态，产生结束信号
    SCL_OUTPUT_LEVEL(LOW);
    SDA_OUTPUT_LEVEL(LOW);
    IIC_delay(1);
    
    //SCL为高电平时，SDA从低到高，产生结束信号
    SCL_OUTPUT_LEVEL(HIGH);
    IIC_delay(1);
    SDA_OUTPUT_LEVEL(HIGH);
    IIC_delay(1);

    return;
}

```
## 5.IIC总线写数据

```c
/*Write 1 Byte to IIC*/
void software_iic_write_byte(uint8 data)
{
    int level;
    uint8 loop;

    //SDA为输出模式
    SDA_OUT_MODE();

    //SCL 为低电平，以便改变SDA上面的数据-拉低后可以直接写SDA,可以无需等待
    SCL_OUTPUT_LEVEL(LOW);

    for(loop = 8;loop > 0;loop --)
    {
        //先发送最高位,在SCL高电平时,SDA必须保持稳定
        level = (data >> 7) & 1;
        SDA_OUTPUT_LEVEL(level);
        SCL_OUTPUT_LEVEL(HIGH);
        IIC_delay(1);

        //SCL为低电平时，SDA可以任意改变
        SCL_OUTPUT_LEVEL(LOW);
        //低位向高位移动
        data <<= 1;//data = data << 1
        IIC_delay(1);
    }

    return;
}

```
## 6.IIC总线读数据

```c
/*Read 1 byte from IIC*/
uint8 software_iic_read_byte()
{
    uint8 loop;
    uint8 value = 0;

    //SDA为输入模式
    SDA_IN_MODE();

    // SCL 为低电平，以便改变SDA上面的数据
    // 读SDA数据时，先将SCl拉低，等待SDA写数据，有数据了才能读
    SCL_OUTPUT_LEVEL(LOW);
    IIC_delay(1);

    for(loop = 8; loop > 0;loop --)
    {
        SCL_OUTPUT_LEVEL(HIGH);
        IIC_delay(1);

        value <<= 1;
        //读取1位数据
        value |= SDA_INPUT_LEVEL();

        SCL_OUTPUT_LEVEL(LOW);
        IIC_delay(1);
    }

    return value;
}

```
## 7.主机向从机发送ACK

```c
/*主机向从机发送ACK*/
void software_iic_send_ack()
{
    SDA_OUT_MODE();

    //SCL为低电平期间，数据允许改变
    SCL_OUTPUT_LEVEL(LOW); 
    //拉低SDA线，产生ACK信号
    SDA_OUTPUT_LEVEL(LOW); 
    IIC_delay(1);

    //SCL高电平期间，SDA保持稳定，从机读取SDA线上的状态
    SCL_OUTPUT_LEVEL(HIGH);
    IIC_delay(1);

    return;
}

```
## 8.主机向从机发送NACK

```c
void software_iic_send_nack(void)
{
    SDA_OUT_MODE();

    SCL_OUTPUT_LEVEL(LOW);
    SDA_OUTPUT_LEVEL(HIGH);
    IIC_delay(1);

    //SCL为高电平期间，SDA也为高，此时主机不向从机发送ACK
    //，此时从机就知道，主机是不想接受数据了
    SCL_OUTPUT_LEVEL(HIGH); 
    IIC_delay(1);

    return;
}

```
## 9.等待从机给主机的应答信号

```c
/*等待从机给主机的应答信号
 *
 *0  : 成功
 *-1 : 超时，失败
 */
uint8 software_iic_wait_ack()
{
    uint8 ret;
    uint8 time_out = 0;

    //SDA设为输入模式
    SDA_IN_MODE();

    SCL_OUTPUT_LEVEL(LOW);
    IIC_delay(1);

    //SCL为高电平期间，读取SDA的值
    SCL_OUTPUT_LEVEL(HIGH);
    IIC_delay(1);

    do{
        if(time_out >50)
        {
            software_iic_stop();
            return -1;
        }

        //读取SDA状态
        ret = SDA_INPUT_LEVEL();
        IIC_delay(1);
        time_out ++;
    }while(ret);

    return 0;
}

```
# 六、LTR-553ALS-WA光环境传感器
## 1.介绍
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5ffc8a57d2f7495f8dd0d2b0714f9507.png)

- The `LTR-553ALS-WA` is an `integrated` `low voltage` I2C `digital light sensor [ALS]` and `proximity sensor [PS]` with built-in `emitter`, in a single `miniature chipled` `lead-free surface` mount package. This sensor `converts light intensity to a digital output` signal capable of direct I2C interface.
	- > ==LTR-553ALS-WA==是一个集成的==低压I2C数字光传感器[ALS]和接近传感器[PS]==，内置发射器，在单个微型芯片无铅表面贴装封装中。该传感器==将光强转换为能够直接I2C接口的数字输出信号==。
- It provides a `linear response` over a wide dynamic range from 0.01 lux to 64k lux and is well suited to applications under `high ambient brightness`. With built-in proximity sensor (emitter and detector), `LTR-553ALS-WA `offers the feature to `detect object` at a `user configurable distance`.
	- >LTR-553ALS-WA在0.01勒克斯到64k勒克斯的宽动态范围内提供线性响应，非常==适合高环境亮度下的应用==。凭借内置的接近传感器（发射器和检测器），LTR-553ALS-WA提供了在用户==可配置距离内检测物体的功能==。
- The sensor supports an `interrupt feature` that `removes the need to poll the sensor` for a reading which improves system efficiency. The sensor also supports several `features` that help to `minimize` the occurrence of `false triggering`. This `CMOS` design and factory-set one time `trimming` capability ensure minimal sensor-to-sensor `variations` for ease of `manufacturability` to the end customers.
	- >该传感器支持==中断功能==，无需轮询传感器以获取读数，从而提高系统效率。该传感器还支持有助于最大限度地==减少误触==发生的几个功能。这种CMOS(互补式金属氧化物半导体)设计和工厂设置的一次性微调能力确保了最小的传感器到传感器的变化，以便于最终客户的制造。
## 2.从机地址
- The 7 bits slave address for this sensor is `0x23H`. A read/write bit should be appended to the slave address by the master device to `properly communicate` with the sensor.
	- >该传感器的7位从属地址为==0x23H==。主设备应将读/写位附加到从属地址以与传感器正确通信。
	![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d8b11efc4c4d4118ac0949d91ad70649.png)
## 3.操作时序分析
### (1)读寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b17293a317154661aa8b827d16f2025b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b5ff29c74f2e42529fcb03fdc6910dfd.png)
### (2)写寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f36904c674594d3b872126152fe9336d.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/05e0d595251d4513af02c23a3648ed04.png)
## 4.重点寄存器分析
### (1)MANUFAC_ID Register (0x87)
- ==厂商ID,芯片唯一标识==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4f647e216df4476d9e2b1c2393f2747c.png)
### (2)PS_CONTR Register (0x81)
- The `PS_CONTR` register controls the ` proximity sensor [PS]operation modes`. The PS sensor can be set to either `standby` mode or `active` mode. At either of these modes, `the I2C circuitry is always active`. The `default mode after power up is standby mode`. During standby mode, there is no PS measurement performed but I2C communication is allowed to enable read/write to all the registers.
	- >PS_CONTR寄存器==控制PS操作模式==。PS传感器可以设置为==待机模式==或==活动模式==。在这两种模式中的任何一种下，I2C电路始终处于活动状态。上电后的==默认模式是待机模式==。在待机模式下，不执行PS测量，但允许I2C通信启用对所有寄存器的读/写。
- `PS Gain` controls the gain setting for the PS sensor. PS `Saturation Indicator` Enable bit is used for enabling the saturation indicator in `Bit 7 of PS_DATA register (0x8E)`
	- >PS Gain控制PS传感器的==增益==设置。PS==饱和指示器启用位==用于启用PS_DATA寄存器（0x8E）第7位中的饱和指示器

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5d36c44a4f454a68a4bccf66095ed6d4.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/860afc77fd124bddbda04748732dd34a.png)
### (3)PS_DATA_0 Register/PS_DATA_1 (0x8D / 0x8E)
- The PS ADC channel data are expressed as a `11-bit data spread over two registers`. The `PS_DATA_0` and `PS_DATA_1` registers provide the lower and upper byte respectively. **When the I2C read operation starts, both the registers are locked until the I2C read operation is completed**. This will ensure that the data in the registers is from the same measurement even if an `additional integration cycle ends` during the read operation. **New measurement data is stored into temporary registers and the PS_DATA registers are updated as soon as there is no on-going I2C read operation.**
	- >PS ADC通道数据表示为分布在两个寄存器上的11位数据。PS_DATA_0和PS_DATA_1寄存器分别提供下字节和上字节。==当I2C读取操作开始时，两个寄存器都被锁定==，直到I2C读取操作完成。这将确保寄存器中的数据来自相同的测量，即使在读取操作期间额外的集成周期结束。==新的测量数据存储到临时寄存器中，一旦没有正在进行的I2C读取操作，PS_DATA寄存器就会更新==。
- PS Saturation Flag is used for monitoring the internal IC saturation. **It will be flagged when the IC has reached saturation and not able to perform any further PS measurement.** The PS Saturation Indicator Enable bit in `PS_CONTR Register (0x81)` has to `be enabled in order to use this feature`. If it is not enable, the flag will always be indicated as 0
	- >PS饱和度标志用于监控内部IC的饱和度。==当IC达到饱和度并且无法执行任何进一步的PS测量时，它将被标记==。PS_CONTR寄存器（0x81）中的PS饱和度指示器启用位必须启用才能使用此功能。如果不启用，该标志将始终指示为0
### (4)ALS_CONTR Register (0x80)
- The ALS_CONTR register controls the **`ALS Gain setting, ALS operation modes and software (SW) reset for the sensor.`** The ALS sensor can be set to **either standby mode or active mode**. At either of these modes, the I2C circuitry is always active. The default mode after power up is standby mode. During standby mode, there is no ALS measurement performed but I2C communication is allowed to enable read/write to all the registers.
	- >ALS_CONTR寄存器控制==ALS增益设置、ALS操作模式和传感器的软件（SW）复位==。ALS传感器可以设置为待机模式或活动模式。在这两种模式中的任何一种，I2C电路始终处于活动状态。上电后的默认模式是待机模式。在待机模式下，不执行ALS测量，但允许I2C通信启用对所有寄存器的读/写。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fe78ca8e0991420ca7d9220f72a24fcd.png)
### (5)ALS_DATA_CH1 Register (0x88 / 0x89)
- The ALS_DATA registers should be read as a group, **`with the lower address read back first (i.e. read 0x88 first, then read 0x89)`**. These two registers should also be read `before reading channel-0 data` (from registers 0x8A, 0x8B).
	- >ALS_DATA寄存器应==作为一组读取==，==较低的地址先读回==（即先读0x88，然后读0x89）。==在读取通道-0数据（来自寄存器0x8A、0x8B）之前，也应读取这两个寄存器==。
- When the I2C read operation starts, **all four ALS data registers are locked until the I2C read operation of register 0x8B is completed**. This will ensure that the data in the registers is from the same measurement even if an additional integration cycle ends during the read operation. New measurement data is stored into temporary registers and the ALS_DATA registers are updated as soon as there is no on-going I2C read operation.
	- >当I2C读取操作开始时，所有四个ALS数据寄存器都被锁定，直到寄存器0x8B的I2C读取操作完成。这将确保寄存器中的数据来自相同的测量，即使在读取操作期间额外的积分周期结束。新的测量数据被存储到临时寄存器中，一旦没有正在进行的I2C读取操作，ALS_DATA寄存器就会更新。
- The `ALS ADC channel-1 `data is expressed as a `16-bit data` spread over two registers. The `ALS_DATA_CH1_0 `and `ALS_DATA_CH1_1` registers provide the lower and upper byte respectively.
	- >ALS ADC通道-1数据表示为分布在两个寄存器上的16位数据.ALS_DATA_CH1_0和ALS_DATA_CH1_1寄存器分别提供下字节和上字节。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b64a4d69757d4f4cb061d50f4b596dc2.png)
### (6)ALS_DATA_CH0 Register (0x8A / 0x8B)
- These two registers should be read **after reading channel-1 data** (from registers 0x88, 0x89). `Lower address register should be read first` (i.e read 0x8A first, then read 0x8B). See ALS_DATA_CH1 register information above.
	- >这两个寄存器应该在读取通道1数据（来自寄存器0x88、0x89）后读取。低地址寄存器应该首先读取（即先读取0x8A，然后读取0x8B）。参见上面ALS_DATA_CH1寄存器信息。
- The `ALS ADC channel-0` data is expressed as a 16-bit data spread over two registers. The `ALS_DATA_CH0_0 `and `ALS_DATA_CH0_1` registers provide the lower and upper byte respectively
	- >ALS ADC通道-0数据表示为分布在两个寄存器上的16位数据。ALS_DATA_CH0_0和ALS_DATA_CH0_1寄存器分别提供下字节和上字节

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bb3b24c10d0b4cf5bd337d5fc61c19a5.png)
# 七、GPIO模拟IIC读取光环境传感器数据
## 1.GPIO模拟I2C总线时序代码
### iic.h
>==易错点：==
> #define SDA_INPUT_LEVEL() ((GPIO1->DR & (1 << I2C_SDA)) ? 1 : 0)
> 定义SDA_INPUT_LEVEL() 函数的返回值，是1或者0，不能用do while包裹
```c
#ifndef _IIC_H
#define _IIC_H
#include"imx6ull.h"
#include"gpt.h"

#define I2C_SDA 29
#define I2C_SCL 28
#define HIGH  1
#define LOW   0

#define SDA_OUT_MODE() do{GPIO1->GDIR |= (1 << I2C_SDA);}while(0)
#define SCL_OUT_MODE() do{GPIO1->GDIR |= (1 << I2C_SCL);}while(0)
#define SDA_IN_MODE()  do{GPIO1->GDIR &= ~(1 << I2C_SDA);}while(0)

#define SDA_INPUT_LEVEL() ((GPIO1->DR & (1 << I2C_SDA)) ? 1 : 0)
#define SDA_OUTPUT_LEVEL(LEVEL) do{GPIO1->DR &= ~(1 << I2C_SDA);\
        GPIO1->DR |= (LEVEL << I2C_SDA);}while(0)
#define SCL_OUTPUT_LEVEL(LEVEL) do{GPIO1->DR &= ~(1 << I2C_SCL);\
        GPIO1->DR |= (LEVEL << I2C_SCL);}while(0)

void iic_init();
void iic_start();
void iic_stop();
void iic_write_byte(uint8_t data);
uint8_t _iic_read_byte();
void iic_send_ack();
void iic_send_nack();
uint8_t iic_wait_ack();
#endif
```

### iic.c
> ==易错点：==
> 1. iic_wait_ack()函数中，SDA 是输入模式，等待从机写，然后读取SDA第9位的值
> 2. ==延迟时间，很短==，不能用gpt_delay_us(1)，可以自定义很短的延迟时间
> 3.iic_read_byte函数中，`return value`的位置不要放错了，不能放在循环里
```c
#include"iic.h"

// 1.初始化管脚工作模式
void iic_init() {
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 &= ~(0xf << 0); // SCL
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO28 |= (0x5 << 0);

    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO29 &= ~(0xf << 0); // SDL
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO29 |= (0x5 << 0);

    gpt_delay_us(1);
}

// 2.产生IIC开始信号
// SCL = 1, SDA = 1->0
void iic_start() {
    // SDA,SCL OUT MODE
    SDA_OUT_MODE();
    SCL_OUT_MODE();

    // SDA,SCL HIGH
    SDA_OUTPUT_LEVEL(HIGH);
    SCL_OUTPUT_LEVEL(HIGH);

    gpt_delay_us(1);

    // SDA->LOW
    SDA_OUTPUT_LEVEL(LOW);
    gpt_delay_us(1);

}

// 3.产生IIC停止信号
// SCL = 1, SDA = 0->1
void iic_stop() {
    SDA_OUT_MODE();
    SCL_OUT_MODE();

    //此时将SCL拉低，让为了让SDA可以改变电平状态，产生结束信号
    SDA_OUTPUT_LEVEL(LOW);
    SCL_OUTPUT_LEVEL(LOW);
    gpt_delay_us(1);

    SCL_OUTPUT_LEVEL(HIGH);
    gpt_delay_us(1);
    SDA_OUTPUT_LEVEL(HIGH);
    gpt_delay_us(1);

}

// 4.IIC总线写数据
/*Write 1 Byte to IIC*/
void iic_write_byte(uint8_t data) {

    // SDA为输出模式
    SDA_OUT_MODE();

    // SCL 为低电平，以便改变SDA上面的数据
    SCL_OUTPUT_LEVEL(LOW);

    //先发送最高位,在SCL高电平时,SDA必须保持稳定
    uint8_t i;
    uint8_t level;
    for(i = 8; i > 0; i--) {
        level = (data >> 7) & 1;
        SDA_OUTPUT_LEVEL(level);
        SCL_OUTPUT_LEVEL(HIGH);
        gpt_delay_us(1);

        //SCL为低电平时，SDA可以任意改变
        SCL_OUTPUT_LEVEL(LOW);

        //低位向高位移动
        data <<= 1;
        gpt_delay_us(1);
    }
}

/*Read 1 byte from IIC*/
uint8_t _iic_read_byte() {
    // SDA为输入模式
    SDA_IN_MODE();

    // SCL 为低电平，以便改变SDA上面的数据
    SCL_OUTPUT_LEVEL(LOW);
    gpt_delay_us(1); // 等待SDL写数据

    uint8_t value = 0;
    uint8_t i;
    for(i = 8; i > 0; i--) {
        SCL_OUTPUT_LEVEL(HIGH);// 在高电平时读
        gpt_delay_us(1);

        value <<= 1;
        value |= SDA_INPUT_LEVEL();

        SCL_OUTPUT_LEVEL(LOW);
        gpt_delay_us(1);

        return value;
    }
}
/*主机向从机发送ACK*/
void iic_send_ack() {
    SDA_OUT_MODE();

    //SCL为低电平期间，数据允许改变
    SCL_OUTPUT_LEVEL(LOW);

    //拉低SDA线，产生ACK信号
    SDA_OUTPUT_LEVEL(LOW);
    gpt_delay_us(1);

    //SCL高电平期间，SDA保持稳定，从机读取SDA线上的状态
    SCL_OUTPUT_LEVEL(HIGH);
    gpt_delay_us(1);
}

/*主机向从机发送NACK*/
 void iic_send_nack() {
    SDA_OUT_MODE();

    SCL_OUTPUT_LEVEL(LOW);
    SDA_OUTPUT_LEVEL(HIGH);
    gpt_delay_us(1);

    //SCL为高电平期间，SDA也为高，此时主机不向从机发送ACK
    //，此时从机就知道，主机是不想接受数据了
    SCL_OUTPUT_LEVEL(HIGH);
    gpt_delay_us(1);
}

/*等待从机给主机的应答信号
*
 *0  : 成功
*-1 : 超时，失败
*/
uint8_t iic_wait_ack() {
    uint8_t ret;
    uint8_t time_out = 0;

    SDA_IN_MODE();

    SCL_OUTPUT_LEVEL(LOW);
    gpt_delay_us(1);

    SCL_OUTPUT_LEVEL(HIGH);
    gpt_delay_us(1);

    do {
        if(time_out > 50) {
            iic_stop();
            return -1;
        }
        
        ret = SDA_INPUT_LEVEL();
        gpt_delay_us(1);
        time_out++;
    } while(ret);
    return 0;
}

```
## 2.GPIO模拟I2C读取环境传感器编程思路
### (1)写光环境传感器寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d8b11efc4c4d4118ac0949d91ad70649.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f36904c674594d3b872126152fe9336d.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/05e0d595251d4513af02c23a3648ed04.png)

```c
uint8_t software_ltr_553als_wa_read_register(uint8_t regaddr)
{
    int ret;
    uint8_t regval;

    //1.产生start信号
    software_iic_start();
    
    //2.发送从机地址 + write
    software_iic_write_byte(SLAVE_ADDRESS_WRITE);
    
    //3.等待从机ACK信号
    ret = software_iic_wait_ack();
    if(ret < 0){
        uart_printf("Fail to wait slave ack\r\n");
        return;
    }
    
    //4.发送寄存器地址
    software_iic_write_byte(regaddr);
    
    //5.等待从机ACK信号
    ret = software_iic_wait_ack();
    if(ret < 0){
        uart_printf("Fail to wait slave ack\r\n");
        return;
    }

    //6.重新发送开始信号
    software_iic_start();
    
    //7.发送从机地址 + read
    software_iic_write_byte(SLAVE_ADDRESS_READ);

    //8.等待从机ACK信号
    ret = software_iic_wait_ack();
    if(ret < 0){
        uart_printf("Fail to wait slave ack\r\n");
        return;
    }

    //9.读取从机数据
    regval = software_iic_read_byte();

    //10.发送NACK信号
    software_iic_send_nack();

    //11.发送stop信号
    software_iic_stop();

    return regval;
}

```
### (2)读光环境传感器寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d8b11efc4c4d4118ac0949d91ad70649.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b17293a317154661aa8b827d16f2025b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b5ff29c74f2e42529fcb03fdc6910dfd.png)


```c
/*GPIO模拟iic向LTR-553ALS-WA传感器从机的指定寄存器读数据*/
uint8_t iic_read_register(uint8_t regaddr) {
    uint8_t regval;
    uint8_t  res;
    // 1.start signal
    iic_start();

    // 2.slave addr + write
    iic_write_byte(LTC_ADR_WRITE);

    // 3.wait ack
    res = iic_wait_ack();
    if(res < 0) {
        uart_printf("write slave address fault!\r\n");
        return;
    }
    // 4.register address
    iic_write_byte(regaddr);

    // 5.wait slave ack
    res = iic_wait_ack();
    if(res < 0) {
        uart_printf("write register address fault!\r\n");
        return;
    }
    // 6.restart 
    iic_start();

    // 7.slave addr + read
    iic_write_byte(LTC_ADR_READ);

    // 8.wait slave ack
    res = iic_wait_ack();

    if(res < 0) {
        uart_printf("write slave address fault!\r\n");
        return;
    }
    // 9.read register command
    regval = iic_read_byte();
 
    // 10.host send nack to slave 
    iic_send_nack();
 
    // 11.stop signal
    iic_stop();
    // software_iic_stop();

    return regval;
}
```
### (3)读光环境传感器ID
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4f647e216df4476d9e2b1c2393f2747c.png)

```c
/* 测试读取光传感器厂家ID*/
void read_ltr_553als_manufac_id() {
    uint8_t manufac_id;
    iic_init();
   
    manufac_id = iic_read_register(LTC_MANUFAC_ADR);
    // manufac_id = software_ltr_553als_wa_read_register(LTC_MANUFAC_ADR);
    uart_printf("manufac_id : %#x\r\n",manufac_id);
}

void iic_test() {
    uint8_t index = 10;
    while(index--) {
        read_ltr_553als_manufac_id();
        gpt_delay_sec(1);
    }
}
```

#### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a9fa6a20e8504afaa3aa641f590533af.png)
### (4)读取接近传感器数据
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5d36c44a4f454a68a4bccf66095ed6d4.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/860afc77fd124bddbda04748732dd34a.png)

```c
/* 测试读取接近传感器数据*/
void read_ltc_553als_ps_data() {
    uint16_t ps_data;
    uint8_t data[2];
    iic_init();
    // active mode
    iic_write_register(LTC_PS_REG_ADR, 0x3);
    gpt_delay_ms(10);

    // read data from two register
    data[0] = iic_read_register(LTC_PS_DATA0_REG_ADR);
    data[1] = iic_read_register(LTC_PS_DATA1_REG_ADR);
    // join data
    ps_data = ((data[1] & 0x7) << 8) | data[0];
    uart_printf("ps data : %d\r\n",ps_data);
}
```
#### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/10b1d0a27fd046cfaef5a8037ce1e656.png)
### (5)读取光线传感器数据
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fe78ca8e0991420ca7d9220f72a24fcd.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b64a4d69757d4f4cb061d50f4b596dc2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b64a4d69757d4f4cb061d50f4b596dc2.png)

```c
/* 测试读取光线传感器数据*/
void read_ltc_553als_als_data() {
    uint8_t low;
    uint8_t high;
    uint16_t channel[2];
    // init
    iic_init();
    // active
    iic_write_register(LTC_ALS_REG_ADR, 0x1);
    gpt_delay_ms(10);
    // read data,ch1 first,ch2 second
    low = iic_read_register(LTC_ALS_CH1_DATA0_REG_ADR);
    high = iic_read_register(LTC_ALS_CH1_DATA1_REG_ADR);
    channel[1] = (high << 8) | low;
    uart_printf("CH1 DATA : %d\r\n", channel[1]);

    low = iic_read_register(LTC_ALS_CH0_DATA0_REG_ADR);
    high = iic_read_register(LTC_ALS_CH0_DATA1_REG_ADR);
    channel[0] = (high << 8) | low;
    uart_printf("CH0 DATA : %d\r\n", channel[0]);
}
```

#### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/64a27f81f7d342e98569c4ba8719aed4.png)
