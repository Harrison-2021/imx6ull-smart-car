# <font color="#fd6f01">1.理论篇</font>

# 一、LCD 介绍

**LCD (Liquid Crystal Display的简称)液晶显示器**。LCD的构造是在两片平行的玻璃基板中放置液晶盒，下基板玻璃上设置**TFT**(**Thin Film Transistor：薄膜晶体管**)，上基板玻璃上设置彩色滤光片，通过TFT上的信号与电压改变来控制液晶分子的转动方向，从而达到控制每个像素点偏振光射出与否而达到显示目的。
![图片描述](https://img.mukewang.com/wiki/63f882fb093609b908690582.jpg)



# 二、LCD屏工作原理

![图片描述](https://img.mukewang.com/wiki/63f8830a0897564d07520672.jpg)

**显示分辨率也称像素分辨率，简称为分辨率**，**它是指可以使显示器显示的像素个数，通常用每行像素数乘每列像素数来表示。**

例如，分辨率为1024×768的液晶屏，表示显示器可以显示768行，1024列，共可显示786432个像素点，由于**每个像素点**都由**R、G、B三个像素单元**(或称为子像素)构成，分别完成红、绿和蓝色的显示，所以总共约有240万个RGB像素单元(1024×3×768=2359296)。

同样，对于分辨率为800×600的液晶屏，表示可显示600行、800列，共可显示480000个像素，有1440000个像素单元。

显然，分辨率越高，显示屏可显示的像素就越多，图像就越清晰。

![图片描述](https://img.mukewang.com/wiki/63f8831f082997b012370484.jpg)



# 三、LCD屏分类

LCD 的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前的彩色LCD的连接方式一般有这么几种：MCU(**micro control unit**)接口（也写成MPU(**micro processor unit**)接口的），RGB接口，SPI接口、VSYNC接口，MIPI接口、MDDI接口，DSI接口等。

![图片描述](https://img.mukewang.com/wiki/63f8834d087a4add07220787.jpg)



# 四、LCD屏常用接口介绍



## 1.TTL(RGB)接口

最早期的LCD接口，**TTL接口属于并行方式传输数据的接口**，采用这种接口时，不**必在液晶显示器的驱动板端和液晶面板端使用专用的接口电路**，而是**由驱动板主控芯片输出的TTL数据信号经电缆线直接传送到液晶面板的输人接口**。由于TTL接口信号电压高、连线多、传输电缆长，因此，电路的抗干扰能力比较差，而且容易产生电磁干扰（EMI）。**在实际应用中，TTL接口电路多用来驱动小尺寸（15寸以下）或低分辨率的液晶面板**。TTL最高像素时钟只有28MHz,驱动板TTL输出接口中一般包含如下信号线:

![图片描述](https://img.mukewang.com/wiki/63f883b809ec41a512060395.jpg)

![图片描述](https://img.mukewang.com/wiki/63f883c908c1cf4505160559.jpg)



## 2.LVDS接口



### **(1)LVDS接口概述**

**LVDS，即Low Voltage Differential Signaling**，**是一种低压差分信号技术接口**。克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式。

LVDS输出接口利用非常低的电压（约350mV）在两条PCB走线或一对平衡电缆上通过差分进行数据的传输，即低压差分信号传输。采用LVDS输出接口，可以使得信号在差分PCB线或平衡电缆上以几百Mbit／s的速率传输，由于采用低压和低电流驱动方式，因此，实现了低噪声和低功耗。



### **(2)LVDS接口电路的组成**

在液晶显示器中，LVDS接口电路包括两部分，即**主板侧的LVDS输出接口电路（LVDS发送端）\**和\**液晶面板侧的LVDS输入接口电路（LVDS接收器）**。**LVDS发送器将驱动板主控芯片输出的TTL信号转换成低电压串行LVDS信号**，然后通过驱动板与液晶面板之间的柔性电缆（排线）将信号传送到液晶面板侧的LVDS接收端的LVDS解码IC中，**LVDS接收器再将串行信号转化为TTL电平信号，送往液晶屏时序控制与行列驱动电路**。**也就是其实TFT只识别TTL（RGB）信号**。

**在数据传输的过程中，还必须要有时钟信号的参与，\**\**LVDS接口无论是传输数据还是时钟，都是采用差分信号对进行传输\**。\**信号对\**即是指LVDS接口电路中，每一个数据或时钟传输通道的输出都是**正输出端和负输出端**两个信号。

![图片描述](https://img.mukewang.com/wiki/63f883f1083581b010830432.jpg)

LVDS信号的分为单路6位LVDS,双路6位LVDS，单路8位LVDS和双路8位LVDS,特点对比如下表：

![图片描述](https://img.mukewang.com/wiki/63f88409094f51c412800319.jpg)

> **单通道6位数据线常称“单6线”,该线有3组信号线,每个基色采用6位数据，共18位RGB数据。**
>
> **单通道8位数据线常称“双8线”,该线4组信号线,每个基色采用8位数据，共24位RGB数据。**



### (3)LVDS屏接口分析

![图片描述](https://img.mukewang.com/wiki/63f8841d0998a85912200736.jpg)



## 3.EDP接口



### **(1)EDP接口概述**

eDP，Embedded Display Port它是一种基于DisplayPort架构和协议的一种内部数字接口，可以用较简单的连接器以及较少的引脚来传递高分辨率信号，且能够实现多数据同时传输，所以它的传输速率也要远高于LVDS。适用于平板电脑、笔记本、一体机、大屏幕高分辨率手机。

液晶显示屏中EDP接口特点：

- 微封包结构，能够实现多数据的同时传输
- 无需LVDS转换电路，电路简洁。
- 较小的EMI（电磁干扰），并具有强大的版权保护功能。

举个例子，以分辨率为1920x1200、24bit彩色的液晶显示屏为例，如采用LVDS接口，则数据传输线需10对；若采用EDP接口，则只需要4对线。由此可见，EDP接口的优势相当明显，特别是在高清屏中。近年来，为了提高面板及处理器间的数据传输速度，在工控机及工业平板电脑中已大量采用EDP接口，EDP接口正迅速成为主流接口。

![图片描述](https://img.mukewang.com/wiki/63f8843a09830e3b11220516.jpg)

如上图所示，为eDP接口的典型连接框图，整个eDP接口信号由四部分组成：

**①Main Link**：**主通道；1~4对差分线组成（具体几对取决于LCD）**，用来传输**视频数据和音频数据**;速率1.6/2.7/5.4Gbps；没有时钟线；

**②AUX CH**：辅助通道；双向半双工；用于传输低带宽需求的数据，以及链路管理和设备控制信号；（这是翻译的，个人理解是可以读取屏的一些信息，如厂家、分辨率等）

**③HPD**：热插拔检测通道，单向；

**④BLControl**：背光控制引脚，对于1.2及以上版本，这个是可选的，如果LCD支持1.2及以上，硬件接口连接是可以不用背光控制引脚，直接通过AUX来控制背光。



### (2)EDP接口屏分析

![图片描述](https://img.mukewang.com/wiki/63f8846909e252cf09750847.jpg)



### (3)EDP和LVDS对比

![图片描述](https://img.mukewang.com/wiki/63f88478090ef4f208840605.jpg)



## 4.MIPI接口



### (1)MIPI介绍

**MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化，从而减少手机设计的复杂程度和增加设计灵活性。** MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。下图是按照 MIPI的规划下一代智能手机的内部架构。

![图片描述](https://img.mukewang.com/wiki/63f8848e09d8c60008650919.jpg)

![图片描述](https://img.mukewang.com/wiki/63f8849e099909f709780852.jpg)

MIPI是一个比较新的标准，其规范也在不断修改和改进，目前比较成熟的接口应用有**DSI(显示接口)和CSI（摄像头接口）**。CSI/DSI分别是指其承载的是针对Camera或Display显示应用，都有复杂的协议结构。



### (2)MIPI DSI接口

MIPI-DSI是一个应用于显示技术的**串行接口**。它以串行方式向外围设备(实际上是液晶显示器)发送像素信息或指令，并从外围设备读取状态信息或像素信息。**在传输过程中，它享有自己独立的通信协议**，包括数据包格式和纠错检测机制。下图是MIPI-DSI接口的简单示意图。

![图片描述](https://img.mukewang.com/wiki/63f884cb0937610708070533.jpg)

MIPI-DSI由应用层、协议层、信道管理层和物理层组成。

![图片描述](https://img.mukewang.com/wiki/63f884df098bde7d07070551.jpg)

#### PHY Layer

①物理层功能：**将通道管理层并行数据转换成串行数据发送；将接收到的串行数据转换成并行数据，传输给通道管理层**

②信号接口：一个时钟lane，两根线一个Dp，Dn；数据lane，两根线一个Dp，Dn；数据lane的数量1~4个不等，其中只有lane0是双向的（低速模式双向，高速模式也只能是单向），其他的都只能是单向（高速模式单向）。（解释一下，为什么lane0是双向的，因为有些时候需要向LCD读取一些LCD相关的数据信息）

③信号电平：信号有两种工作状态，高速模式状态（HS）和低速模式状态（LP）。在每一个状态下，信号电平不一样。

#### Lane Management

主要功能是将要发送的数据，按照字节为单位（MIPI-DSI是按照字节传输的，从低位到高位），分配到各个数据lane上；将lane上接收到的数据，恢复成原来的字节顺序。

#### Low Level Protocol

主要功能是将打包数据和解包数据。将数据通道管理层传输来的数据包解包，传输到应用层；将应用层送来的数据，打包成数据包的形式传输到通道管理层。

#### Application

应用层是直接连接到LCD的，负责与LCD之间的通信。对于LCD来说，协议层是将来自MIPI控制器的数据转化成DPI(Display Pixel Interface)或者DBI(Display Bus Interface)供给显示模组

> 推荐阅读DPI和DBI区别:https://www.cnblogs.com/vedic/p/10679464.html



### (3)MIPI DSI接口分析

![图片描述](https://img.mukewang.com/wiki/63f884f80996c24007200714.jpg)



## 5.MCU接口

因为主要针对单片机的领域在使用，因此得名。后在中低端手机大量使用，其主要特点是价格便宜。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用**I80来指MCU-LCD**屏。主要又可以分为8080模式(Intel)和6800模式(Moto)，**这两者之间主要是时序的区别**。信号线有CS/,RS,RD/,WR/,数据线。

**MCU接口LCD的Driver IC 都带GRAM****(***\*数据先写到它内部的GRAM中然后再显示到屏幕上\****)**,Driver IC作为MCU的一个协议处理，接收MCU发过来的Command/Data，可以相对独立的工作。**对于MCU接口的\**\*\*LCM(LCD Module)\*\**\*,其内部的芯片就叫LCD驱动器**。主要功能是对主机发过来的数据/命令，进行变换，变成每个像素的RGB数据，使之在屏上显示出来。这个过程不需要点、行、帧时钟。

![图片描述](https://img.mukewang.com/wiki/63f8852409019cc406680240.jpg)

优点是：控制简单方便，无需时钟和同步信号。

缺点是：要耗费GRAM，所以难以做到大屏（3.8以上）

**MCU接口标准名称是I80**，控制管脚有5个:

- CS 片选信号
- RS (置1为写数据,置0为写命令）
- /WR （为0表示写数据) 数据命令区分信号
- /RD （为0表示读数据）
- RESET 复位LCD（ 用固定命令系列 0 1 0来复位)

![图片描述](https://img.mukewang.com/wiki/63f8854d09c9c00410110357.jpg)

![图片描述](https://img.mukewang.com/wiki/63f8855a09d33ec410100351.jpg)



## 6.VGA接口

Video Graphics Array视频图形阵列是IBM于1987年提出的一个使用模拟信号的电脑显示标准。VGA接口即电脑采用VGA标准输出数据的专用接口。VGA接口共有15针，分成3排，每排5个孔。它传输红、绿、蓝模拟信号以及同步信号(水平和垂直信号)。



## 7.HDMI接口

**HDMI接口，全名叫做高清晰度多媒体接口(英文:High Definition Multimedia Interface,HDMI)**,是一种数字化视频/音频接口技术，是适合影像传输的专用型数字化接口，**可以同时传送音频和视频信号**，最高数据传输速度为2.25GB/S,同时无需在信号传送前进行数/模或者模/数转换。



## 8.IIC/SPI接口

IIC/SPI接口的屏一般都是小尺寸的LCD屏，通过SPI/I2C总线把命令和数据传输到LCD屏的驱动IC里面，驱动IC自带显存，只需要把数据写入，然后发送命令让其显示即可。

![图片描述](https://img.mukewang.com/wiki/63f8856f097e66ab07790325.jpg)



# 五、RGB与YUV



## 1.RGB格式

RGB色彩模式是工业界的一种颜色标准，是通过对红®、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的。常见的RGB像素格式有RGB565,RGB888等。

![图片描述](https://img.mukewang.com/wiki/63f8858309847c3807160416.jpg)

**RGB565**:16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感



## 2.YUV格式

YUV：与RGB编码方式类似，是一种颜色编码方法，主要用于电视系统以及模拟视频领域。**它是指将亮度参量（Y：Luminance或Luma）和色度参量（UV：Chrominance或Chroma）分开进行表示的像素编码格式。\**将一幅图像中的\**亮度信息和色彩信息分开**可以更好的进行相关图像处理算法的实现，同时还可以通过减少色度的采样降低视频的传输带宽。

**YUV使用RGB的信息，它从全彩色图像中产生一个黑白图像，然后提取出三个主要的颜色变成两个额外的信号来描述颜色。**把这三个信号组合回来就可以产生一个全彩色图像。
![图片描述](https://img.mukewang.com/wiki/63f88599098a591806930388.jpg)

**The human visual system (HVS) is less sensitive to color than to luminance (brightness)**

“色度”则定义了颜色的两个方面——色调与饱和度，分别用Cr和Cb来表示。

- Cr反映了RGB输入信号**红色部分与RGB信号亮度值之间的差异**
- Cb反映的是RGB输入信号**蓝色部分与RGB信号亮度值之间的差异**

此即所谓的**色差信号**，也就是我们常说的**分量信号（Y、Cr:R-Y、Cb:B-Y）**。

**将亮度参量Y和色度参量U/V分开表示的像素格式，主要用于优化彩色视频信号的传输。**YUV像素格式来源于RGB像素格式，通过公式运算，YUV三分量可以还原出RGB，YUV转RGB的公式如:

![图片描述](https://img.mukewang.com/wiki/63f885ac09825db707190406.jpg)



## 3.**YUV与YCbCr颜色空间的区别**

YCbCr颜色空间是YUV颜色空间的变种。**YUV颜色空间用于向后兼容的电视系统**，**YCbCr颜色空间则主要应用于图像、视频压缩的的数字彩色信号表示**，**是YUV压缩和偏移的版本，广泛应用于\**\*\*视频编码\*\**\*中**。

YCbCr的Y与YUV中的Y含义一致，Cb和Cr与UV同样都指色彩，Cb指蓝色色度，Cr指红色色度，在应用上很广泛，JPEG、MPEG、DVD、摄影机、数字电视等皆采此一格式。**因此一般俗称的YUV大多是指YCbCr。**



## 4.YUV的采样方式

**YUV采样方式，主要描述像素Y、U、V分量采样比例**，即表达每个像素时，Y、U、V分量的数目，通常有三种方式:YUV 4:4:4，YUV 4:2:2 ,YUV 4:2:0等。

**Y、U、V分量采样比一般以4列2行为基础**,他们表示的意思是:

**第一个数**：**表示在第一行的4个像素里采样几个Y,第二行以第一行的方式采样Y**

**第二个数：****表示在第一行的4个像素里采样几个Ｕ，Ｖ（Ｕ和Ｖ分别采样）**

**第三个数**：**表示在第二行的４个像素里采样几个Ｕ，Ｖ（Ｕ和Ｖ分别采样）**

#### YUV 4:4:4 采样，每一个Y对应一组UV分量

每个分量用8bit表示，两行8个像素就需要: (3 x 8 x 8) ,平均每个像素用24bit表示

![图片描述](https://img.mukewang.com/wiki/63f885c30926994110680680.jpg)

#### YUV 4:2:2 采样，每两个Y共用一组UV分量

每个分量用8bit表示，两行8个像素就需要: (4 + 2 + 2)x8x2,平均每个像素用16bit表示

![图片描述](https://img.mukewang.com/wiki/63f885e60918d90710900698.jpg)

#### YUV 4:2:0 采样，每四个Y共用一组UV分量

每个分量用8bit表示，两行8个像素就需要: (4 + 2 + 0)x8x2,平均每个像素用12bit表示

**YUV 4:2:0 采样，并不是指只采样 U 分量而不采样 V 分量**。**而是指，在每一行扫描时，只扫描一种色度分量（U 或者 V），和 Y 分量按照 2 : 1 的方式采样**。比如，第一行扫描时，YU 按照 2 : 1 的方式采样，那么第二行扫描时，YV 分量按照 2:1 的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和 Y 分量相比都是 2:1 。

# <font color="#fd6f01">2.实践篇</font>

# 一、原理图阅读



## 1.原理图

![图片描述](https://img.mukewang.com/wiki/63f889c909f44f9612800664.jpg)



## 2.屏接口定义

![图片描述](https://img.mukewang.com/wiki/63f889dc09af162407851280.jpg)



# 二、LCD RGB接口时序



## 1.RGB接口时序介绍

![图片描述](https://img.mukewang.com/wiki/63f889ee091c133611190837.jpg)

![图片描述](https://img.mukewang.com/wiki/63f889fa084fd75411070551.jpg)

我们看从上图可以看到在显示一幅图像的时候先是从左到右，扫描第一行的 480 个像素点，然后在从

上到下，扫描第二行，第三行，直至最后一行。

- **HSYNC 是水平同步信号，当产生此信号的时候表示开始显示新的一行。**
- **VSYNC 是垂直同步信号，当产生此信号的时候表示要显示一幅图像。**
- HBP 称作水平同步信号的后肩，表示从水平同步信号开始到一行的有效数据开始之前的CLK的个数
- HFP 称作水平同步信号的前肩，表示从一行的有效数据结束到下一个水平信号开始之间的CLK的个数
- VBP 称作垂直同步信号的后肩，表示一帧图像开始时，垂直同步信号以后的无效行数
- VFP 称作垂直同步信号的前肩， 表示一帧图像结束后，垂直同步信号以前的无效行数



## 2.实例

![图片描述](https://img.mukewang.com/wiki/63f88a13093f7f1812540594.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88a2409d8e95c12360627.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88a3209e4999e12290597.jpg)



# 三、IMX6ULL LCD控制器



## 1.介绍

The enhanced Liquid Crystal Display Interface (eLCDIF) is a general purpose display controller used to drive a wide range of display devices varying in size and capability.

> 增强型液晶显示接口（eLCDIF）是一种通用显示控制器，用于驱动各种尺寸和功能不同的显示设备。

The eLCDIF block supports the following:

• Displays with an asynchronous parallel MPU interface for command and data transfer to an integrated frame buffer. (具有异步并行MPU接口，用于将命令和数据搬迁到集成帧缓冲区)

• **Displays that support moving pictures and require the RGB interface mode (DOTCLK interface)**.(支持移动图片并需要RGB界面模式（DOTCLK界面）的显示器)

• VSYNC mode for high-speed data transfers. (用于高速数据传输的VSYNC模式)

• Digital video encoders that accept ITU-R BT.656 format 4:2:2 YCbCr digital component video and convert it to analog TV signals. (接受ITU-R BT.656格式4:2:2 YCbCr数字分量视频并将其转换为模拟电视信号的数字视频编码器)

• **Programmable timing and parameters for MPU, VSYNC, and DOTCLK LCD interfaces to support a wide variety of displays.** (MPU、VSYNC和DOTCLK LCD的可编程时序和参数接口以支持各种显示器)



## 2.DOTCLK Interface

The DOTCLK interface is another mode used in moving picture displays. It includes the VSYNC, HSYNC, DOTCLK and (optional) ENABLE signals. The interface is popularly called the RGB interface if the ENABLE signal is present.

> DOTCLK接口是动态图像显示中使用的另一种模式。它包括VSYNC、HSYNC、DOTCLK和（可选）ENABLE信号。如果存在ENABLE信号，该接口通常称为RGB接口。

![图片描述](https://img.mukewang.com/wiki/63f88a49091307bd12800996.jpg)

The DOTCLK mode writes data at high speed to the LCD, and the display operation is synchronized with the VSYNC, HSYNC, ENABLE and DOTCLK signals. The polarities, periods and pulse-widths of the sync signals are programmable using the LCDIF_VDCTRL0-4 registers. The units for the VSYNC signal must be number of horizontal lines and can be selected using the VSYNC_PULSE_WIDTH_UNIT and VSYNC_PERIOD_UNIT bit fields. The VERTICAL_WAIT_CNT is by default given the same unit as the VSYNC_PERIOD. The DISPLAY CLOCK (pix_clk) frequency is managed by the CCM.

> DOTCLK模式将数据高速写入LCD，显示操作与VSYNC、HSYNC、ENABLE和DOTCLK信号同步。同步信号的极性、周期和脉冲宽度可以使用LCDIF_VDCTRL0-4寄存器进行编程。VSYNC信号的单位必须是水平线数，可以使用VSYNC_PULSE_WIDTH_UNIT和VSYNC_PERIOD_UNIT位域进行选择。默认情况下，VERTICAL_WAIT_CNT与VSYNC_PERIOD相同。DISPLAY CLOCK（pix_clk）频率由CCM管理。

In DOTCLK mode, LCDIF_CTRL_BYPASS_COUNT bit must be set to 1. To end the current transfer, the software should make the DOTCLK_MODE bit 0, so that all data that is currently in the LCDIF LFIFO and TXFIFO is transmitted. Once that transfer is complete, the block will automatically clear the RUN bit and issue the cur_frame_done interrupt.

> 在DOTCLK模式下，LCDIF_CTRL_BYPASS_COUNT位必须设置为1。要结束当前传输，软件应使DOTCLK_MODE位为0，以便传输当前在LCDIF LFIFO和TXFIFO中的所有数据。一旦传输完成，块将自动清除RUN位并发出cur_frame_done中断。



## 3.时钟信号

![图片描述](https://img.mukewang.com/wiki/63f88a5e09487ce712220783.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88a6a0845bcbf05910130.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88a7509631cd112800332.jpg)

![图片描述](https://img.mukewang.com/wiki/63f88a82090cb1f212800381.jpg)

NUM和DENOM是用来设置时钟信号的小数部分，这里不使用小数部分，则公式可以简化如下：

```plain
PLL output frequency = Fref * (DIV_SELECT + NUM/DENOM)
                     = 24MHZ * DIV_SELECT
                     = 24MHZ * 28
                     = 672MHZ
代码块1234
```

PLL5 出来后还需要经过POST_DIV_SELECT 和 VIDEO_DIV两级分频，这里将这两个参数设置如下：

```plain
POST_DIV_SELECT     = 4
VIDEO_DIV           = 1

最终得到的频率如下：
PLL5—MAIN-CLOK      = 672MHZ/4/1=168MHZ
代码块12345
```

![图片描述](https://img.mukewang.com/wiki/63f88ad00943cf7812210198.jpg)

我们最终需要给屏提供的时钟信号频率为9MHZ，PLL5-MAIN-CLOCK需要经过两个选择器和两个分频器最终达到LCD控制器，这里两个分频器的参数设置如下：

```plain
LCDIF1_PRED = 6
LCDIF1_PODF = 3
LCD_CLK     = 168MHZ / 6 / 3 = 9MHZ
代码块123
```



### **(1) CCM_ANALOG_PLL_VIDEO*****n***

![图片描述](https://img.mukewang.com/wiki/63f88aec09558ad111951077.jpg)



### **(2) CCM_ANALOG_MISC2*****n***

![图片描述](https://img.mukewang.com/wiki/63f88b01093b582f12720310.jpg)



### (3) CCM_CSCDR2

![图片描述](https://img.mukewang.com/wiki/63f88b1009f21f6a12781280.jpg)



### (4) CCM_CBCMR

![图片描述](https://img.mukewang.com/wiki/63f88b2009dd1d0711170979.jpg)



## 4.重点寄存器介绍



### (1)**eLCDIF General Control Register (LCDIF_CTRL*****n*****)**

![图片描述](https://img.mukewang.com/wiki/63f88c8909f016aa13693030.jpg)



### (2)**eLCDIF General Control1 Register (LCDIF_CTRL1*****n*****)**

![图片描述](https://img.mukewang.com/wiki/63f88c9d093692a213652832.jpg)



### (3)**eLCDIF General Control2 Register (LCDIF_CTRL2*****n*****)**

![图片描述](https://img.mukewang.com/wiki/63f88b7409af7f5808861280.jpg)



### (4)**eLCDIF Horizontal and Vertical Valid Data Count Register (LCDIF_TRANSFER_COUNT)**

![图片描述](https://img.mukewang.com/wiki/63f88b850956c95612800309.jpg)



### (5)**eLCDIF VSYNC Mode and Dotclk Mode Control Register0 (LCDIF_VDCTRL0*****n*****)**

![图片描述](https://img.mukewang.com/wiki/63f88b9309b5732712801074.jpg)



### (6)**eLCDIF VSYNC Mode and Dotclk Mode Control Register1 (LCDIF_VDCTRL1)**

![图片描述](https://img.mukewang.com/wiki/63f88ba209651eb512800157.jpg)



### (7)e**LCDIF VSYNC Mode and Dotclk Mode Control Register2 (LCDIF_VDCTRL2)**

![图片描述](https://img.mukewang.com/wiki/63f88bb20999340412800223.jpg)



### (8)**eLCDIF VSYNC Mode and Dotclk Mode Control Register3 (LCDIF_VDCTRL3)**

![图片描述](https://img.mukewang.com/wiki/63f88bbf0987452612800486.jpg)



### (9)**eLCDIF VSYNC Mode and Dotclk Mode Control Register4 (LCDIF_VDCTRL4)**

![图片描述](https://img.mukewang.com/wiki/63f88bcd0993944f12800478.jpg)



### (10)**LCD Interface Current Buffer Address Register (LCDIF_CUR_BUF)**

This register indicates the address of the current frame being transmitted by eLCDIF. When the eLCDIF is behaving as a master, this address points to the address of the current frame of data being sent out via the LCDIF. When the current frame is done, the LCDIF block will assert the cur_frame_done interrupt for software to take action. The block will also copy the LCDIF_NEXT_BUF_ADDR into this bitfield so that the software can program the next frame address into the LCDIF_NEXT_BUF_ADDR bitfield. This address must always be double-word aligned.

> 该寄存器指示eLCDIF传输的当前帧的地址。当eLCDIF充当主控时，该地址指向通过LCDIF发送的当前数据帧的地址。当当前帧完成时，LCDIF块将断言cur_frame_done中断，以便软件采取行动。该块还将LCDIF_NEXT_BUF_ADDR复制到该位字段中，以便软件可以将下一帧地址编程到LCDIF_NEXT_BUF_ADDR位字段中。该地址必须始终是双字对齐的。

![图片描述](https://img.mukewang.com/wiki/63f88bdd0985e0af12800135.jpg)



### (11)**LCD Interface Next Buffer Address Register (LCDIF_NEXT_BUF)**

![图片描述](https://img.mukewang.com/wiki/63f88bea09d0ca9312800137.jpg)



# 四、实验代码



## 1.LCD 管脚初始化

```c
void lcd_gpio_init(void)
{
    volatile uint32_t *p;

    IOMUXC_SW_MUX_CTL_PAD_LCD_CLK &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC &= ~(0xf << 0);

    /*LCD_DATA0 ~ LCD_DATA23*/
    for(p = IOMUXC_SW_MUX_CTL_PAD_LCD_DATA0_ADDR;
        p <= IOMUXC_SW_MUX_CTL_PAD_LCD_DATA23_ADDR;
        p ++){
            *p &= ~(0xf << 0);
    }

    return;
}
代码块123456789101112131415161718
```



## 2.LCD 时钟初始化

```c
void lcd_clock_init(void)
{
    /*
     PLL output frequency = Fref * (DIV_SELECT + NUM/DENOM)
                     = 24MHZ * DIV_SELECT
                     = 24MHZ * 28
                     = 672MHZ

    DIV_SELECT = 28
    NUM        = 0
    DENOM      = 0

    ENABLE          [13   ]  Enalbe PLL output 
    DIV_SELECT      [6 - 0]  his field controls the PLL loop divider. 
                             Valid range for DIV_SELECT divider value: 27~54
    */
   CCM_ANALOG->PLL_VIDEO &= ~(0x7f << 0);
   CCM_ANALOG->PLL_VIDEO |= (28 << 0) | (1 << 13);
   CCM_ANALOG->PLL_VIDEO_NUM = 0;
   CCM_ANALOG->PLL_VIDEO_DENOM = 0;
   
   /*
    POST_DIV_SELECT     = 4
    VIDEO_DIV           = 1
    最终得到的频率如下：
    PLL5—MAIN-CLOK      = 672MHZ/4/1=168MHZ
    POST_DIV_SELECT [20–19]  00 — Divide by 4.
   */
    CCM_ANALOG->PLL_VIDEO &= ~(0x3 << 19);
    /*
    VIDEO_DIV [31–30]  00 divide by 1 (Default)
    */
    CCM_ANALOG->MISC2 &= ~(0x3 << 30);

    /*
     LCDIF1_PRE_CLK_SEL  [17–15]  010 derive clock from PLL5
     LCDIF1_CLK_SEL      [11-9 ]  000 derive clock from divided pre-muxed LCDIF1 clock
    */
    CCM->CSCDR2 &= ~(0x7 << 15);
    CCM->CSCDR2 |=  (0x2 << 15);
    CCM->CSCDR2 &= ~(0x7 << 9 );

    /*
    LCDIF1_PRED = 6
    LCDIF1_PODF = 3
    LCD_CLK     = 168MHZ / 6 / 3 = 9MHZ
    */

    /*
     LCDIF1_PRED [14–12] 101 divide by 6
    */
    CCM->CSCDR2 &= ~(0x7 << 12);
    CCM->CSCDR2 |=  (0x5 << 12);
    /*
     LCDIF1_PODF [25–23] 010 divide by 3
    */
    CCM->CBCMR &= ~(0x7 << 23);
    CCM->CBCMR |=  (0x2 << 23);

    return;
}
代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061
```



## 3.LCD 控制器初始化

```c
/*
support 16bit pix  RGB565
support 24bit pix  RGB888
*/
void lcd_ctrl_init(uint32_t pix_bits)
{
    /*
     Reset lcd block
     SFTRST [31]  When set to one, it forces a block level reset.
    */
    LCDIF->CTRL |= (1 << 31);
    gpt_delay_ms(500);
    LCDIF->CTRL = 0;

    /*
     BYPASS_COUNT [19] must be 1 in DOTCLK modes of operation.
     DOTCLK_MODE  [17] Set this bit to 1 to make the hardware go into the DOTCLK mode
     INPUT_DATA_SWIZZLE [15–14] 0x0 NO_SWAP — No byte swapping.(Little endian)
     CSC_DATA_SWIZZLE   [13–12] 0x0 NO_SWAP — No byte swapping.(Little endian)
     LCD_DATABUS_WIDTH  [11–10] 0x3 24_BIT — 24-bit data bus mode.
     WORD_LENGTH        [ 9–8 ] 0x0 16_BIT — Input data is 16 bits per pixel
                                0x3 24_BIT — Input data is 24 bits per pixel.

     DATA_FORMAT_16_BIT [3    ] When this bit is 0 and WORD_LENGTH = 0,
                                it implies that the 16-bit data is in RGB565 format.
                                When WORD_LENGTH is not 0, this bit does not care.
     MASTER             [5    ] Set this bit to make the eLCDIF act as a bus master.
     DATA_FORMAT_24_BIT [1    ] 0x0 ALL_24_BITS_VALID — Data input to the block is 
                                in 24 bpp format, such that all RGB 888 data is
                                contained in 24 bits.  
    */
    LCDIF->CTRL |= (1 << 19) | (1 << 17) | (0x3 << 10) | (1 << 5);
    if(pix_bits == 24){
        LCDIF->CTRL |= (0x3 << 8);
    }

    /*
     BYTE_PACKING_FORMAT [19–16]
     In the 16-bit mode, a 16-bit half-word is valid only if adjacent bits [1:0] 
     or [3:2] or both are 1.
     For example, set the bit field value to 0x7 if the display data is arranged 
     in the 24-bit unpacked format (A-R-G-B where A value does not have be transmitted).
    */
    LCDIF->CTRL1 &= ~(0xf << 16);
    if(pix_bits == 24){
        LCDIF->CTRL1 |= (0x7 << 16);
    }else if(pix_bits == 16){
        LCDIF->CTRL1 |= (0xf << 16);
    }

    /*
      ODD_LINE_PATTERN  [18–16] 0x5 BGR —
      EVEN_LINE_PATTERN [14–12] 0x5 BGR —
    */
    LCDIF->CTRL2 &= ~(0x7 << 16);
    LCDIF->CTRL2 |=  (0x5 << 16);
    LCDIF->CTRL2 &= ~(0x7 << 12);
    LCDIF->CTRL2 |=  (0x5 << 12);
  
    return;
}
代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061
```



## 5.LCD 屏时序参数设置



### (1).参数结构体

```c
typedef struct
{
    uint16_t panelWidth;  /*!< Display panel width, pixels per line. */
    uint16_t panelHeight; /*!< Display panel height, how many lines per panel. */
    uint8_t hsw;          /*!< HSYNC pulse width. */
    uint8_t hfp;          /*!< Horizontal front porch. */
    uint8_t hbp;          /*!< Horizontal back porch. */
    uint8_t vsw;          /*!< VSYNC pulse width. */
    uint8_t vfp;          /*!< Vrtical front porch. */
    uint8_t vbp;          /*!< Vertical back porch. */
    uint8_t vsync_pol;    /*Default 0 active low during VSYNC_PULSE_WIDTH time*/
    uint8_t hsync_pol;    /*Default 0 active low during HSYNC_PULSE_WIDTH time*/
    uint8_t dotclk_pol;   /*Default is data launched at negative edge of DOTCLK and 
                           captured at positive edge.*/
    uint8_t enable_pol;   /*Default 0 active low during valid data transfer on each 
                           horizontal line.*/
} elcdif_rgb_parm_t;
代码块1234567891011121314151617
```



### (2).时序参数设置代码

```c
void lcd_timing_init(const elcdif_rgb_parm_t *parm)
{
    /*
    VSYNC_OEB      [29] Should be set to 0 in the DOTCLK mode.
    ENABLE_PRESENT [28] Setting this bit to 1 will make the hardware generate the 
                        ENABLE signal in the DOTCLK mode,
    VSYNC_POL      [27] Default 0 active low during VSYNC_PULSE_WIDTH time
    HSYNC_POL      [26] Default 0 active low during HSYNC_PULSE_WIDTH time
    DOTCLK_POL     [25] Default is data launched at negative edge of DOTCLK 
                        and captured at positive edge
    ENABLE_POL     [24] Default 0 active low during valid data transfer on 
                        each horizontal line.
    VSYNC_PERIOD_UNIT      [21] Set it to 1 to count in terms of complete 
                                horizontal lines.
    VSYNC_PULSE_WIDTH_UNIT [20] Set it to 1 to count in terms of complete 
                                horizontal lines. 

    VSYNC_PULSE_WIDTH      [17:0] Number of units for which VSYNC signal is active.
    */
    LCDIF->VDCTRL0 = (0 << 29) | (1 << 28) | (1 << 21) | (1 << 20);
    LCDIF->VDCTRL0 |= (parm->vsync_pol << 27)  | (parm->hsync_pol << 26) |
                      (parm->dotclk_pol << 25) | (parm->enable_pol << 24)|
                      (parm->vsw << 0);

    /*
    Total number of units between two positive or two negative edges of the VSYNC signal.
    */
    LCDIF->VDCTRL1 = parm->vsw + parm->vbp + parm->panelHeight + parm->vfp;
    /*
     HSYNC_PULSE_WIDTH [31–18] Number of DISPLAY CLOCK (pix_clk) cycles for 
                               which HSYNC signal is active

     HSYNC_PERIOD      [17-0] Total number of DISPLAY CLOCK (pix_clk) cycles 
                              between two positive or two negative edges of the 
                              HSYNC signal.
    */
    LCDIF->VDCTRL2 = (parm->hsw << 18) |
                (parm->hsw + parm->hbp + parm->panelWidth + parm->hfp);

    /*
     HORIZONTAL_WAIT_CNT [27–16]  wait for this number of clocks
                                  before the moving picture information begins.

     VERTICAL_WAIT_CNT    [15-0] it accounts for the vertical back porch lines
                                 plus the number of horizontal lines before the moving 
                                 picture begins. The unit for this parameter is 
                                 inherently the same as the VSYNC_PERIOD_UNIT.
    */
    LCDIF->VDCTRL3 = ((parm->hsw + parm->hbp) << 16) | ((parm->vsw + parm->vbp) << 0);

    /*
    SYNC_SIGNALS_ON [18] Set this field to 1 if the LCD controller requires that 
                         the VSYNC or VSYNC/HSYNC/DOTCLK control signals should
                         be active
    DOTCLK_H_VALID_DATA_CNT [17-0] Total number of DISPLAY CLOCK (pix_clk)
    cycles on each horizontal line that carry valid data in DOTCLK mode.
    */
    LCDIF->VDCTRL4 = (1 << 18) | (parm->panelWidth << 0);

    /*
    V_COUNT [31-16] Number of horizontal lines per frame which contain valid data.
    H_COUNT [15-0 ] Total valid data (pixels) in each horizontal line.
    */
    LCDIF->TRANSFER_COUNT = (parm->panelHeight << 16) | (parm->panelWidth << 0);

    return;
}
代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667
```



## 6.LCD 帧缓存地址设置

```c
void lcd_framebuffer_addr_init(uint32_t framebuffer_addr)
{
    LCDIF->CUR_BUF  = framebuffer_addr;
    LCDIF->NEXT_BUF = framebuffer_addr; 
}
代码块12345
```



## 7.LCD 控制器使能

```c
void lcd_enable(void)
{
    /*
    When this bit is set by software, the eLCDIF will begin transferring data 
    between the SoC and the display.This bit must remain set until the operation
    is complete.
    */
   LCDIF->CTRL |= (1 << 0);
}
代码块123456789
```



## 8.LCD 屏清屏

![图片描述](https://img.mukewang.com/wiki/63f88c0108b271f605760334.jpg)

```c
#define LCD_WIDTH  480
#define LCD_HEIGHT 272

uint32_t framebuffer_32[LCD_HEIGHT][LCD_WIDTH];

void lcd_clear_screen(void)
{
    int i,j;
    int index;
    uint32_t pix[] = {0xff0000,0x00ff00,0x0000ff};

    for(i = 0;i < LCD_HEIGHT;i ++){
        for(j = 0,index = 0;j < LCD_WIDTH;j ++){
            if(j == 160 || j == 320){
                index ++;
            }
            
            framebuffer_32[i][j] = pix[index];
        }
    }

    return;
}
代码块1234567891011121314151617181920212223
```



## 9.LCD RGB 接口测试



### 1.清屏功能

```c
#define RGB888_PIX_BITS 24

void lcd_rgb888_init(void)
{
    elcdif_rgb_parm_t lcd_parm = {
        .panelWidth  = LCD_WIDTH,
        .panelHeight = LCD_HEIGHT,
        .hsw         = 41,
        .hfp         = 2,
        .hbp         = 2,
        .vsw         = 10,
        .vfp         = 2,
        .vbp         = 2,
        .vsync_pol   = 0,
        .hsync_pol   = 0,
        .dotclk_pol  = 1,
        .enable_pol  = 1,
    };

    lcd_gpio_init();
    lcd_clock_init();
    lcd_ctrl_init(RGB888_PIX_BITS);
    lcd_timing_init(&lcd_parm);
    lcd_framebuffer_addr_init((uint32_t)framebuffer_32);
    lcd_clear_screen();
    lcd_enable();

    return;
}

void lcd_test(void)
{    
    lcd_rgb888_init();

    while(1){
       lcd_clear_screen();
    }

    return;
}
代码块12345678910111213141516171819202122232425262728293031323334353637383940
```



### 2.RGB888图片显示

```c
#include "picture.h"

#define RGB888_PIX_BITS 24

void lcd_rgb888_init(void)
{
    elcdif_rgb_parm_t lcd_parm = {
        .panelWidth  = LCD_WIDTH,
        .panelHeight = LCD_HEIGHT,
        .hsw         = 41,
        .hfp         = 2,
        .hbp         = 2,
        .vsw         = 10,
        .vfp         = 2,
        .vbp         = 2,
        .vsync_pol   = 0,
        .hsync_pol   = 0,
        .dotclk_pol  = 1,
        .enable_pol  = 1,
    };

    lcd_gpio_init();
    lcd_clock_init();
    lcd_ctrl_init(RGB888_PIX_BITS);
    lcd_timing_init(&lcd_parm);
    lcd_framebuffer_addr_init((uint32_t)framebuffer_32);
    lcd_clear_screen();
    lcd_enable();

    return;
}

void lcd_rgb888_picture_display(void)
{
    int i,j;
    uint32_t pix;
    uint8_t *p = (uint8_t *)gImage_picture;

    for(i = 0;i < LCD_HEIGHT;i ++){
        for(j = 0;j < LCD_WIDTH;j ++){
            pix = (p[0] << 16) | (p[1] << 8) | (p[2] << 0);
            framebuffer_32[i][j] = pix;
            p += 3;
        }
    }

    return;
}

void lcd_rgb888_test(void)
{    
    lcd_rgb888_init();

    while(1){
        lcd_rgb888_picture_display();
       //lcd_clear_screen();
    }

    return;
}
代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960
```



### 3.RGB565图片显示

```c
#include "picture.h"

#define RGB565_PIX_BITS 16

uint16_t framebuffer_16[LCD_HEIGHT][LCD_WIDTH];

void lcd_rgb565_init(void)
{
    elcdif_rgb_parm_t lcd_parm = {
        .panelWidth  = LCD_WIDTH,
        .panelHeight = LCD_HEIGHT,
        .hsw         = 41,
        .hfp         = 2,
        .hbp         = 2,
        .vsw         = 10,
        .vfp         = 2,
        .vbp         = 2,
        .vsync_pol   = 0,
        .hsync_pol   = 0,
        .dotclk_pol  = 1,
        .enable_pol  = 1,
    };

    lcd_gpio_init();
    lcd_clock_init();
    lcd_ctrl_init(RGB565_PIX_BITS);
    lcd_timing_init(&lcd_parm);
    lcd_framebuffer_addr_init((uint32_t)framebuffer_16);
    lcd_enable();

    return;
}

void lcd_rgb565_picture_display(void)
{
    int i,j;
    uint16_t pix;
    uint8_t *p = (uint8_t *)gImage_picture;

    for(i = 0;i < LCD_HEIGHT;i ++){
        for(j = 0;j < LCD_WIDTH;j ++){
            pix = (p[0] << 8) | (p[1] << 0);
            framebuffer_16[i][j] = pix;
            p += 2;
        }
    }

    return;
}


void lcd_rgb565_test(void)
{    
    lcd_rgb565_init();

    while(1){
        lcd_rgb565_picture_display();
    }

    return;
}
代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061
```



## 10.完整代码

```c
#include "imx6ull.h"

void lcd_gpio_init(void)
{
    volatile uint32_t *p;

    IOMUXC_SW_MUX_CTL_PAD_LCD_CLK &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC &= ~(0xf << 0);

    /*LCD_DATA0 ~ LCD_DATA23*/
    for(p = IOMUXC_SW_MUX_CTL_PAD_LCD_DATA0_ADDR;
        p <= IOMUXC_SW_MUX_CTL_PAD_LCD_DATA23_ADDR;
        p ++){
            *p &= ~(0xf << 0);
    }

    return;
}

void lcd_clock_init(void)
{
    /*
     PLL output frequency = Fref * (DIV_SELECT + NUM/DENOM)
                     = 24MHZ * DIV_SELECT
                     = 24MHZ * 28
                     = 672MHZ

    DIV_SELECT = 28
    NUM        = 0
    DENOM      = 0

    ENABLE          [13   ]  Enalbe PLL output 
    DIV_SELECT      [6 - 0]  his field controls the PLL loop divider. 
                             Valid range for DIV_SELECT divider value: 27~54
    */
   CCM_ANALOG->PLL_VIDEO &= ~(0x7f << 0);
   CCM_ANALOG->PLL_VIDEO |= (28 << 0) | (1 << 13);
   CCM_ANALOG->PLL_VIDEO_NUM = 0;
   CCM_ANALOG->PLL_VIDEO_DENOM = 0;
   
   /*
    POST_DIV_SELECT     = 4
    VIDEO_DIV           = 1
    最终得到的频率如下：
    PLL5—MAIN-CLOK      = 672MHZ/4/1=168MHZ
    POST_DIV_SELECT [20–19]  00 — Divide by 4.
   */
    CCM_ANALOG->PLL_VIDEO &= ~(0x3 << 19);
    /*
    VIDEO_DIV [31–30]  00 divide by 1 (Default)
    */
    CCM_ANALOG->MISC2 &= ~(0x3 << 30);

    /*
     LCDIF1_PRE_CLK_SEL  [17–15]  010 derive clock from PLL5
     LCDIF1_CLK_SEL      [11-9 ]  000 derive clock from divided pre-muxed LCDIF1 clock
    */
    CCM->CSCDR2 &= ~(0x7 << 15);
    CCM->CSCDR2 |=  (0x2 << 15);
    CCM->CSCDR2 &= ~(0x7 << 9 );

    /*
    LCDIF1_PRED = 6
    LCDIF1_PODF = 3
    LCD_CLK     = 168MHZ / 6 / 3 = 9MHZ
    */

    /*
     LCDIF1_PRED [14–12] 101 divide by 6
    */
    CCM->CSCDR2 &= ~(0x7 << 12);
    CCM->CSCDR2 |=  (0x5 << 12);
    /*
     LCDIF1_PODF [25–23] 010 divide by 3
    */
    CCM->CBCMR &= ~(0x7 << 23);
    CCM->CBCMR |=  (0x2 << 23);

    return;
}

/*
support 16bit pix  RGB565
support 24bit pix  RGB888
*/
void lcd_ctrl_init(uint32_t pix_bits)
{
    /*
     Reset lcd block
     SFTRST [31]  When set to one, it forces a block level reset.
    */
    LCDIF->CTRL |= (1 << 31);
    gpt_delay_ms(500);
    LCDIF->CTRL = 0;

    /*
     BYPASS_COUNT [19] must be 1 in DOTCLK modes of operation.
     DOTCLK_MODE  [17] Set this bit to 1 to make the hardware go into the DOTCLK mode
     INPUT_DATA_SWIZZLE [15–14] 0x0 NO_SWAP — No byte swapping.(Little endian)
     CSC_DATA_SWIZZLE   [13–12] 0x0 NO_SWAP — No byte swapping.(Little endian)
     LCD_DATABUS_WIDTH  [11–10] 0x3 24_BIT — 24-bit data bus mode.
     WORD_LENGTH        [ 9–8 ] 0x0 16_BIT — Input data is 16 bits per pixel
                                0x3 24_BIT — Input data is 24 bits per pixel.

     DATA_FORMAT_16_BIT [3    ] When this bit is 0 and WORD_LENGTH = 0,
                                it implies that the 16-bit data is in RGB565 format.
                                When WORD_LENGTH is not 0, this bit does not care.
     MASTER             [5    ] Set this bit to make the eLCDIF act as a bus master.
     DATA_FORMAT_24_BIT [1    ] 0x0 ALL_24_BITS_VALID — Data input to the block is 
                                in 24 bpp format, such that all RGB 888 data is
                                contained in 24 bits.  
    */
    LCDIF->CTRL |= (1 << 19) | (1 << 17) | (0x3 << 10) | (1 << 5);
    if(pix_bits == 24){
        LCDIF->CTRL |= (0x3 << 8);
    }

    /*
     BYTE_PACKING_FORMAT [19–16]
     In the 16-bit mode, a 16-bit half-word is valid only if adjacent bits [1:0] 
     or [3:2] or both are 1.
     For example, set the bit field value to 0x7 if the display data is arranged 
     in the 24-bit unpacked format (A-R-G-B where A value does not have be transmitted).
    */
    LCDIF->CTRL1 &= ~(0xf << 16);
    if(pix_bits == 24){
        LCDIF->CTRL1 |= (0x7 << 16);
    }else if(pix_bits == 16){
        LCDIF->CTRL1 |= (0xf << 16);
    }

    /*
      ODD_LINE_PATTERN  [18–16] 0x5 BGR —
      EVEN_LINE_PATTERN [14–12] 0x5 BGR —
    */
    LCDIF->CTRL2 &= ~(0x7 << 16);
    LCDIF->CTRL2 |=  (0x5 << 16);
    LCDIF->CTRL2 &= ~(0x7 << 12);
    LCDIF->CTRL2 |=  (0x5 << 12);
  
    return;
}

typedef struct
{
    uint16_t panelWidth;  /*!< Display panel width, pixels per line. */
    uint16_t panelHeight; /*!< Display panel height, how many lines per panel. */
    uint8_t hsw;          /*!< HSYNC pulse width. */
    uint8_t hfp;          /*!< Horizontal front porch. */
    uint8_t hbp;          /*!< Horizontal back porch. */
    uint8_t vsw;          /*!< VSYNC pulse width. */
    uint8_t vfp;          /*!< Vrtical front porch. */
    uint8_t vbp;          /*!< Vertical back porch. */
    uint8_t vsync_pol;    /*Default 0 active low during VSYNC_PULSE_WIDTH time*/
    uint8_t hsync_pol;    /*Default 0 active low during HSYNC_PULSE_WIDTH time*/
    uint8_t dotclk_pol;   /*Default is data launched at negative edge of DOTCLK and 
                           captured at positive edge.*/
    uint8_t enable_pol;   /*Default 0 active low during valid data transfer on each 
                           horizontal line.*/
} elcdif_rgb_parm_t;

void lcd_timing_init(const elcdif_rgb_parm_t *parm)
{
    /*
    VSYNC_OEB      [29] Should be set to 0 in the DOTCLK mode.
    ENABLE_PRESENT [28] Setting this bit to 1 will make the hardware generate the 
                        ENABLE signal in the DOTCLK mode,
    VSYNC_POL      [27] Default 0 active low during VSYNC_PULSE_WIDTH time
    HSYNC_POL      [26] Default 0 active low during HSYNC_PULSE_WIDTH time
    DOTCLK_POL     [25] Default is data launched at negative edge of DOTCLK 
                        and captured at positive edge
    ENABLE_POL     [24] Default 0 active low during valid data transfer on 
                        each horizontal line.
    VSYNC_PERIOD_UNIT      [21] Set it to 1 to count in terms of complete 
                                horizontal lines.
    VSYNC_PULSE_WIDTH_UNIT [20] Set it to 1 to count in terms of complete 
                                horizontal lines. 

    VSYNC_PULSE_WIDTH      [17:0] Number of units for which VSYNC signal is active.
    */
    LCDIF->VDCTRL0 = (0 << 29) | (1 << 28) | (1 << 21) | (1 << 20);
    LCDIF->VDCTRL0 |= (parm->vsync_pol << 27)  | (parm->hsync_pol << 26) |
                      (parm->dotclk_pol << 25) | (parm->enable_pol << 24)|
                      (parm->vsw << 0);

    /*
    Total number of units between two positive or two negative edges of the VSYNC signal.
    */
    LCDIF->VDCTRL1 = parm->vsw + parm->vbp + parm->panelHeight + parm->vfp;
    /*
     HSYNC_PULSE_WIDTH [31–18] Number of DISPLAY CLOCK (pix_clk) cycles for 
                               which HSYNC signal is active

     HSYNC_PERIOD      [17-0] Total number of DISPLAY CLOCK (pix_clk) cycles 
                              between two positive or two negative edges of the 
                              HSYNC signal.
    */
    LCDIF->VDCTRL2 = (parm->hsw << 18) |
                (parm->hsw + parm->hbp + parm->panelWidth + parm->hfp);

    /*
     HORIZONTAL_WAIT_CNT [27–16]  wait for this number of clocks
                                  before the moving picture information begins.

     VERTICAL_WAIT_CNT    [15-0] it accounts for the vertical back porch lines
                                 plus the number of horizontal lines before the moving 
                                 picture begins. The unit for this parameter is 
                                 inherently the same as the VSYNC_PERIOD_UNIT.
    */
    LCDIF->VDCTRL3 = ((parm->hsw + parm->hbp) << 16) | ((parm->vsw + parm->vbp) << 0);

    /*
    SYNC_SIGNALS_ON [18] Set this field to 1 if the LCD controller requires that 
                         the VSYNC or VSYNC/HSYNC/DOTCLK control signals should
                         be active
    DOTCLK_H_VALID_DATA_CNT [17-0] Total number of DISPLAY CLOCK (pix_clk)
    cycles on each horizontal line that carry valid data in DOTCLK mode.
    */
    LCDIF->VDCTRL4 = (1 << 18) | (parm->panelWidth << 0);

    /*
    V_COUNT [31-16] Number of horizontal lines per frame which contain valid data.
    H_COUNT [15-0 ] Total valid data (pixels) in each horizontal line.
    */
    LCDIF->TRANSFER_COUNT = (parm->panelHeight << 16) | (parm->panelWidth << 0);

    return;
}

void lcd_framebuffer_addr_init(uint32_t framebuffer_addr)
{
    LCDIF->CUR_BUF  = framebuffer_addr;
    LCDIF->NEXT_BUF = framebuffer_addr; 
}

void lcd_enable(void)
{
    /*
    When this bit is set by software, the eLCDIF will begin transferring data 
    between the SoC and the display.This bit must remain set until the operation
    is complete.
    */
   LCDIF->CTRL |= (1 << 0);
}

#define LCD_WIDTH  480
#define LCD_HEIGHT 272

uint32_t framebuffer_32[LCD_HEIGHT][LCD_WIDTH];
uint16_t framebuffer_16[LCD_HEIGHT][LCD_WIDTH];

void lcd_clear_screen(void)
{
    int i,j;
    int index;
    uint32_t pix[] = {0xff0000,0x00ff00,0x0000ff};

    for(i = 0;i < LCD_HEIGHT;i ++){
        for(j = 0,index = 0;j < LCD_WIDTH;j ++){
            if(j == 160 || j == 320){
                index ++;
            }

            framebuffer_32[i][j] = pix[index];
        }
    }

    return;
}

#define RGB888_PIX_BITS 24

void lcd_rgb888_init(void)
{
    elcdif_rgb_parm_t lcd_parm = {
        .panelWidth  = LCD_WIDTH,
        .panelHeight = LCD_HEIGHT,
        .hsw         = 41,
        .hfp         = 2,
        .hbp         = 2,
        .vsw         = 10,
        .vfp         = 2,
        .vbp         = 2,
        .vsync_pol   = 0,
        .hsync_pol   = 0,
        .dotclk_pol  = 1,
        .enable_pol  = 1,
    };

    lcd_gpio_init();
    lcd_clock_init();
    lcd_ctrl_init(RGB888_PIX_BITS);
    lcd_timing_init(&lcd_parm);
    lcd_framebuffer_addr_init((uint32_t)framebuffer_32);
    lcd_clear_screen();
    lcd_enable();

    return;
}

#define RGB565_PIX_BITS 16

void lcd_rgb565_init(void)
{
    elcdif_rgb_parm_t lcd_parm = {
        .panelWidth  = LCD_WIDTH,
        .panelHeight = LCD_HEIGHT,
        .hsw         = 41,
        .hfp         = 2,
        .hbp         = 2,
        .vsw         = 10,
        .vfp         = 2,
        .vbp         = 2,
        .vsync_pol   = 0,
        .hsync_pol   = 0,
        .dotclk_pol  = 1,
        .enable_pol  = 1,
    };

    lcd_gpio_init();
    lcd_clock_init();
    lcd_ctrl_init(RGB565_PIX_BITS);
    lcd_timing_init(&lcd_parm);
    lcd_framebuffer_addr_init((uint32_t)framebuffer_16);
    lcd_enable();

    return;
}

#include "picture.h"

void lcd_rgb888_picture_display(void)
{
    int i,j;
    uint32_t pix;
    uint8_t *p = (uint8_t *)gImage_picture;

    for(i = 0;i < LCD_HEIGHT;i ++){
        for(j = 0;j < LCD_WIDTH;j ++){
            pix = (p[0] << 16) | (p[1] << 8) | (p[2] << 0);
            framebuffer_32[i][j] = pix;
            p += 3;
        }
    }

    return;
}

void lcd_rgb565_picture_display(void)
{
    int i,j;
    uint16_t pix;
    uint8_t *p = (uint8_t *)gImage_picture;

    for(i = 0;i < LCD_HEIGHT;i ++){
        for(j = 0;j < LCD_WIDTH;j ++){
            pix = (p[0] << 8) | (p[1] << 0);
            framebuffer_16[i][j] = pix;
            p += 2;
        }
    }

    return;
}

void lcd_rgb888_test(void)
{    
    lcd_rgb888_init();

    while(1){
        lcd_rgb888_picture_display();
       //lcd_clear_screen();
    }

    return;
}

void lcd_rgb565_test(void)
{    
    lcd_rgb565_init();

    while(1){
        lcd_rgb565_picture_display();
    }

    return;
}

```

