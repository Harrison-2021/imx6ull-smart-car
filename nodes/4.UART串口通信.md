# 1.串口通信理论
## 1.1 串行与并行通信
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1544f55b99014313a95013efe3f20f80.png)
## 1.2 串口介绍
- **串口**全称叫做串行接口，通常也叫做 **COM 接口**，
- **串行接口**指的是**数据一个一个的顺序传输**，通信线路简单。
- 	使用**两条线即可实现双向通信**，一条用于发送，一条用于接收。

> 我们经常说的串口指的是**RS-232C接口**，它是在1970年由美国电子工业协会（EIA）联合贝尔系统、调制解调器厂家及计算机终端生产厂家共同制定的用于**串行通讯的标准**。它的全名是“数据终端设备（DTE）和数据通讯设备（DCE）之间串**行二进制数据交换接口技术标准**”。传统的**RS-232-C接口标准有22根线**，采用标准25芯D型插头座（DB25），后来使用**简化为9芯D型插座（DB9）**，现在应用中25芯插头座已很少采用。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0aaf4fa778fe424eb7133b1049ea591f.png)
## 1.3 串口通信电平标准
- 所谓的电平标准，指的是在通信的过程中**如何表示0和1的问题**。
> 即在通信过程中用什么样的电压表示1，用什么样的电压表示0。由于行业需求不同，在发展的过程中出现了很多串口通信电平标准。
### 1.3.1 TTL标准
- TTL是`Transistor-Transistor Logic`，即**晶体管-晶体管逻辑的简称**，**全双工**工作模式，
- 它是计算机处理器控制的**设备内部各部分之间通信的标准技术**。
- TTL电平信号应用广泛,**+5V等价于逻辑"1"，0V等价于逻辑"0**。

数字电路中，由TTL电子元器件组成电路的**电平是个电压范围**，规定：

- **输出高电平>=2.4V，输出低电平<=0.4V**；

- **输入高电平>=2.0V，输入低电平<=0.8V**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/633732113c9248e594f6c70704b99873.png)
### 1.3.2 RS232标准
- RS232电平定义：它采用**负逻辑**，==-15V-3V代表逻辑"1"，+3V+15V代表逻辑"0"==，
- **全双工**工作模式
> RS-232是美国电子工业协会EIA（Electronic Industry Association）制定的一种串行物理接口标准。RS是英文“推荐标准(Recommend standard)”的缩写，232为标识号。RS-232是对电气特性以及物理特性的规定，只**作用于数据的传输通路上，它并不内含对数据的处理方式**。
- **设备先使用TTL标准，再转为RS232标准通信**
	- [RS232与TTL电平有什么不同，如何转换？](https://zhuanlan.zhihu.com/p/78645036?utm_id=0)
>-  很多**单片机的串口则是TTL电平，电源电压 一般 +5V**，因此，要互连的话，必须做电平转换
>- TTL-RS232转换器：用于将TTL电平（通常为0V和5V）转换为RS232电平（通常为-12V和12V），通常用于将单片机与其他设备（如计算机、PLC等）进行通讯

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/36c6d01690a44f8b9bcceadaac432d76.png)
### 1.3.3 RS485
- RS485是一种串口接口标准，**为了长距离传输采用差分方式传输**，
	- 传输的是差分信号，即通过**AB两根线的电压差作为电平信号**。
	- 差分信号能**有效地抵御外界因素的干扰**，因为干扰对两根线影响是一样的，两根线的电压差不变，信号传递也就不会受干扰。

- RS485电平定义：
	-  **逻辑1：AB两根线压差:+2V ~ +6V**， **逻辑0：AB两根线压差-6V ~ -2V**，
	- **半双工**工作模式

> RS-485是美国电子工业协会（EIA）在1983年批准了一个新的平衡传输标准（balanced transmission standard），EIA一开始将RS（Recommended Standard）做为标准的前缀，不过后来为了便于识别标准的来源，已将RS改为EIA/TIA。目前标准名称为TIA-485，但工程师及应用指南仍继续使用RS-485来称呼此标准。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c7b37e42353e4887b2a19d31bf745b30.png) 
- RS485与TTL、RS232只能一对一连接不同，==**RS-485可以一对多，在总线上是允许连接多达128个收发器。**==

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fa79b4fabe2a4f279204cd462facc3bc.png)
### 1.3.4 RS422标准
- RS-422和RS-485电路原理基本相同，都是以**差分方式发送和接收**，**不需要数字地线**。
- **差分模式使得同速率条件传输距离更远**，这正是二者与RS232的根本区别。

- RS-422通过**两对双绞线可以全双工工作**收发互不影响，RS485采用一对双绞线故只能半双工工作，发收不能同时进行，RS-422不允许出现多个发送端而只能有多个接受端。
- 因为有两对双绞线实现全双工，**故有四条信号线T/R+，T/R-，以及一条GND线**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/eddf67b99cca4fd493e7d1d5a6bb0ce4.png)
### 1.3.5 几种电平标准对比
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b2f027c136f4460e8457901ef475fed5.png)
## 1.4 串口通信协议
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4ec5204cf955496283bb03ac7db0686e.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/dc244b1103ee44958e9073eed659d043.png)
### 1.4.1 波特率
- 串口通信常用的是**异步通讯**，
- **异步通讯中由于没有时钟信号,所以两个通讯设备之间需要约定好波特率**,例如:115200

### 1.4.2 通讯的起始和停止信号
- 串口通讯的**一个数据包**从起始信号开始，直到停止信号结束。
- 数据包的**起始信号由一个逻辑0的数据位**表示，而数据包的停止信号可由0.5、1、1.5或2个逻辑1的数据位表示，只要双方约定一致即可。
### 1.4.2 有效数据
- 在数据包的起始位之后紧接着的就是**要传输的主体数据内容**，也称为有效数据，有效数据的长度常被约定为==5、6、7或8位长==。
### 1.4.2 数据校验
- 在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。
- 校验方法有奇校验(odd)、偶校验(even)、0校验、无校验
	- 奇校验要求**有效数据和校验位中“1"的个数为奇数**，比如一个8位长的有效数据为：01101001，此时总共有4个"1”，为达到奇校验效果，校验位为"1"，最后传输的数据将是8位的有效数据加上1位的校验位总共9位。
	- 偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1"的个数为偶数，比如数据帧：11001010，此时数据帧"1"的个数为4个，所以偶校验位为"0”。
	- 0校验是不管有效数据中的内容是什么，校验位总为"0"，1校验是校验位总为"1"。
	- 在无校验的情况下，数据包中不包含校验位。
## 1.5 UART
- `UART(Universal Asynchronous Receiver and Transmitter)`**通用异步收发器**。
- UART我们可以认为它是**集成在SOC内部的一个控制器**，它可以**按照串口通信协议格式收发数据。**
- 由**两部分组成**:
  - 一个将来`自微处理器的并行数据`转换为串行形式发送的**发送器(Tx)**。
  - 一个将串行比特流转换成`微处理器可以使用的并行`数据**接收器(Rx)**


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/50b28e79f78a481db0613cced9ca3573.png)

**问题:同步与异步有什么区别？**

- 同步方式指的是，在数据传输的过程中，**需要一根时钟线同步**。例如IIC,SPI总线，通过他们进行数据传输的时候，必须有一根时钟线，用来同步。

- 异步方式指的是，数据传输的过程中，不需要时钟线，直接发送数据就可以了。例如我们常说的串口采用的就是异步方式,<font color=green>**发送方和接收方之间是没有时钟信号线的，他们各自使用自己的时钟,因此需要约定波特率**</font>
> 在STM32芯片中除了有 UART 外 ，还有 个 叫 做 USART 。 USART 的全称是 Universal Synchronous/Asynchronous Receiver/Transmitter，也就是同步/异步串行收发器。相比 UART 多了 一个同步的功能，在硬件上体现出来的就是多了一条时钟线。

# 2. I.MX6ull UART
## 2.1 特点
### 整体特点
- ==**通用异步收发设备**==
	- 通过**电平转换器**和**RS-232电缆**提供**与外部设备的串行通信能力**，
	- 或通过使用外部电路将红外信号转换为电信号（用于接收）或将电信号转换为驱动红外LED（用于传输）的信号，以提供低速IrDA兼容性。

- UART支持NRZ编码格式、==RS485兼容的9位数据格式==和IrDA兼容的红外慢速数据速率（SIR）格式。
	- RS485兼容的9位数据格式,校验位，**为0，表示数据，为1，表地址**，因RS485可以连接多个接收器，**地址用以区分不同的接收器**
> NRZ编码（Non-return-to-zero Code），也叫不归零编码。信号电平的一次反转代表1，电平不变化表示0，并且在表示完一个码元后，电压不需回到0
> 参考链接:https://blog.csdn.net/yxfabcdefg/article/details/53506694

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3940db6f77534a789841dfa124cd5494.png)
### 总结
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/913e7a44369241919a1c62fbe7a7ecab.png)
- 高速TIA/EIA-232-F兼容，高达5.0Mbit/s
- 串行红外接口低速，IrDA兼容（高达115.2 Kbit/s）
- **9位或多点模式（RS-485）支持（自动从属地址检测）**
- **7或8位RS-232字符数据，或9位RS-485格式**
- 1或2个停止位
- 可编程奇偶校验（偶数、奇数和无奇偶校验）
- 硬件流控制支持请求发送（RTS_B）和清除发送
- 通过CTS_B信号控制RS-485驱动器方向
- 自动波特率检测（高达115.2 Kbit/s）
## 2.2 重点寄存器
### (1)数据接收寄存器
- 这个寄存器其他位不需要关心，**只关心[7:0]就可以了，用来从UART接收的数据**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f344692e6450493bb655720931572b7b.png)
### (2)数据发送寄存器
- 这个寄存器其他位不需要关心，**只关心[7:0]就可以了，用来向UART发送数据。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4623ec7951c4453d9e31c07b696e32de.png)
### (3)UART控制寄存器1
- 这个寄存器我们只需要**关注第[0]位**，用来控制UART是否工作。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/267ca8fd40634481bb5f26b0d2fc438e.png)
### (4)UART控制寄存器2
- 这个寄存器主要用来设置UART在通信的时候，**数据位字长，停止位，校验模式，关闭硬件流控**

	- bit14:	1 忽略 RTS 引脚
	- bit8 :	0 关闭奇偶校验
	- bit6 :	0 1位停止位
	- bit5 :	1 8位数据位
	- bit2 :	1 打开发送
	- bit1 :	1 打开接收
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6bee39a114214ba3a747405945db7076.png)
### (5)UART控制寄存器3
- ==**在这个芯片，这一位必须设置为1。**==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f038a4673efc4708b03937a5fdb68f96.png)
### (6)UART缓冲控制寄存器
- 这里我们把串口输入的时钟信号**不进行分频**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f02f5db3c9454fbeb527307250f0bf76.png)
- 可以在u_boot中输入`clocks`**获取时钟频率**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/563c140ccb314084a7f2090844fcea11.png)
### (7)UART状态寄存器2
- 这个寄存器可以告诉我们**UART发送数据是否发送完，UART是否接收到数据**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c959f27a9da24f3b9f3ad6a1439ce7d0.png)
### (8)波特率计算寄存器
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bc74d0eb9cea47f6a91d8509d2e90e58.png)

```bash
#假如：
Reference Frequency = 16 MHz       # 输入的时钟信号
Desired Baud Rate   = 920 Kbits/s  # 期望的波特率
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9441916b7e364bdf9a9aaf88699f9c36.png)
- 即可通过**设置UBMR、UBIR寄存器的值**，根据输入的时钟信号值，可调出我们期望的波特率
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b3bb002de28149068fc5943f00fa0c76.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/033b1b81005046bfb9bac1f570663b46.png)
> 我们这里的UART输入时钟信号频率:80MHZ，期望波特率是115200，计算如下：
> (UBMR + 1) / (UBIR + 1) = 80 x 1000 x 1000 / 16 x 115200 = 43.4
> 这里我们取一对数据，让计算的结果为43.4就可以了。我们将UBIR= 9 ,则UBMR = 433。

# 3. I.MX6ull UART编程
## 3.1 原理图
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/662c8256047447c4b43d9a5d09fb131a.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0691f9ced23f461f87584ebafa4ccd6c.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0fc1657f6b224a7e832b7f710592fb57.png)
## 3.2 编程思路
### 1：配置并使能UART1时钟
- 板子启动的时候，板子上面固化的程序已经做了系统时钟初始化，这里只需**直接使能UART1**时钟。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8800c31c9be7431b979f95d6c6de8f6b.png)

```c
CCM_CCGR5 |= (0x3 << 24)
```
### 2：将GPIO设置为UART1功能
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7d7a6f2761f74bdb9a62f00cf9a64488.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/792aa6da20db4ba2b636f44333c7f98e.png)

```c
  /* 2. GPIO MODE: UART1 */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO16 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO17 &= ~(0xf << 0);
```

### 3：设置UART1串口通信协议参数
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ba1e8f0c67364c5d86f7638d95ccee25.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/57ac9c0554a04411a19e76394011ebac.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/77d95c0081414a1b8f10bfe068c27cba.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b3bb002de28149068fc5943f00fa0c76.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/033b1b81005046bfb9bac1f570663b46.png)

> 我们这里的UART输入时钟信号频率:80MHZ，期望波特率是115200，计算如下：
> (UBMR + 1) / (UBIR + 1) = 80 x 1000 x 1000 / 16 x 115200 = 43.4
> 这里我们取一对数据，让计算的结果为43.4就可以了。我们将UBIR= 9 ,则UBMR = 433。

```c
/* 3. Set UART1
        8bit data,1bit stop,no even/odd,115200 bit/s
        本例程使用的RS-232
     */
    UART1->UCR2 = (1 << 14) | (1 << 5) | (1 << 2)
        | (1 << 1); // UCR2,寄存器不要选错了
    UART1->UCR3 |= (1 << 2); // 强制要求
    UART1->UFCR = (0x5 << 7); // clk:80MHZ，不分频
    UART1->UBIR = 9;
    UART1->UBMR = 433;
```
### 4：使能UART1
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d760df31abaa4fd8b793b60606dbcb5f.png)

```c
    /* 4. Enable UART */
    UART1->UCR1 |= (1 << 0);
```
### 5：实现UART1收发功能
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1780e4cb6f054cb5ba4d372de2b12b89.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ea559b4dd73545dd89584885ff7a687e.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4a761465d8be46e785da9c2ff5c344db.png)

```c
/* 5. send,receive */
void uart_send(uint8_t data) {
    int flag = 0;

    UART1->UTXD = data;
    // wait transmit complete
    while(!flag) {
        flag = UART1->USR2 & (1 << 3);
    }
}

uint8_t uart_recv() {
    int flag = 0;

    // wait data read
    while(!flag) {
        flag = UART1->USR2 & (1 << 0);
    }
    return UART1->URXD & 0xff;
}
```
## 3.3 代码实现
### UART接受与发送

```c
#include"imx6ull.h"
#include"uart.h"

void uart_init() {
    /* 1. Enable UART1 Clock */
    CCM_CCGR5 |= (0x3 << 24);

    /* 2. GPIO MODE: UART1 */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO16 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO17 &= ~(0xf << 0);

    /* 3. Set UART1
        8bit data,1bit stop,no even/odd,115200 bit/s
     */
    UART1->UCR2 = (1 << 14) | (1 << 5) | (1 << 2)
        | (1 << 1); // UCR2,寄存器不要选错了
    UART1->UCR3 |= (1 << 2);
    UART1->UFCR = (0x5 << 7); // clk:80MHZ
    UART1->UBIR = 9;
    UART1->UBMR = 433;

    /* 4. Enable UART */
    UART1->UCR1 |= (1 << 0);
}

/* 5. send,receive */
void uart_send(uint8_t data) {
    int flag = 0;

    UART1->UTXD = data;
    // wait transmit complete
    while(!flag) {
        flag = UART1->USR2 & (1 << 3);
    }
}

uint8_t uart_recv() {
    int flag = 0;

    // wait data read
    while(!flag) {
        flag = UART1->USR2 & (1 << 0);
    }
    return UART1->URXD & 0xff;
}

void uart_test() {
    uint8_t data;
    uart_init();

    // 测试从控制板写入数据，向pc端发送数据，pc端接收并通过kermit传递显示
    uart_puts("hello imx6ull\r\n");
    uart_puts("hello uart\r\n");

    // 测试从pc端发送数据，控制板接收，并转发至pc端显示
    while(1) {
        data = uart_recv();
        uart_send(data);
    }
}

void uart_puts(const char *str) {
    const char *p = NULL;

    uart_init();
    
    for(p = str; *p; p++) {
        uart_send(*p);
    }
}
```
### 自定义printf函数实现

```c
#include<stdarg.h>
#include"uart.h"
#include<stdio.h>

int uart_printf(const char *fmt, ...) {
    va_list args;
    char printbuffer[1024];

    va_start(args,fmt);
    vsprintf(printbuffer,fmt,args);
    va_end(args);

    uart_puts(printbuffer);
}

void uart_printf_test(void) {
    uint32_t data = 100;
    const char *str = "hello uart printf";

    uart_printf("data = %d\r\n", data);
    uart_printf("str = %s\r\n",str);
    uart_printf("data = %#x\r\n",data);
}
```

## 3.4 效果展示
### UART接受与发送
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ca8a73d465ee4431af7522c80af41c85.gif)

### 自定义printf函数实现
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/14b440ee3fa34d1ba4cb4ee10d08a2f7.png)

