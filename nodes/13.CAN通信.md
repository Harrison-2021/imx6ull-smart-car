# <font color="#fd6f01">1.理论篇</font>
## 一、CAN简介
### 1.1 CAN总线由来
- 上世纪八十年代以来，汽车`ECU`(`Electronic Control Unit`:电子控制单元)越来越多，如ABS，电控门窗，电子燃油喷射装置。如果仍然采用常规的点对点布线方式，即电线一段与开关相接，另一端与用电设备相通，将会导致车上电线数目的急剧增加，从而带来线束的冗余及维修成本的提高。这就**对汽车的线束分布及信息通讯提出了更高的要求**。
- ==总线技术==可以实现信息的==实时共享==，解决了传统布线方式中线束多，布线难，成本高等问题`CAN`（`Controller Area Network`）**总线技术**应运而生。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/601b32ad2e67454486222515c7dbe44e.png)
- 总线有很多种，较常用的有`CAN总线`、`232/485总线`、`以太网总线`等等，但是应用在对通讯**速度要求很高**的汽车领域，232/485总线就显得不足，**CAN总线和以太网可以胜任**，
- 但是对于实时性来说，CAN总线可以说是首当其冲，对于汽车中的数据通信，要求`发送周期都小于10ms`，而且每辆车都有好几条这样的数据，并且在安全性方面，**CAN总线还有一系列的安全保护措施**，所以综合之后，汽车选用了CAN总线。

### 1.2 CAN总线介绍
- CAN是**控制器局域网络**(`Controller Area Network`, CAN)的简称，是由以研发和生产汽车电子产品著称的德国`BOSCH`公司开发的，并最终成为国际标准（`ISO 11898`），是国际上应用最广泛的现场总线之一。 
- 在北美和西欧，CAN总线协议已经成为**汽车计算机控制系统和嵌入式工业控制局域网的标准总线**，并且拥有以**CAN为底层协议**专为**大型货车和重工机械车辆设计**的`J1939协议`。

- CAN总线是一种==多主控==（Multi-Master）的总线系统。传统总线系统如USB或以太网等是在总线控制器的协调下，实现从A节点到B节点大量数据的传输。
- CAN网络的消息是==广播式==的，即在**同一时刻网络上所有节点侦测的数据是一致的**，它是一种==基于消息广播模式的串行通信总线==。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a664a15ab87f4d229bea21041928e4be.png)
- CAN通信属于==半双工通信==，**收发数据要分时进行**。不管CAN网络上挂多少设备，在同一时刻只能有1个发送数据。
- 如果有多个需要同时发送则**只有优先级别高的先发送，其它的设备处于等待模式**。

- CAN 总线是一种广播类型的总线,这意味着所有节点都可以“听到”所有传输,==无法仅向特定节点发送消息==；
- 这会导致所有节点都会不可避免地接收所有流量,但是==CAN 硬件提供本地过滤==，因此**每个节点只能对自己感兴趣的消息做出反应**
#### (1).CAN总线标准
- CAN总线标准规定了==物理层和数据链路层==，至于**应用层需要用户自定义**。**不同的CAN标准仅物理层不同**。
	- **物理层和数据链路层**:`ISO11898`
	- **应用层**:不同的应用领域使用不同的应用层标准

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/042756caa21644a789833d5dfb2935e5.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7f435868eb004878a3defdd93e099389.png)
#### (2).CAN物理层介绍
- 在 CAN总 线上，利用 `CAN_H` 和` CAN_L` 两根线上的电位差来表示 CAN 信号。
- CAN 总线上的电位差分为 ==显性电平==（Dominant Voltage） 和 ==隐性电平==（Recessive Voltage） 。
	- ==显性电平为逻辑 0==，
	- ==隐性电平为逻辑 1==。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9f73ee58e8224e49a1557ed2a0844c11.png)
- ISO 国际标准 `ISO 11898-2` 和 `ISO 11898-3` 分别规定了两种 CAN 总线结构（在 BOSCH CAN2.0 规范中，并没有关于总线拓扑结构的说明),==闭环总线网络==和==开环总线网络==。
##### 闭环总线网络
- `SO 11898-2` 定义了通信速率为 `125 kbps～1 Mbps` 的==高速 CAN 通信标准==，属于==闭环总线==，
- **传输速率可达1Mbps**，**总线长度 ≤ 40米**。总线的==两端各要求有一个“120欧”的电阻==。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b30734732616499385c61aadca7b52dd.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/442106a7f3a142fbb86a05b98482cbf1.png)
##### 开环总线网络
- `ISO 11898-3` 定义了通信速率为 `10～125 kbps` 的**低速 CAN 通信标准，属于开环总线**，
- 传输速率为 `40kbps `时，总线长度可达`1000`米。**两根总线是独立的、不形成闭环，要求每根总线上各串联有一个“2.2千欧”的电阻**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2fd796868fba4dd898277199d6a3d453.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/68babd25420648d69f1563232877c29f.png)
##### 高速CAN与低速CAN对比
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9183fdb92da048bd90cfc93c8b74de89.png)
##### 线与机制
 模块以==线与==的方式连接到总线：
 - 如果只有==一个节点将总线驱动到逻辑0，则整个总线处于该状态，而不管发送逻辑1的节点数量==。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/90286bb7db0a406db1347947a199c7bb.png)
##### CAN通信物理结构
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b29e5ec60c15440fb79b46e975cdfef7.png)
## 二、 CAN通信协议
### 2.1 CAN通信帧类型
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/96b491e15adf49a897279978e1f678d1.png)
### 2.2 一帧数据格式
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/38260088b6fb494bbbf774efd6f15790.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/31762f13d1374d95a4b583946e030388.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/83560637fa8e4bdcb694be43e7189c38.png)

- `Remote Frame`实际上它的意义是**“遥控帧”**，发起方发起特定ID的远程帧，**并且只发送ID部分**，那么与其ID相符的**终端设备就有义务在后半段的数据部分接管总线控制权并发送自己的数据**。
-  打个比方，中控机需要定时获取某个节点的数据（例如转速计的实时转速、油量计的实时油量等），可以向总线发送远程帧；相**应节点在接收判断帧ID与自己相符、并且是远程帧的情况下，就可以将自己的实时数据发送到总线上；这样中控机就获取到了相关节点的实时数据。**

#### can2.0数据的位序与字节序

![img](https://img-blog.csdnimg.cn/94bec638d81a4da7bed499da031f1d9b.png)

<font color=green>**1.字节序：小端，即，byte0保存低地址，byte7保存在高地址**</font>

<font color=green>**2.位序：	大端，即，高位保存在低地址，低位保存在高地址**</font>

> 例如：以下报文，
>
> - **byte0-byte7从左往右数，第1个字节就算byte0:6F**
> - **位序是大端模式，6F:6在低地址，F在高地址--->6是高位，F是地位，因此6是1.4-1.7高位，F是1.0-1.3低位**
> - <font color="#fd6f01">**即Can2.0数据格式，字节序，从低到高：从左往右数，位序：从低到高，从右往左数**</font>
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c9b8f7edf78f416484bb546aa13586ec.png)

### 2.3 非破坏性仲裁机制
 ==每一个CAN节点都会在“帧开始”进行同步==，同步之后==开始仲裁==，看看能否获得CAN总线的使用权。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8b912cb70a354af6851ad4d3ef5a8057.png)
### 2.4 位填充机制
CAN协议中规定，==当相同极性的电平持续五位时，则添加一个极性相反的位==。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b3bc6a4f6c1c43508c0e1489b60e7305.png)
#### 对于发送节点而言：
在发送**数据帧和遥控帧**时，对于SOF~CRC(除去CRC界定符) 之间的位流，相同极性的电平如果持续5位，那么在下一个位==插入一个与之前5位反型的电平==；

#### 对于接收节点而言：
在**接收数据帧和遥控帧时**，对于SOF~CRC(除去CRC界定符)之间的位流，==相同极性的电平如果持续5位，那么需要删除下一位再接收==。

### 2.5 CAN总线错误帧
#### (1)错误帧分类
CAN总线的错误帧可分为五大类
>- ==位发送错误==、
>- ==位填充错误==、
>- ==CRC错误==、
>- ==格式错误==、
>- ==应答错误==。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bf8979d22f7b4877b38d4e301ce92916.png)
#### (2)错误帧格式
当出现5种错误类型之一时，发送或接收节点将发送错误帧。**错误帧的结构**如下所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e61c67f57ee44a3e97ebcdeb82842f04.png)
#### (3)错误状态的转换
根据CAN协议的规定，在CAN节点内，**有两个计数器**：
- ==发送错误计数器(TEC)==
- ==接收错误计数器(REC)==

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d0fb3e4472ae459d9fc92d58e06b8e14.png)
##### 主动错误状态
- **最开始**TCE和REC都小于127时，**就处于主动错误状态**。

- 在这一状态下，**节点检测到一个错误就会发送带有主动错误标志的错误帧**，

- 因为主动错误标志是==连续六个显性位==，所以这个时候主动错误标志将==会“覆盖”掉总线上其它节点的发送==，**而之前在CAN总线上传输的报文就被这“六个连续显性位”破坏掉了**。

- 如果<font color="#fd6f01">**发出主动错误帧的节点是发送节点**</font>，这个情况下就相当于：刚刚发送的那一帧报文我发错了，现在我破坏掉它（发送主动错误帧），你们不管收到什么都不算数；

- 如果<font color="#fd6f01">**发出主动错误帧的节点是接收节点**</font>，这个情况就相当于：刚刚我收报文的时候发现了错误，不管你们有没有发现这个错误，**我现在主动站出来告诉大家这个错误，并把这一帧报文破坏掉**（发送主动错误帧），刚才你们收到的东西不管对错都不算数了。

  > - ==Tips==: **处于主动错误状态，说明这个节点目前是比较可靠的**，
  >
  > - ==出现错误的原因可能不是它本身的问题==，即刚刚检测到的错误可能不仅仅只有它自己遇到，正是因为这一点，**整个总线才相信它报告的错误，允许它破坏掉发送中的报文**，也就是将这一次的发送作废。

##### 被动错误状态
- 如果某个节点发送错误帧的次数较多，必将使得**TCE＞127 或者 REC＞127**，那么该节点就处于被动错误状态。在这一状态下，节点Node_A检测到一个错误就会发送带有被动错误标志的错误帧，
- ==因为被动错误标志是连续六个隐性位==，所以这个时候**总线上正在传输的报文位流不会受到该被动错误帧的影响**，其它的节点该发送的发送，该接收的接收，没人搭理这个发送被动错误帧的节点Node_A。
- 如果<font color="#fd6f01">**发出被动错误帧的节点Node_A为报文的发送节点**</font>，那么在发送被动错误帧之后，刚刚正在发送的**报文被破坏**，并且Node_A**不能在错误帧之后随着连续发送刚刚发送失败的那个报文**。（因为已经退出竞争）
  - **随之而来的是<font color=red>帧间隔</font>，并且连带着8位隐性位的 “延迟传送” 段**；这样总线电平就呈现出连续11位隐性位，<font color="#fd6f01">**总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争**</font> 。

  - 此时如果Node_A能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。**这种机制的目的正是为了让其它正常节点（处于主动错误）优先使用总线。**


> - ==Tips==: **处于被动错误状态，说明这个节点目前是不太可靠的**，
>
> - ==出现错误的原因可能是它本身的问题==，即刚刚检测到的错误可能仅仅只有它自己遇到，正是因为这一点，整个总线才不信任它报告的错误，**从而只允许它发送六个连续的隐性位，这样它才不会拖累别人**。

##### 总线关闭状态
 - 如果一个处于被动错误状态的节点，仍然多次发送被动错误帧，那么势必导致==TEC ＞ 255，这样就处于总线关闭状态==。
 - 在总线关闭状态下的节点Node_A不能向总线上发送报文，也不能从总线上接收报文，**整个节点脱离总线**。
 - 等到检测到==128次11个连续的隐性位时，TEC和REC置0==，**重新回到主动错误状态**。

### 2.6 过载帧
- 当某个**接收节点没有做好接收下一帧数据的准备时**，将发送过载帧以通知发送节点。
- 可以理解成，接收节点A接收报文的能力达到极限了，于是该节点就发出过载帧告诉总线的其他节点，接收节点A已经没有能力处理你们发来的报文了。

- ==过载帧由过载标志和过载帧界定符组成。==
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cd8e637a55894c2eac50ebeee6370aff.png)
### 2.7 帧间隔
- 帧间隔是用来==隔离数据帧（或者遥控帧）的==，也就是说，数据帧（或者遥控帧）通**过插入帧间隔可以将本帧与先行帧（数据帧、遥控帧、错误帧、过载帧）分隔开来**。

  > <font color=red>**Tips:过载帧和错误帧的前面不能插入帧间隔**</font>




>![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/60c19cae19aa4b4c89c5e5cae7c5c95d.png)
- **间隔段**：==连续三个隐性位==；间隔段期间，所有节点不允许发送数据帧或遥控帧，==只要在这期间监听到显性位，接收节点就会发送过载帧==。 
- **空闲段**：==连续隐性位==，个数不一定，0个或者多个都可以。总线空闲的时间是任意长的，只要总线空闲，节点就可以竞争总线。 
- **暂停段**：==只有处于被动错误状态的节点在发送帧间隔的时候，才会在帧间隔中插入8个连续隐性位的暂停段==，延迟传送。

### 2.8.推荐学习视频
>- [维克多汽车技术](https://www.bilibili.com/video/BV1M5411N7Kc/?spm_id_from=333.788.recommend_more_video.1)
>- [广州虹科电子](https://www.bilibili.com/video/BV1gD4y1U7bJ/?spm_id_from=333.337.search-card.all.click)

## 三、CAN采样点与波特率
### 3.1 介绍
>- CAN网络采用==异步通信==的方式，因此需要==根据波特率进行采样==，采样原理如下图所示。红色箭头则表示采样点的位置，图示采样得到数据则为“1010 1010”。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/11dd2d2758994f84901b83759bbaac3a.png)

- 采样点，需要引入==位时间==的概念。
- 位时间是指**每传输一位数据需要的时间**，即`位时间=1/波特率`。
- 一个位时间可以分为`同步段`、`传播段`、`相位缓冲段1`和`相位缓冲段2`，某个位时间每个段的时间份额如下图所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/80a0f353ff554591b210b4dbb3243a21.png)
- CAN通信中常见的采样点以及相关的参数如下表所示。**不同的波特率时间对应的采样点以及位时间的份额可能不同**。以波特率为500k为例，一个位时间被分成了16个时间份额，采用点在第14个时间份额。
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8d73299e7104472cb15ba6b611cdaa9e.png)
### 3.2 参数含义
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fed07fd2999341e19c8042bc221f877e.png)
#### `SS (synchronization segment)`
- 多个连接在总线上的单元通过此段实现==时序调整，同步进行接收和发送的工作==。
- 由**隐形电平到显性电平的边沿**或由**显性电平到隐性电平边沿**最好出现在此段中。

#### `PTS(Propagation Time Segment)`
- 用于==吸收网络上的物理延迟的段==。
- 所谓的网络的物理延迟指<font color=green>**发送单元的输出延迟**、**总线上信号的传播延迟**、**接收单元的输入延迟**。</font>
- ==这个段的时间为以上各延迟时间和的两倍==

#### `PBS1/2(Phase Buffer Segment 1/2)`
 - 当<font color=green>**信号边沿不能被包含于SS段中时，可在此段进行补偿**。</font>
 - 由于各单元以各自独立的时钟工作，细微的时钟误差会累积起来，==PBS段可用于吸收此误差==。
 - 通过对相位缓冲段加减`SJW`吸收误差。<font color="#fd6f01">**SJW加大后允许误差加大，但通信速度下降**。</font>

#### `SJW (Resynchronization jump width)`
- 因时钟频率偏差、传送延迟等，各单元有同步误差。==SJW为补偿此误差的最大值==。

### 3.3 一些概念
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0aa75cfe3f5b4aa4aa96b7604a8a01ec.png)
> - Fcan输入时钟为`60Mhz`，分频数为6，---->Can `Tq` =  6/60M = 0.1us
>   - <font color=green>即，Tq为一次的周期值，1/f</font>
> - 设置总线**波特率**为`500kbit/s`则:
> 	- CAN `bit time` = 1/500k = 2us ，
> 	- `TqCount`      = CAN bit time/CAN Tq   = 2/0.1 = 20
> 	- 那么`SS + TSEG1 + TSEG2  = TqCount = 20`
> - <font color="#fd6f01">**SS固定占用一个Tq**，**分配TSEG1和TESG2，可以调整采样点位置**</font>
>   - <font color=green>采样点在TSEG1之后，TSEG2之前</font>
>   - 设置TESG1    = 14 ，则TESG2 = 5，（有些手册看到要求TSEG1 > TSEG2 > SJW）
>     则`采样点位置  = （SS + TSEG1）/（SS + TSEG1+TSEG2） =  （1+14）/ 20 = 75%`
>   - **一般采样点位置要求在75-80% 但很难调整到中间值**。

# <font color="#fd6f01">2.实践篇</font>
# 一、硬件原理图阅读
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6bf4d34451d040a49fbf167c4c25846b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/79af3447c75c4db9a2ceca3f788ad53d.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/67994568952a40b4b221600806b0cefa.png)

# 二、Flexible Controller Area Network `(FLEXCAN)`

## 2.1 FlexCan控制器介绍
- The Flexible Controller Area Network (FLEXCAN) module is a `communication controller` `implementing` the `CAN protocol` according to the `CAN 2.0B protocol specification`。

	>- 柔性控制器局域网（FLEXCAN）模块是根据CAN2.0B协议规范实现CAN协议的通信控制器。

- The CAN protocol was primarily designed to be used as a vehicle serial data bus meeting the specific requirements of this field: `real-time processing`, `reliable operation` in the EMI(Electromagnetic Interference:电磁干扰) environment of a vehicle, `cost-effectiveness` and `required bandwidth`. 
- The FLEXCAN module is a **full implementation of the CAN protocol specification**, which supports both **standard and extended message frames**. `64 Message Buffers `are supported by the Flexcan module

	>- CAN协议主要设计用作车辆串行数据总线，以满足该领域的特定要求：==实时处理==、在车辆的EMI环境中==可靠运行==、==成本有效性==和==所需带宽==。
	>- FLEXCAN模块是CAN协议规范的完整实现，它支持标准和扩展消息帧。Flexcan模块支持==64个消息缓冲区==

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3612ee320b364cdc83c61d1cc1002e20.png)

> <font color=green>**ROM**：只读存储器（Read Only Memory）--->硬盘内存</font>
>
> <font color=green>**RAM**：随机存取存储器（Random Access Memory）--->内存</font>

## 2.2 工作模式

- The FLEXCAN module has `four functional modes`: 
	- `Normal Mode` (User and Supervisor), 
	- `Freeze Mode`, 
	- `Listen-Only Mode`
	- `Loop-Back Mode`. 
- There are also two low power modes:` Disable Mode` and `Stop Mode`.

	>- FLEXCAN模块有**四种功能模式**：
	>	- ==正常模式（用户和主管）==、
	>	- ==冻结模式==、
	>	- ==只听模式==
	>	- ==回环模式==。
	>- 还有两种低功耗模式：==禁用模式和停止模式==。

### (1)Normal Mode
- In Normal Mode, the module operates `receiving and/or transmitting message frames`, errors are handled normally and `all the CAN Protocol functions are enabled`. 
- `User and Supervisor Modes` differ in the access to some `restricted control registers`.

	>- 在正常模式下，==模块操作接收和/或发送消息帧，错误得到正常处理，所有CAN协议功能都被启用==。
	>- ==用户和管理模式在访问某些受限控制寄存器方面有所不同==。

### (2) Freeze Mode（冻结模式）
- It is enabled when the `FRZ bit in the MCR Register is asserted`. 
- If enabled, Freeze Mode is entered when the `HALT bit` in MCR is set or when `Debug Mode` is requested at MCU level and the `FRZ_ACK bit` in the MCR Register is asserted by the FlexCAN. 
- In this mode, `no transmission or reception` of frames is done and `synchronicity to the CAN bus is lost`.

	>- 当MCR寄存器中的FRZ位被断言时，它被**启用**。
	>- 如果启用，<font color=green>当MCR中的HALT位被设置时，或者当调试模式在MCU级别被请，**进入冻结模式后**，FlexCAN的MCR寄存器中的FRZ_ACK位被设置1。</font>
	>- 在这种模式下，==不进行帧的传输或接收，并且与CAN总线的同步性丢失==。

### (3)Loop-Back Mode
- The module enters this mode when the `LPB bit in the Control Register is asserted`.
-  In this mode, FLEXCAN performs an internal loop back that can be used for `self test operation`. <font color="#fd6f01">**The bit stream output of the transmitter is internally fed back to the receiver input.**</font>
-  <font color="#fd6f01">The `FLEXCAN_RX input pin is ignored` and the `FLEXCAN_TX output goes to the recessive state (logic ‘1’)`. </font>FLEXCAN behaves as it normally does when transmitting and <font color="#fd6f01">`treats its own transmitted message as a message received from a remote node`.</font>
-  In this mode, FLEXCAN <font color="#fd6f01">`ignores the bit sent during the ACK slot`</font> in the `CAN frame` acknowledge field to `ensure proper reception of its own message`. Both `transmit and receive interrupts are generated`.

	>- 当控制寄存器中的==LPB位被断言时，模块进入此模式==。
	>- 在此模式下，FLEXCAN执行可用于**自检操作的内部环回**。**发送器的比特流输出在内部反馈到接收器输入**。
	>- ==FLEXCAN_RX输入引脚被忽略，FLEXCAN_TX输出进入隐性状态（逻辑“1”）==。FLEXCAN在发送时的行为与往常一样，**并将自己传输的消息视为从远程节点接收到的消息**。
	>- 在此模式下，FLEXCAN忽略CAN帧确认字段中ACK时隙期间发送的位，以确保正确接收自己的消息。==会产生发送和接收中断==

## 2.3 时钟信号
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/96170dd208eb4699ac859e769f69a2ff.png)
### (1)CCM Clock Switcher Register (`CCM_CCSR`)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/170a78d77bc2450685fc31ca959c1462.png)

```c
CCM_CCSR &= ~(1 << 0);
```
### (2)CCM Serial Clock Multiplexer Register 2 (`CCM_CSCMR2`)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/811f276cdfd64b11869ff0f5dff5bc8c.png)

```c
 CCM_CSCMR2 &= ~(0x3 << 8);
 CCM_CSCMR2 &= ~(0x3f << 2); //60MHZ
```
### (3) CCM_CCGR0  

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9d479ef71c7c4408810ed2a4bdc2b740.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9903e76b9d3d43e99ad05e21ac9295d9.png)

```c
//can2_clk_enable
//can2_serial_clk_enable
CCM_CCGR0  |= (0xf << 18);
```



## 2.4 Message Buffer Structure

>![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3612ee320b364cdc83c61d1cc1002e20.png)
>
>- <font color="#fd6f01">**共有64个Message buffer**</font>
>
>- <font color="#fd6f01">Each individual Message buffer is formed by `16 bytes`.</font>
>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0fdc0be663dd4e26a32364b51f8fdaae.png)
>
>  ```c
>  struct
>        {                          /* offset: 0x80, array step: 0x10 */
>              __IO uint32_t CS;    /**< MB0-63:CS Register, array offset: 0x80, array step: 0x10 */
>              __IO uint32_t ID;    /**< MB0-63:ID Register, array offset: 0x84, array step: 0x10 */
>              __IO uint32_t WORD0; /**< MB0-63:WORD0 Register, array offset: 0x88, array step: 0x10 */
>              __IO uint32_t WORD1; /**< MB0-63:WORD1 Register, array offset: 0x8C, array step: 0x10 */
>        } MB[64];
>  ```
>
>  
### (1)`CODE` - Message Buffer Code
- This `4-bit field` can be `accessed` (read or write) by the CPU and by the FLEXCAN module itself, as part of the `message buffer matching` and `arbitration process`.

	>- 作为==消息缓冲区匹配和仲裁过程==的一部分，CPU和FLEXCAN模块本身可以访问（读取或写入）这个**4位字段**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0fc2e8d14d6f41cfb5a4596605b17c0a.png)

> 1.<font color=green>**先准备接收数据，将MB设置为Inactive状态，不参与匹配过程，便于先接收数据**：</font>
>
> ​	<font color="#fd6f01">0b0000: INACTIVE - MB is not active.</font>
>
> 2.可以手动先清空MB数据区，进行准备接收新数据
>
> 3.<font color=green>**active MB：数据放入MB后，激活MB，清空MB数据区，并开始接收数据，数据接收成功，状态会自动变为FULL（0010）**</font>
>
> ​	<font color="#fd6f01">0b0100: EMPTY - MB is active and empty</font>
>
> ​	<font color="#fd6f01">0b0010: FULL - frame is received successfully </font>

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/28e4e856fe634ff59edc9ac375299358.png)

> <font color=green>**1.先inactive准备向MB写入数据: 0b1000: INACTIVE - MB is not active**</font>
>
> 2.向MB的data区放数据
>
> <font color=green>**3.激活：0b1100，进行写数据传输，写入成功后自动返回INACTIVE状态**</font>

### (2)`SRR` - Substitute Remote Request
- `Fixed recessive bit`, used only in `extended format`. <font color="#fd6f01">It `must `be set to ‘1’ by the user for `transmission (Tx Buffers)` </font>and will be stored with the value received on the CAN bus for Rx receiving buffers. 

- It can be received as either `recessive or dominant`. If FLEXCAN receives this bit as `dominant`, then it is interpreted as `arbitration loss`.

  >- ==固定隐性位==，仅用于扩展格式。用户**必须**将其**设置为“1”才能传输（Tx Buffers）**，并将与CAN总线上接收到的Rx接收缓冲区的值一起存储。
  >- 它可以作为隐性或显性接收。如果FLEXCAN接收到此位作为==显性==，则将其解释为==仲裁丢失==。
  >- <font color="#fd6f01">`1 = Recessive` value is `compulsory` </font>for transmission in `Extended Format frames`(对于扩展格式帧中的传输，必须使用隐值)
  >- <font color="#fd6f01">`0 = Dominant` is `not a valid value` </font>for transmission in `Extended Format frames`(显性不是扩展格式帧中传输的有效值)

### (3)`IDE` - ID Extended Bit
This bit identifies `whether the frame format is standard or extended`. It is also used as part of the `reception filter`.

> 该位标识帧格式是标准格式还是扩展格式。它也用作**接收过滤器的一部分**。

- `1= Frame format is extended`
- `0= Frame format is standard`

### (4)`DLC` - Length of Data in Bytes
- This 4-bit field is the `length (in bytes) of the Rx or Tx data`, which is located in offset 0x08 through 0x0F of the MB space (see the first table above). 

- <font color="#fd6f01">`In reception`, this field is written by the FLEXCAN module</font>, `copied from the DLC (Data Length Code) field of the received frame`.

	>- 这个4位字段是Rx或Tx数据的==长度（以字节为单位）==，它位于MB空间的偏移量0x08到0x0F（参见上面的第一个表）。
	>- 在接收中，该字段由FLEXCAN模块写入，从接收帧的DLC（数据长度代码）字段复制。

- <font color="#fd6f01">` In transmission`, this field is written by the `Arm` and `corresponds` to the DLC field value of the frame to be transmitted.</font> 

- When `RTR=1`, the Frame to be transmitted is a `Remote Frame` and `does not include the data field`, regardless of the Length field. 

- <font color="#fd6f01">**The DLC field indicates which DATA BYTEs are valid** </font>as shown in the table below.

	![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/63d5daba3aca42b0a979dd04bbc46946.png)
	
	>- 在传输中，此字段由Arm写入，对应于要传输帧的DLC字段值。
	>- ==当RTR=1时，无论长度字段如何，要传输的帧都是远程帧，不包括数据域==。
	>- DLC字段指示哪些数据BYTE有效，如下表所示。

### (5)PRIO - Local priority
- <font color=green>**This 3-bit field is only used when `MCR[LPRIO_EN]` bit is asserted and it only makes sense for `Tx mailboxes`.** </font>

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e756acb44afa44358062f2f1607ab1d6.png)

- <font color=green>**These bits are `not transmitted`.** </font>They are appended to the regular ID to `define the transmission priority`.

	>- 此3位字段仅在断言MCR[LPRIO_EN]位时使用，并且==仅对Tx传输有意义==。
	>- **这些位不会被传输**。它们被附加到常规ID以**定义传输优先级**。

### (6)ID - Frame Identifier
- <font color=green>**In `Standard Frame format`, only the 11 most significant bits (`28 to 18`) are used for frame identification**</font> in both receive and transmit cases. The 18 least significant bits are ignored. 
- <font color=green>**In `Extended Frame format`, `all bits` are used for frame identification in both receive and transmit cases.**</font>

	>- 在标**准帧格式**中，只有**11个最高有效位（28到18）**用于接收和发送情况下的帧识别。18个最低有效位被忽略。
	>- 在**扩展帧格式**中，**所有位**都用于接收和发送情况下的帧识别。

### (7)DATA BYTE 0-7 - Data Field
- **`Up to eight bytes`** can be used for a data frame. `For Rx frames`, the data is` stored as it is received from the CAN bus`.

	>- 一个数据帧==最多可使用8个字节==。对于Rx帧，数据在从CAN总线接收时存储。

## 2.5 Transmit Process
1. Check if the `respective interruption` bit is set and `clear it`(检查各自的中断位是否设置并清除)

2. If the MB is `active` (transmission pending), write the` ABORT code (0b1001)` to the CODE field of the Control and Status word to request an `abortion` of the transmission. 

   - Wait for the corresponding `IFLAG` to be asserted by` polling the IFLAG register` or **by the interrupt request** if enabled by the respective `IMASK`. Then read back the CODE field to `check if the transmission was aborted or transmitted` (see Transmission Abort Mechanism). 

   - <font color="#fd6f01">If `backwards compatibility` is desired (`MCR[AEN] bit negated`), **just write the `INACTIVE code (0b1000)` to the CODE field to inactivate the MB** </font>but then `the pending frame may be transmitted without notification`

   	>- 如果MB处于**活动状态（传输挂起）**，将ABORT代码（0b1001）写入控制和状态字的CODE字段以**请求中止传输**。
   	>- 等待通过轮询IFLAG寄存器或中断请求断言相应的IFLAG（如果相应的IMASK启用）。**然后读回CODE字段以检查传输是否被中止或传输**（参见传输中止机制）。
   	>- 如果需要==向后兼容性（MCR[AEN]位否定），只需将INACTIVE （0b1000）写入CODE字段以停用MB==，但随后挂起帧可能会在没有通知的情况下传输


3. `Write the ID word`.

4. `Write the data bytes`.

5. Write the `DLC`, Control and `Code fields` of the Control and Status word to `activate the MB`.(编写控制和状态字的DLC、控制和代码字段以激活MB)

   


 Once the MB is activated, it will `participate into the arbitration process` and eventually be transmitted according to its `priority`. 

   - At the` end of the successful transmission`, **the value of the Free `Running Timer` at the time of the second bit of frame’s Identifier field is written into the MB’s `Time Stamp field`,** the `CODE field` in the Control and Status word is updated, the` CRC Register` is updated, a `status flag is set in the Interrupt Flag Register` and an interrupt is generated if allowed by the corresponding Interrupt Mask Register bit. 

   - The new CODE field after transmission depends on the code that was used to activate the MB in step five

     >- 一旦**MB被激活，它将参与仲裁过程**，并最终根据其**优先级进行传输**。
     >- 在成功传输结束时，**帧标识符字段第二位时的自由运行定时器的值被写入MB的时间戳字段**，控制和状态字中的CODE字段被更新，CRC寄存器被更新，在中断标志寄存器中设置状态标志，如果相应的中断掩码寄存器位允许，则产生中断。
     >- 传输后的新CODE字段取决于用于激活步骤5中MB的代码


   - When the` Abort feature is enabled` (MCR[AEN] bit is asserted), `after the Interrupt Flag is asserted` for a Mailbox configured as transmit buffer, **the Mailbox is `blocked`, therefore the CPU is not able to update it until it negates the Interrupt Flag.** 

   - It means that the CPU must<font color="#fd6f01">**` clear the corresponding IFLAG `before starting to prepare this MB for a `new transmission or reception`**.</font>

     > - 当中止功能被启用（MCR[AEN]位被断言）时，在配置为传输缓冲区的邮箱断言中断标志后，邮箱被阻塞，因此CPU无法更新它，直到它清空中断标志。
     > - 这意味着==CPU必须清除相应的IFLAG才能开始准备此MB以进行新的传输或接收==。

## 2.6 Receive Process
To be able to receive CAN frames into a Mailbox, the CPU must prepare it for reception by executing the steps listed here.(为了能够将CAN帧接收到邮箱中，CPU必须通过执行此处列出的步骤来准备接收)

- 1.If the Mailbox is `active` (either Tx or Rx), `inactivate the Mailbox` (see Message Buffer Inactivation), preferably with a safe inactivation(如果邮箱==处于活动状态（Tx或Rx），请停用==邮箱（请参阅消息缓冲区停用），最好安全停用)

- 2.`Write the ID word`

- 3.Write the EMPTY code (0b0100) to the `CODE field` of the Control and Status word to` activate the Mailbox`.(将EMPTY代码（0b0100）写入控制和状态字的CODE字段以激活邮箱)

  

Once the Mailbox **is activated in the third step, it will be able to receive frames that match the programmed filter.**(在第三步中激活邮箱后，它将能够接收与编程过滤器匹配的帧)

- The CPU should synchronize to frame reception by the status flag bit for the specific Mailbox in one of the `IFLAG Registers` and not by the CODE field of that Mailbox. 
- `Never do polling by reading directly the C/S word of the Mailboxes`. Instead, `read the IFLAG registers`.

>- CPU应该==通过其中一个IFLAG寄存器中特定邮箱的状态标志位而不是该邮箱的CODE字段与帧接收同步==。
>- ==切勿通过直接读取邮箱的C/S字进行轮询==。**相反，读取IFLAG寄存器。**

> <font color=red>**注意：**</font>
>
> <font color="#fd6f01">**注意时序：第一次接收数据前要先配置，将MB准备好**</font>
>
> ```c
> /* 第一次接收数据前要先配置，将MB准备好
> 	MB9 for rx*/
>     flexcan_rx_MB_config(CAN2,9,0x520);
> 
>     while(1){
>         for(i = 0;i < sizeof(tx_buf);i ++){
>             flexcan_send_data(CAN2,0x520,tx_buf,i + 1);
>             uart_printf("flexcan send data ok\r\n");
>             size = flexcan_recv_data(CAN2,0x520,rx_buf,sizeof(rx_buf));
>             uart_printf("can rx:");
>             for(j = 0;j < size;j ++){
>                 uart_printf("%x ",rx_buf[j]);
>             }
>             uart_printf("\r\n");
>             // flexcan_rx_MB_config(CAN2,9,0x520);
>             gpt_delay_ms(500);
>         }
>     }
> ```
>
> 


## 2.7 Protocol Timing
- The FLEXCAN module `supports a variety of means` to **`setup bit timing parameters`** that are required by the CAN protocol. 
- The Control Register has various fields used to control bit timing parameters: `PRESDIV`, `PROPSEG`,` PSEG1`, `PSEG2` and `RJW`.

  >- FLEXCAN模块支持多种设置CAN协议所需的位定时参数的方法。
  >- 控制寄存器有各种用于控制位定时参数的字段：PRESDIV、PROPSEG、PSEG1、PSEG2和RJW。

- The `PRESDIV` field controls a prescaler that generates the Serial Clock (Sclock), whose period defines the `‘time quantum’(Tq) used to compose the CAN waveform`. 
- A time quantum(Tq) is the `atomic unit of` time handled by the CAN engine.

  >- PRESDIV字段控制一个预定标器，该预定标器生成串行时钟，其周期定义用于组成**CAN波形**的时间量。
  >- ==时间量(Tq)是由CAN引擎处理的原子时间单位==。


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7f342a9a69aa4ccbb6fe3a8a370ec651.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b450c0c6863f480eb999e113af92bfa4.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bc055f749dcb4c21893e691343075f6e.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4695b41f40de4f54b59dcd576bad93a9.png)

> ==**bit rate = 1 / bit time = 1 / (Tq * Tq count)**==

### (1)SYNC_SEG
- This segment has a `fixed length` of `one time quantum`. Signal edges are expected to happen within this section.

	>- 此段具有==一个Tq的固定长度==。信号边缘预计发生在该部分内。

### (2)Time Segment 1
- This segment includes the `Propagation Segment and the Phase Segment 1` of the CAN standard. 

- It can be programmed by setting the` PROPSEG` and the `PSEG1 `fields of the `CTRL Register` so that their sum `(plus 2)` is in the range of 4 to 16 time quanta.

	>- 此段包括**CAN标准的传播段和相位段1。**
	>
	>- 它可以通过设置**CTRL寄存器的PROPSEG和PSEG1字段进行编程，使它们的总和加2**，在4到16个时间量子的范围内。
	>
	>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c1ac47ecb47c4ec9a0892898bb93ad1e.png)
	>
	>  ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/52cfbe5a442f438bb96eb2950024d868.png)

### (3)Time Segment 2
This segment represents the `Phase Segment 2` of the CAN standard. It can be programmed by setting the `PSEG2 field of the CTRL Register (plus 1) `to be 2 to 8 time quanta long.

> - 此段表示CAN标准的相位段2。**可以通过将CTRL寄存器（加1）的PSEG2字段**设置为2到8个时间量子长来对其进行编程。
>
>   ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1791760057f24fc2a3158c847dcd2921.png)

### (4)计算

```bash
set CAN bit-rate 500000 = 500K,75% sample rate
FLEXCAN_TIME_QUANTA_NUM = 1 + (PSEG1 + 1) + (PSEG2 + 1) + (PROPSEG + 1);
                        = 1 + (6 + 1) + (4 + 1) + (6 + 1)
                        = 20

bit-rate = fTq/(number of Time Quanta)
fTq      = bit-rate * (number of Time Quanta)
         = 500000   * 20
         = 10000000

fCANCLK  = 60MHZ
fTq      = fCANCLK / (Prescaler value);
         = 60MHZ   / PV
        
PV       = 60MHZ/fTq = 60MHZ/10000000 = 6

```

# 三、CAN 控制器寄存器介绍



## 3.1 **Module Configuration Register (FLEXCANx_MCR)**

![图片描述](https://img.mukewang.com/wiki/63eca68109c74bd712573935.jpg)



## 3.2 **Control 1 Register (FLEXCANx_CTRL1)**

![图片描述](https://img.mukewang.com/wiki/63eca6a909d54e1712622606.jpg)



## 3.3 **Interrupt Masks 1 Register (FLEXCANx_IMASK1)**

This register allows to enable or disable any number of a range of **32 Message Buffer Interrupts**. 

- It contains one **interrupt mask bit per buffer**, enabling the Arm to determine which buffer generates an interrupt after a successful transmission or reception(i.e., when the corresponding **IFLAG1 bit is set**)

> 该寄存器允许启用或禁用任意数量的32个消息缓冲区中断。它每个缓冲区包含一个中断掩码位，使Arm能够确定哪个缓冲区在成功传输或接收后生成中断(即，当设置相应的IFLAG1位时）

![图片描述](https://img.mukewang.com/wiki/63eca6ec09e66eee12600247.jpg)



## 3.4 **Interrupt Masks 2 Register (FLEXCANx_IMASK2)**

This register allows any number of a range of 32 Message Buffer Interrupts to be enabled or disabled. 

- It contains one interrupt mask bit per buffer, enabling the Arm to determine which buffer generates an interrupt after a successful transmission or reception (i.e. when the corresponding IFLAG2 bit is set).

> 该寄存器允许启用或禁用任意数量的32个消息缓冲区中断。它每个缓冲区包含一个中断掩码位，使Arm能够确定哪个缓冲区在成功传输或接收后（即设置相应的IFLAG2位时）产生中断。

![图片描述](https://img.mukewang.com/wiki/63eca70d09a4dfe612660257.jpg)



## 3.5 **Interrupt Flags 1 Register (FLEXCANx_IFLAG1)**

This register **defines the flags for 32 Message Buffer interrupts and FIFO interrupts**. 

- It contains one interrupt flag bit per buffer. **Each successful transmission or reception sets the corresponding IFLAG1 bit**. 
- If the corresponding IMASK1 bit is set, an interrupt will be generated. **The Interrupt flag must be cleared by writing it to ‘1’. Writing ‘0’ has no effect.**

> 该寄存器定义了32个消息缓冲区中断和FIFO中断的标志。**每个缓冲区包含一个中断标志位**。**每次成功的传输或接收都会设置相应的IFLAG1位。**
>
> **如果设置了相应的IMASK1位，则会产生中断**。<font color=red>**(即，没有设置IMASK1位，不会产生中断，只是改变中断标志位的值)**</font>
>
> 中断标志必须通过将其写入“1”来清除。写入“0”没有效果。

When the `RFEN` bit in the MCR is set (Rx FIFO enabled), the function of the 8 least significant interrupt flags (BUF7I - BUF0I) is changed to support the FIFO operation. 

- BUF7I, BUF6I and BUF5I indicate operating conditions of the FIFO, while BUF4I to BUF0I are not used.

> - 当MCR中的RFEN位被设置（RxFIFO启用）时，8个最低有效中断标志（BUF7I-BUF0I）的功能被改变以支持FIFO操作。BUF7I、BUF6I和BUF5I指示FIFO的工作条件，而BUF4I到BUF0I不被使用。
>
> - <font color=green>**即，MB0-MB7用作FIFO特殊用处的MB，一般的功能，直接使用MB8-MB31即可**</font>

![图片描述](https://img.mukewang.com/wiki/63eca7370911bbef12490902.jpg)



## 3.6 **Interrupt Flags 2 Register (FLEXCANx_IFLAG2)**

![图片描述](https://img.mukewang.com/wiki/63eca74d0969695112630212.jpg)



# 四、实现CAN数据收发



## 1.GPIO初始化

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6bf4d34451d040a49fbf167c4c25846b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/79af3447c75c4db9a2ceca3f788ad53d.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/67994568952a40b4b221600806b0cefa.png)

```c
void flexcan_gpio_init() {
    //0010 ALT2 — FLEXCAN2_TX of instance
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO22 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO22 |=  (0x2 << 0);

    // 0010 ALT2 — FLEXCAN2_RX of instance
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO23 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO23 |=  (0x2 << 0);
}

```



## 2.FlexCan时钟初始化

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/96170dd208eb4699ac859e769f69a2ff.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9903e76b9d3d43e99ad05e21ac9295d9.png)

```c

void flexcan_clock_init() {
    // 1.[0] 0 pl3_main_clk: 480MHz
    CCM_CCSR &= ~(1 << 0);

    // 2.[9-8] 0b00 can_clk_sel: /8 = 60MHz
    //   [7-2] 0b000000 can_clk_podf: divide by 1: 60MHz
    CCM_CSCMR2 &= ~((0x3 << 8) | (0x3f << 2));

    // 3.enable can2 clock
    // [21-20] 11 can2_serial clock
    // [19-18] 11 can2 clock
    CCM_CCGR0 |= (0xf << 18);

}
```



## 3.FlexCan控制器初始化

![图片描述](https://img.mukewang.com/wiki/63eca68109c74bd712573935.jpg)

```c
void flexcan_can_init(CAN_Type *base) {
    /* 1.MDIS[31] 0 enable flexcan mode*/
    base->MCR &= ~(1 << 31);

    /*
     2.SOFT_RST[25] 1 Reset the registers
     it may take some time to fully propagate its effect,
     The SOFT_RST bit remains asserted while reset is pending, 
     and is automatically negated when reset completes.
    */
    base->MCR |= (1 << 25);
    while(base->MCR & (1 << 25)) {
        uart_printf("wait reset \r\n");
    }

    /*
     3.在进行一些can配置时，要求必须进入冻结模式，配置完后，再解除冻结模式
       FRZ[30] 1 Enabled to enter Freeze Mode
      HALT[28] 1 Enters Freeze Mode if the FRZ bit is asserted.
    */
    flexcan_freeze_enable(base);

    /*
     4.SRX_DIS [17] 1 Self reception disabled
    */
    base->MCR |= (1 << 17);

    /*
     5.MAXMB [6:0] Number of the last MB = MAXMB
    */
    base->MCR &= ~(0x7f << 0);
    base->MCR |=  (63 << 0); // 0-63

    /*
     6.配置完后，再解除冻结模式
     FRZ [30] 0 Not enabled to enter Freeze Mode
    HALT [28] 0 No Freeze Mode request.
    */
    flexcan_freeze_disable(base);
}

void flexcan_freeze_enable(CAN_Type *base) {
    /*
     在进行一些can配置时，要求必须进入冻结模式，配置完后，再解除冻结模式
       FRZ[30] 1 Enabled to enter Freeze Mode
      HALT[28] 1 Enters Freeze Mode if the FRZ bit is asserted.
    */
    base->MCR |= (1 << 28) | (1 << 30);
}

void flexcan_freeze_disable(CAN_Type *base) {
    /*
     配置完后，再解除冻结模式
     FRZ [30] 0 Not enabled to enter Freeze Mode
    HALT [28] 0 No Freeze Mode request.
    */
    base->MCR &= ~((1 << 30) | (1 << 28));
}
```



## 4.FlexCan采样点和波特率设置

> 见2.7 Protocol timing
>
> ![图片描述](https://img.mukewang.com/wiki/63eca6a909d54e1712622606.jpg)

```c
void flexcan_sample_bitRate_init(CAN_Type *base) {
    #if 0
    set CAN bit-rate 500000 = 500K,75% sample rate
    FLEXCAN_TIME_QUANTA_NUM = 1 + (PSEG1 + 1) + (PSEG2 + 1) + (PROPSEG + 1);
                            = 1 + (6 + 1) + (4 + 1) + (6 + 1)
                            = 20

    bit-rate = fTq/(number of Time Quanta)
       ->fTq = bit-rate * (number of Time Quanta)
             = 500000   * 20
             = 10000000 = 10MHz-->Tq = 0.1us

    fCANCLK  = 60MHZ
    fTq      = fCANCLK / (Prescaler value);
             = 60MHZ   / PV
            
        ->PV = 60MHZ/fTq = 60MHZ/10000000 = 6
    #endif
    
    /*1.控制器配置前，要先进入冻结模式,结束配置后，解冻
     FRZ  [30] 1 Enabled to enter Freeze Mode
     HALT [28] 1 Enters Freeze Mode if the FRZ bit is asserted.
    */
    flexcan_freeze_enable(base);

    /*2.控制器设置
     PRESDIV [31–24]  Sclock frequency = CPI clock frequency / (PRESDIV+1)
     RJW     [23–22]  Resync Jump Width = RJW + 1. 
                      The valid programmable values are 0-3.
                      通过对相位缓冲段加减`SJW`吸收误差。SJW加大后允许误差加大，但通信速度下降

     PSEG1   [21–19]  Phase Buffer Segment 1 = (PSEG1 + 1) x Time-Quanta.
                      The valid programmable values are 0-7

     PSEG2   [18–16]  Phase Buffer Segment 2 = (PSEG2 + 1) x Time-Quanta.
                      The valid programmable values are 1-7
     PROP_SEG [2-0 ]  Propagation Segment Time = (PROPSEG + 1) * Time-Quanta
                      The valid programmable values are 0-7                 
    */
    base->CTRL1 = (5 << 24) | (0 << 22) | (6 << 19) | (4 << 16) | (6 << 0);

    /*3.解冻 */
    flexcan_freeze_disable(base);
}
```



## 5.FlexCan收发邮箱配置



### (1)发送邮箱配置

> 见 2.5 Transmit Process
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/28e4e856fe634ff59edc9ac375299358.png)

```c
typedef struct{
    int index;
    int id;
    int word0;
    int word1;
    int size;
}mb_data_t;

void flexcan_tx_MB_config(CAN_Type *base, mb_data_t *mb) {
    /* 1.先inactive,准备发送数据
     CODE [27:24] 0b1000: INACTIVE - MB is not active
    */
    base->MB[mb->index].CS = (0x8 << 24);

    /*2.发送id，size,数据
    DLC         [19:16] Length of Data in Bytes
    ID Standard [28:18]  Frame Identifier
   */
    base->MB[mb->index].CS |= (mb->size << 16);
    base->MB[mb->index].ID = (mb->id << 18);
    base->MB[mb->index].WORD0 = mb->word0;
    base->MB[mb->index].WORD1 = mb->word1;

    /*3.数据准备好后，进行Active MB,发送完成后，会触发中断标志位
    CODE [27:24] 0b1100: DATA -MB is a Tx Data Frame (MB RTR must be 0)
   */
    base->MB[mb->index].CS |= (0xc << 24);// 注意是|=,否则会清空前面的cs值
}
```



### (2)接收邮箱配置

> 见 2.6 Receive Process
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0fc2e8d14d6f41cfb5a4596605b17c0a.png)

```c
void flexcan_rx_MB_config(CAN_Type *base, int index, int id) {
    /*1.inactiveMB,准备接收数据
     CODE [27:24] 0b0000: INACTIVE - MB is not active.
    */
    base->MB[index].CS = 0;

    /*2.写入iD,接收指定ID的帧数据
    ID Standard [28:18]  Frame Identifier
    */
    base->MB[index].ID = (id << 18);
    base->MB[index].WORD0 = 0;
    base->MB[index].WORD1 = 0;

    /*3.Active MB，开始接收数据，接收成功后code会变为0010 full状态
    CODE [27:24] 0b0100: EMPTY - MB is active and empty.*/ 
    base->MB[index].CS |= (0x4 << 24);
}
```



## 6.FlexCan阻塞方式发送数据

> 见2.5 Transmit Process
>
> ![图片描述](https://img.mukewang.com/wiki/63eca7370911bbef12490902.jpg)
>
> ![图片描述](https://img.mukewang.com/wiki/63eca74d0969695112630212.jpg)

```c
#define TX_MB_INDEX 8
#define RX_MB_INDEX 9

void flexcan_send_data(CAN_Type *base, int id, uint8_t *buf, int size) {
    /*
    1.先准备要发送的数据，要以帧格式写入MB中
    word0 : DATA BYTE 0 |  DATA BYTE 1 |  DATA BYTE 2 | DATA BYTE 3
    word1 : DATA BYTE 4 |  DATA BYTE 5 |  DATA BYTE 6 | DATA BYTE 7
    */
    mb_data_t mb;
    mb.id = id;
    mb.size = size;
    mb.index = TX_MB_INDEX;
    uint32_t word0 = 0;
    uint32_t word1 = 0;
    int i,flag;
    if(size > 4) { // 要放入两个32位的内存中
        for(i = 0; i < 4; i++) { // 字节序大端模式，低字节放在高位
            word0 |= (buf[i] << (24 - i * 8));
        }
        for(i = 4; i < size; i++) {
            word1 |= (buf[i] << (24 - (i - 4) * 8));
        }
    } else {
        for(i = 0; i < size; i++) { // 字节序大端模式，低字节放在高位
            word0 |= (buf[i] << (24 - i * 8));
        }
    }
    mb.word0 = word0;
    mb.word1 = word1;

    /* 2.将准备好的数据写入MB中 */
    flexcan_tx_MB_config(base, &mb);

    /* 3.等待发送，直到发送完成，产生中断标志位（轮循方式判定），
         并非产生中断，要产生中断，需要设置mask寄存器
   [31-8] Each bit flags the respective MB(MB8 to MB31) interrupt
   1 responding MB has successfully completed transmission or reception*/
   do {
        flag = base->IFLAG1 & (1 << TX_MB_INDEX);
        // uart_printf("wait iflag1: ");
   } while(!flag);


   /* 4.发送完成后，要清除中断标志位，写1清除
   CPU must clear the corresponding IFLAG before starting to prepare this MB for a 	newtransmission or reception.
   The Interrupt flag must be cleared by writing it to '1'.*/
   base->IFLAG1 |= (1 << TX_MB_INDEX);
}
```



## 7.FlexCan阻塞方式接收数据

> 见2.6 Receive Process

```c
flexcan_rx_MB_config(CAN2, RX_MB_INDEX, 0x233);

/* 在接收数据前，要先配置好MB,才能开始接收数据 */
int flexcan_recv_data(CAN_Type *base, int id, uint8_t *buf, int size) {
    /* 1.等待接收，直到接收完成，产生中断标志位（轮循方式判定）
   [31-8] Each bit flags the respective MB(MB8 to MB31) interrupt
   1 responding MB has successfully completed transmission or reception*/
    int flag, i;
    do {
        flag = base->IFLAG1 & (1 << RX_MB_INDEX);
        // uart_printf("wait reve iflag1: \r\n");
    } while(!flag);

   /*2.同时判断MB是否接收成功，full标志
    0b0010: FULL - MB is full.*/
    int code = (base->MB[RX_MB_INDEX].CS >> 24) & 0xf;
    if(code != 2) {
        uart_printf("Fail to flexcan recv data\r\n");
        return -1;
    }

    /* 3.接收成功后，进行处理数据（打印接收的字节）
    注意需求接收的字节数不能超高实际MB中的大小*/
    int rev_size = 0;
    rev_size = (base->MB[RX_MB_INDEX].CS >> 16) & 0xf;
    
    if(rev_size > size) {
        uart_printf("recv buf is too small\r\n");
        return -1;
    }
    int word0 = base->MB[RX_MB_INDEX].WORD0;
    int word1 = base->MB[RX_MB_INDEX].WORD1;
    /*
     word0 : DATA BYTE 0 |  DATA BYTE 1 |  DATA BYTE 2 | DATA BYTE 3
     word1 : DATA BYTE 4 |  DATA BYTE 5 |  DATA BYTE 6 | DATA BYTE 7
    */
    if(rev_size > 4) {
        for(i = 0; i < 4; i++) {
            buf[i] = word0 >> 24;
            word0  <<= 8;
        }
        for(i = 4; i < rev_size; i++) {
            buf[i] = word1 >> 24;
            word1  <<= 8;
        } 
    } else {
        for(i = 0; i < rev_size; i++) {
            buf[i] = word0 >> 24;
            word0 <<=  8;
        }
    }

    /* 4.清除中断位
   The Interrupt flag must be cleared by writing it to '1'.*/
    base->IFLAG1 |= (1 << RX_MB_INDEX);

    /* 5.重新配置接收MB,准备接收下一帧数据
   MB9 for rx*/
    flexcan_rx_MB_config(base, RX_MB_INDEX, id);

    return rev_size;
}

```



## 8.FlexCan测试收发

### (1)回环测试

#### Loopback Enable/Disable

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a68302198e1b4ec69af2aad4a8680535.png)

```c
void flexcan_loopback_enable(CAN_Type *base) {
    /* 1.进入冻结模式，控制进行设置 */
    flexcan_freeze_enable(base);

    /* 2.回环模式开启 
    LPB  [12] 1 Loop Back enabled
              0 Loop Back disabled
    */
    base->CTRL1 |= (1 << 12);

    /* 3.解冻 */
    flexcan_freeze_disable(base);
}

void flexcan_loopback_disable(CAN_Type *base) {
    /* 1.进入冻结模式，控制进行设置 */
    flexcan_freeze_enable(base);

    /* 2.回环模式开启 
    LPB  [12] 1 Loop Back enabled
              0 Loop Back disabled
    */
    base->CTRL1 &= ~(1 << 12);

    /* 3.解冻 */
    flexcan_freeze_disable(base);
}
```

#### 测试代码

```c
void flexcan_loopback_test() {
    int size = 0;
    uint8_t rx_buf[8];
    uint8_t tx_buf[ ] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88};

    flexcan_gpio_init();
    flexcan_clock_init();
    // flexcan_can_init(CAN2);
    // flexcan_freeze_enable(CAN2);
    // flexcan_freeze_disable(CAN2);
    flexcan_sample_bitRate_init(CAN2); // 注意，采样率和波特率要设置
    flexcan_loopback_enable(CAN2);

    flexcan_rx_MB_config(CAN2, RX_MB_INDEX, 0x233);

    int i, j;
    while(1) {
        for(i = 0; i < sizeof(tx_buf); i++) {
            // 回环测试的id，发送与接受一定要相同
            flexcan_send_data(CAN2, 0x233, tx_buf, i + 1); 
            uart_printf("flexcan send data ok\r\n");
            size = flexcan_recv_data(CAN2,0x233,rx_buf,sizeof(rx_buf));
            uart_printf("can rx: ");
            for(j = 0;j < size;j ++){
                uart_printf("%x ",rx_buf[j]);
            }
            uart_printf("\r\n");
            gpt_delay_ms(500);
        }
    }
}
```

#### 结果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5642a4ba79d940c1aa8c69a3544ac861.png)

### (2)CAN节点测试

#### 中断初始化

```c
void flexcan_interrupt_init(CAN_Type *base, int mb_index) {
    /*Enable flexcan interrupt*/
    if(mb_index < 32) {
        base->IMASK1 |= (1 << (mb_index));
    } else {
        base->IMASK2 |= (1 << (mb_index - 32));
    }
    /* 注册中断 */
    request_irq(CAN2_IRQn, flexcan_interrupt_handler);
    /* arm使能中断 */
    enable_irq();
}

/* 注意，此id是中断号，不是报文id */
int flexcan_interrupt_handler(int id) {
    int j, size;
    uint8_t rx_buf[8];

    /* 发送和接受到数据后，会产生中断，在中断函数中打印接收的数据 */
    size = flexcan_recv_data(CAN2, 0x120, rx_buf, sizeof(rx_buf));
    uart_printf("can rx:");
    for(j = 0;j < size;j ++){
        uart_printf("%x ",rx_buf[j]);
    }
    uart_printf("\r\n");
}
```

#### 测试代码

```c
void flexcan_normal_test() {
    int i;
    int j;
    uint8_t tx_buf[ ] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88};

    flexcan_gpio_init();
    flexcan_clock_init();
    flexcan_sample_bitRate_init(CAN2);
    flexcan_loopback_disable(CAN2);
    flexcan_interrupt_init(CAN2,RX_MB_INDEX);

    /*MB9 for rx*/
    flexcan_rx_MB_config(CAN2,RX_MB_INDEX,0x120);

    while(1){
        for(i = 0;i < sizeof(tx_buf);i ++){
            flexcan_send_data(CAN2,0x230,tx_buf,i + 1);
            // uart_printf("flexcan send data ok\r\n");
     
            gpt_delay_ms(1000);
        }
    }
}
```

#### 结果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2b3622b3289a4c60babb75dc1f0bd3f4.png)

## 9.完整代码

```c
#include"flexcan.h"

void flexcan_gpio_init() {
    //0010 ALT2 — FLEXCAN2_TX of instance
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO22 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO22 |=  (0x2 << 0);

    // 0010 ALT2 — FLEXCAN2_RX of instance
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO23 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO23 |=  (0x2 << 0);
}

void flexcan_clock_init() {
    // 1.[0] 0 pl3_main_clk: 480MHz
    CCM_CCSR &= ~(1 << 0);

    // 2.[9-8] 0b00 can_clk_sel: /8 = 60MHz
    //   [7-2] 0b000000 can_clk_podf: divide by 1: 60MHz
    CCM_CSCMR2 &= ~((0x3 << 8) | (0x3f << 2));

    // 3.enable can2 clock
    // [21-20] 11 can2_serial clock
    // [19-18] 11 can2 clock
    CCM_CCGR0 |= (0xf << 18);

}

void flexcan_can_init(CAN_Type *base) {
    /* 1.MDIS[31] 0 enable flexcan mode*/
    base->MCR &= ~(1 << 31);

    /*
     2.SOFT_RST[25] 1 Reset the registers
     it may take some time to fully propagate its effect,
     The SOFT_RST bit remains asserted while reset is pending, 
     and is automatically negated when reset completes.
    */
    base->MCR |= (1 << 25);
    while(base->MCR & (1 << 25)) {
        uart_printf("wait reset \r\n");
    }

    /*
     3.在进行一些can配置时，要求必须进入冻结模式，配置完后，再解除冻结模式
       FRZ[30] 1 Enabled to enter Freeze Mode
      HALT[28] 1 Enters Freeze Mode if the FRZ bit is asserted.
    */
    flexcan_freeze_enable(base);

    /*
     4.SRX_DIS [17] 1 Self reception disabled
    */
    base->MCR |= (1 << 17);

    /*
     5.MAXMB [6:0] Number of the last MB = MAXMB
    */
    base->MCR &= ~(0x7f << 0);
    base->MCR |=  (63 << 0); // 0-63

    /*
     6.配置完后，再解除冻结模式
     FRZ [30] 0 Not enabled to enter Freeze Mode
    HALT [28] 0 No Freeze Mode request.
    */
    flexcan_freeze_disable(base);
}

void flexcan_freeze_enable(CAN_Type *base) {
    /*
     在进行一些can配置时，要求必须进入冻结模式，配置完后，再解除冻结模式
       FRZ[30] 1 Enabled to enter Freeze Mode
      HALT[28] 1 Enters Freeze Mode if the FRZ bit is asserted.
    */
    base->MCR |= (1 << 28) | (1 << 30);
}

void flexcan_freeze_disable(CAN_Type *base) {
    /*
     配置完后，再解除冻结模式
     FRZ [30] 0 Not enabled to enter Freeze Mode
    HALT [28] 0 No Freeze Mode request.
    */
    base->MCR &= ~((1 << 30) | (1 << 28));
}

void flexcan_sample_bitRate_init(CAN_Type *base) {
    #if 0
    set CAN bit-rate 500000 = 500K,75% sample rate
    FLEXCAN_TIME_QUANTA_NUM = 1 + (PSEG1 + 1) + (PSEG2 + 1) + (PROPSEG + 1);
                            = 1 + (6 + 1) + (4 + 1) + (6 + 1)
                            = 20

    bit-rate = fTq/(number of Time Quanta)
       ->fTq = bit-rate * (number of Time Quanta)
             = 500000   * 20
             = 10000000 = 10MHz-->Tq = 0.1us

    fCANCLK  = 60MHZ
    fTq      = fCANCLK / (Prescaler value);
             = 60MHZ   / PV
            
        ->PV = 60MHZ/fTq = 60MHZ/10000000 = 6
    #endif
    
    /*1.控制器配置前，要先进入冻结模式,结束配置后，解冻
     FRZ  [30] 1 Enabled to enter Freeze Mode
     HALT [28] 1 Enters Freeze Mode if the FRZ bit is asserted.
    */
    flexcan_freeze_enable(base);

    /*2.控制器设置
     PRESDIV [31–24]  Sclock frequency = CPI clock frequency / (PRESDIV+1)
     RJW     [23–22]  Resync Jump Width = RJW + 1. 
                      The valid programmable values are 0-3.
                      通过对相位缓冲段加减`SJW`吸收误差。SJW加大后允许误差加大，但通信速度下降

     PSEG1   [21–19]  Phase Buffer Segment 1 = (PSEG1 + 1) x Time-Quanta.
                      The valid programmable values are 0-7

     PSEG2   [18–16]  Phase Buffer Segment 2 = (PSEG2 + 1) x Time-Quanta.
                      The valid programmable values are 1-7
     PROP_SEG [2-0 ]  Propagation Segment Time = (PROPSEG + 1) * Time-Quanta
                      The valid programmable values are 0-7                 
    */
    base->CTRL1 = (5 << 24) | (0 << 22) | (6 << 19) | (4 << 16) | (6 << 0);

    /*3.解冻 */
    flexcan_freeze_disable(base);
}

void flexcan_tx_MB_config(CAN_Type *base, mb_data_t *mb) {
    /* 1.先inactive,准备发送数据
     CODE [27:24] 0b1000: INACTIVE - MB is not active
    */
    base->MB[mb->index].CS = (0x8 << 24);

    /*2.发送id，size,数据
    DLC         [19:16] Length of Data in Bytes
    ID Standard [28:18]  Frame Identifier
   */
    base->MB[mb->index].CS |= (mb->size << 16);
    base->MB[mb->index].ID = (mb->id << 18);
    base->MB[mb->index].WORD0 = mb->word0;
    base->MB[mb->index].WORD1 = mb->word1;

    /*3.数据准备好后，进行Active MB,发送完成后，会触发中断标志位
    CODE [27:24] 0b1100: DATA -MB is a Tx Data Frame (MB RTR must be 0)
   */
    base->MB[mb->index].CS |= (0xc << 24);// 注意是|=,否则会清空前面的cs值
}

void flexcan_rx_MB_config(CAN_Type *base, int index, int id) {
    /*1.inactiveMB,准备接收数据
     CODE [27:24] 0b0000: INACTIVE - MB is not active.
    */
    base->MB[index].CS = 0;

    /*2.写入iD,接收指定ID的帧数据
    ID Standard [28:18]  Frame Identifier
    */
    base->MB[index].ID = (id << 18);
    base->MB[index].WORD0 = 0;
    base->MB[index].WORD1 = 0;

    /*3.Active MB，开始接收数据，接收成功后code会变为0010 full状态
    CODE [27:24] 0b0100: EMPTY - MB is active and empty.*/ 
    base->MB[index].CS |= (0x4 << 24);
}

void flexcan_send_data(CAN_Type *base, int id, uint8_t *buf, int size) {
    /*
    1.先准备要发送的数据，要以帧格式写入MB中
    word0 : DATA BYTE 0 |  DATA BYTE 1 |  DATA BYTE 2 | DATA BYTE 3
    word1 : DATA BYTE 4 |  DATA BYTE 5 |  DATA BYTE 6 | DATA BYTE 7
    */
    mb_data_t mb;
    mb.id = id;
    mb.size = size;
    mb.index = TX_MB_INDEX;
    uint32_t word0 = 0;
    uint32_t word1 = 0;
    int i,flag;
    if(size > 4) { // 要放入两个32位的内存中
        for(i = 0; i < 4; i++) { // 字节序大端模式，低字节放在高位
            word0 |= (buf[i] << (24 - i * 8));
        }
        for(i = 4; i < size; i++) {
            word1 |= (buf[i] << (24 - (i - 4) * 8));
        }
    } else {
        for(i = 0; i < size; i++) { // 字节序大端模式，低字节放在高位
            word0 |= (buf[i] << (24 - i * 8));
        }
    }
    mb.word0 = word0;
    mb.word1 = word1;

    /* 2.将准备好的数据写入MB中 */
    flexcan_tx_MB_config(base, &mb);

    /* 3.等待发送，直到发送完成，产生中断标志位（轮循方式判定），
         并非产生中断，要产生中断，需要设置mask寄存器
   [31-8] Each bit flags the respective MB(MB8 to MB31) interrupt
   1 responding MB has successfully completed transmission or reception*/
   do {
        flag = base->IFLAG1 & (1 << TX_MB_INDEX);
        // uart_printf("wait iflag1: ");
   } while(!flag);


   /* 4.发送完成后，要清除中断标志位，写1清除
   CPU must clear the corresponding IFLAG before starting to prepare this MB for a 	newtransmission or reception.
   The Interrupt flag must be cleared by writing it to '1'.*/
   base->IFLAG1 |= (1 << TX_MB_INDEX);
}

/* 在接收数据前，要先配置好MB,才能开始接收数据 */
int flexcan_recv_data(CAN_Type *base, int id, uint8_t *buf, int size) {
    /* 1.等待接收，直到接收完成，产生中断标志位（轮循方式判定）
   [31-8] Each bit flags the respective MB(MB8 to MB31) interrupt
   1 responding MB has successfully completed transmission or reception*/
    int flag, i;
    do {
        flag = base->IFLAG1 & (1 << RX_MB_INDEX);
        // uart_printf("wait reve iflag1: \r\n");
    } while(!flag);

   /*2.同时判断MB是否接收成功，full标志
    0b0010: FULL - MB is full.*/
    int code = (base->MB[RX_MB_INDEX].CS >> 24) & 0xf;
    if(code != 2) {
        uart_printf("Fail to flexcan recv data\r\n");
        return -1;
    }

    /* 3.接收成功后，进行处理数据（打印接收的字节）
    注意需求接收的字节数不能超高实际MB中的大小*/
    int rev_size = 0;
    rev_size = (base->MB[RX_MB_INDEX].CS >> 16) & 0xf;
    
    if(rev_size > size) {
        uart_printf("recv buf is too small\r\n");
        return -1;
    }
    int word0 = base->MB[RX_MB_INDEX].WORD0;
    int word1 = base->MB[RX_MB_INDEX].WORD1;
    /*
     word0 : DATA BYTE 0 |  DATA BYTE 1 |  DATA BYTE 2 | DATA BYTE 3
     word1 : DATA BYTE 4 |  DATA BYTE 5 |  DATA BYTE 6 | DATA BYTE 7
    */
    if(rev_size > 4) {
        for(i = 0; i < 4; i++) {
            buf[i] = word0 >> 24;
            word0  <<= 8;
        }
        for(i = 4; i < rev_size; i++) {
            buf[i] = word1 >> 24;
            word1  <<= 8;
        } 
    } else {
        for(i = 0; i < rev_size; i++) {
            buf[i] = word0 >> 24;
            word0 <<=  8;
        }
    }

    /* 4.清除中断位
   The Interrupt flag must be cleared by writing it to '1'.*/
    base->IFLAG1 |= (1 << RX_MB_INDEX);

    /* 5.重新配置接收MB,准备接收下一帧数据
   MB9 for rx*/
    flexcan_rx_MB_config(base, RX_MB_INDEX, id);

    return rev_size;
}

/* 回环测试 */
void flexcan_loopback_enable(CAN_Type *base) {
    /* 1.进入冻结模式，控制进行设置 */
    flexcan_freeze_enable(base);

    /* 2.回环模式开启 
    LPB  [12] 1 Loop Back enabled
              0 Loop Back disabled
    */
    base->CTRL1 |= (1 << 12);

    /* 3.解冻 */
    flexcan_freeze_disable(base);
}

void flexcan_loopback_disable(CAN_Type *base) {
    /* 1.进入冻结模式，控制进行设置 */
    flexcan_freeze_enable(base);

    /* 2.回环模式开启 
    LPB  [12] 1 Loop Back enabled
              0 Loop Back disabled
    */
    base->CTRL1 &= ~(1 << 12);

    /* 3.解冻 */
    flexcan_freeze_disable(base);
}

void flexcan_loopback_test() {
    int size = 0;
    uint8_t rx_buf[8];
    uint8_t tx_buf[ ] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88};

    flexcan_gpio_init();
    flexcan_clock_init();
    // flexcan_can_init(CAN2);
    // flexcan_freeze_enable(CAN2);
    // flexcan_freeze_disable(CAN2);
    flexcan_sample_bitRate_init(CAN2); // 注意，采样率和波特率要设置
    flexcan_loopback_enable(CAN2);

    flexcan_rx_MB_config(CAN2, RX_MB_INDEX, 0x233);

    int i, j;
    while(1) {
        for(i = 0; i < sizeof(tx_buf); i++) {
            // 回环测试的id，发送与接受一定要相同
            flexcan_send_data(CAN2, 0x233, tx_buf, i + 1); 
            uart_printf("flexcan send data ok\r\n");
            size = flexcan_recv_data(CAN2,0x233,rx_buf,sizeof(rx_buf));
            uart_printf("can rx: ");
            for(j = 0;j < size;j ++){
                uart_printf("%x ",rx_buf[j]);
            }
            uart_printf("\r\n");
            gpt_delay_ms(500);
        }
    }
}

/* 正常收发测试 */
void flexcan_interrupt_init(CAN_Type *base, int mb_index) {
    /*Enable flexcan interrupt*/
    if(mb_index < 32) {
        base->IMASK1 |= (1 << (mb_index));
    } else {
        base->IMASK2 |= (1 << (mb_index - 32));
    }
    /* 注册中断 */
    request_irq(CAN2_IRQn, flexcan_interrupt_handler);
    /* arm使能中断 */
    enable_irq();
}

/* 注意，此id是中断号，不是报文id */
int flexcan_interrupt_handler(int id) {
    int j, size;
    uint8_t rx_buf[8];

    /* 发送和接受到数据后，会产生中断，在中断函数中打印接收的数据 */
    size = flexcan_recv_data(CAN2, 0x120, rx_buf, sizeof(rx_buf));
    uart_printf("can rx:");
    for(j = 0;j < size;j ++){
        uart_printf("%x ",rx_buf[j]);
    }
    uart_printf("\r\n");
}

void flexcan_normal_test() {
    int i;
    int j;
    uint8_t tx_buf[ ] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88};

    flexcan_gpio_init();
    flexcan_clock_init();
    flexcan_sample_bitRate_init(CAN2);
    flexcan_loopback_disable(CAN2);
    flexcan_interrupt_init(CAN2,RX_MB_INDEX);

    /*MB9 for rx*/
    flexcan_rx_MB_config(CAN2,RX_MB_INDEX,0x120);

    while(1){
        for(i = 0;i < sizeof(tx_buf);i ++){
            flexcan_send_data(CAN2,0x230,tx_buf,i + 1);
            // uart_printf("flexcan send data ok\r\n");
     
            gpt_delay_ms(1000);
        }
    }
}
```

