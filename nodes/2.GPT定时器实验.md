# 1.定时器原理
![](https://img.mukewang.com/wiki/63e9d52108c55f5e07080381.jpg)
![](https://img.mukewang.com/wiki/63e9d57009fcc87708890713.jpg)
# 2.GPT操作与高精度延时实现
## 2.1 软件复位GPT定时器
> 软件复位（GPT_CR控制寄存器中的SWR位）复位除EN、ENMOD、STOPEN、WAITEN和DBGEN位之外的所有寄存器位。这些位的状态不受软件复位的影响。请注意，`在禁用GPT时,可以进行软件复位`。
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/5ced9379-2fb3-4fe1-b85c-2acbfab0c815)
- 注意：程序要判断是否复位成功，复位成功后，GPT_CR控制器的15位自动清0
  ```c
  /* 1.Reset GPT */
    GPT1->CR |= (1 << 15);
    while(GPT1->CR & (1 << 15)){}
  ```
## 2.2 确定GPT定时器的时钟源和工作模式
### 时钟源选定
![](https://img.mukewang.com/wiki/63e9d5b8099d413f08630338.jpg)
可以从 4 个时钟源中选择输入到预分频器的时钟，分别为：

- 高频参考时钟（ipg_clk_highfreq），
- 低频参考时钟（ipg_clk_32k），
- 外围时钟（ipg_clk）
- 外部时钟（GPT_CLK）或者晶体振荡器时钟（ipg_clk_24M）
> 外部时钟（GPT_CLK）或者晶体振荡器时钟（ipg_clk_24M）只能选择一个。
这里我们选择ipg_clk=66MHZ作为GPT定时器的输入时钟源，芯片在启动的时候，芯片内部的程序已经做了系统时钟初始化，初始化的时钟频率如下:
![](https://img.mukewang.com/wiki/63e9d5da08a5e4e907230372.jpg)

时钟源选择寄存器:
![](https://img.mukewang.com/wiki/63e9d60709a331ff08850672.jpg)

### 预分频器设定
![](https://img.mukewang.com/wiki/63e9d62209b92cf309030811.jpg)
### 工作模式设定
- Restart Mode:在重新启动模式下（可通过GPT控制寄存器GPT_CR选择），当计数器达到比较值时，计数器复位并从0x00000000再次启动。
- Free-Run Mode:在自由运行模式下，当所有3个通道发生比较事件时，计数器不会重置；相反，计数器继续计数，直到0xffffffff，然后滚动（到0x00000000）
![](https://img.mukewang.com/wiki/63e9d644093b398109010268.jpg)
## 2.3 确定比较寄存器的值(根据延时时间来确定)
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/94999826-74ab-401f-b4f6-e42446a778f3)
![](https://img.mukewang.com/wiki/63e9d7ed09d7943709010453.jpg)
- 选择GPTx_OCR1比较器，将比较事件写入到OF0状态寄存器中
## 2.4 开启GPT定时器
![](https://img.mukewang.com/wiki/63e9d68809cddf6008960624.jpg)
## 2.5 等待输出比较事件产生
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/f0c3c956-1ae5-4dc7-89d8-d3e01facff88)

![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/399441f2-b882-4b4a-89f5-4cb8aa23da22)

## 2.6 关闭GPT定时器

# 3.代码展示
```c
#include"imx6ull.h"
#include"led.h"
#include"gpt.h"

void gpt_init() {
    /* 1.Reset GPT */
    GPT1->CR |= (1 << 15);
    while(GPT1->CR & (1 << 15)){}

    /* 2.Select Clock:IPG(66MHZ) */
    GPT1->CR &= ~(0x7 << 6);
    GPT1->CR |=  (0x1 << 6);

    /* 3.Select mode :Free-Run or Restart */
    GPT1->CR |= (1 << 9);

    /* 4.Select Prescaler:65:1MHZ-->1us 增加一次*/
    GPT1->PR = 65;
}

void gpt_delay_us(uint32_t us) {
    gpt_init();
    /* 5.GPT Output Compare value:depandens delay time*/
    GPT1->OCR1 = us;

    /* 6.start gpt */
    gpt_start();
    /* 7.wait output compare event occur */
    wait_cmp_event();
    /* 8.stop gpt */
    gpt_stop();
}
void gpt_delay_ms(uint32_t ms) {
    gpt_delay_us(ms * 1000);
}
void gpt_delay_sec(uint32_t sec) {
    gpt_delay_ms(sec * 1000);
}
void gpt_start() {
    GPT1->CR |= (1 << 0) | (1 << 1);
}

void gpt_stop() {
    GPT1->CR &= ~(1 << 1);
}

void wait_cmp_event() {
    int flag = 0;
    while(!flag) {
        flag = GPT1->SR & (1 << 0);
    }
}

void gpt_test() {
    led_init();

    while(1) {
        led_on();
        gpt_delay_ms(500);

        led_off();
        gpt_delay_ms(500);
    }
}


```
# 4.效果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ae63afdf8ec44d10acfc7628a4c23248.gif)
