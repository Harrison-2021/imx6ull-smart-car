# 1.定时器原理

![](https://img-blog.csdnimg.cn/img_convert/96fac2f6e2b3fc07963c10a6e6422ee2.jpeg)
![](https://img-blog.csdnimg.cn/img_convert/867501c3d837b8dd5e179ccce1c1bcf5.png)

# 2.GPT操作与高精度延时实现

## 2.1 软件复位GPT定时器

> 软件复位（GPT_CR控制寄存器中的SWR位）复位除EN、ENMOD、STOPEN、WAITEN和DBGEN位之外的所有寄存器位。这些位的状态不受软件复位的影响。请注意，`在禁用GPT时,可以进行软件复位`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6c1df4ed01c1484990c209e3757bbe96.png)


- 注意：==程序要判断是否复位成功，复位成功后，GPT_CR控制器的15位自动清0==

  ```c
  /* 1.Reset GPT */
    GPT1->CR |= (1 << 15);
    while(GPT1->CR & (1 << 15)){}
  ```

## 2.2 确定GPT定时器的时钟源和工作模式

### 时钟源选定

![](https://img-blog.csdnimg.cn/img_convert/ded629e0a82d3649ba81ee7aad31bce7.png)
可以从 4 个时钟源中选择输入到预分频器的时钟，分别为：

- 高频参考时钟（`ipg_clk_highfreq`），
- 低频参考时钟（`ipg_clk_32k`），
- 外围时钟（`ipg_clk`）
- 外部时钟（`GPT_CLK`）或者晶体振荡器时钟（`ipg_clk_24M`）

> 外部时钟（GPT_CLK）或者晶体振荡器时钟（ipg_clk_24M）只能选择一个。
> 这里我们选择==ipg_clk=66MHZ==作为GPT定时器的输入时钟源，芯片在启动的时候，芯片内部的程序已经做了系统时钟初始化，初始化的时钟频率如下:

![](https://img-blog.csdnimg.cn/img_convert/a27d4f0274c780275486bdbcb91c7182.jpeg)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c2e4631f55f24485908d267ff9575e04.png)

```c
/* 2.Select Clock:IPG(66MHZ) */
    GPT1->CR &= ~(0x7 << 6);
    GPT1->CR |=  (0x1 << 6);
```

### 预分频器设定

![](https://img-blog.csdnimg.cn/img_convert/7e21cce50ac10f594e6ef74ca1a4e116.png)

```c
/* 4.Select Prescaler:65:1MHZ-->1us 增加一次*/
    GPT1->PR = 65;
```

### 工作模式设定

- `Restart Mode`:在**重新启动模式**下（可通过GPT控制寄存器`GPT_CR`选择），==当计数器达到比较值时，计数器复位并从0x00000000再次启动==。

  - > 重新启动功能**仅与比较通道1相关联**。对通道1的比较寄存器的任何写访问都将重置GPT计数器。
    >
    > 这样做是为了避免在计数进行时比较值从较高值更改为较低值时可能丢失比较事件。对于其他两个比较通道，当比较事件发生时，计数器不会重置。

- `Free-Run Mode`:在**自由运行模式**下，==当所有3个通道发生比较事件时，计数器不会重置；相反，计数器继续计数，直到0xffffffff，然后滚动（到0x00000000）==
  ![](https://img-blog.csdnimg.cn/img_convert/883ffd76a68082d9052ff1e3e25553b0.png)

- > 注意：
  >
  > 1.设置成重启模式，通道1可以发生比较事件，进行重置，**但对其它通道没有作用，故，一般设置为自由模式**
  >
  > 2.设置自由模式后，要设置设置`ENMOD`为1,并每次比较事件后，关闭定时器，设置`EN`为0,**使能模式下会自动重置**
  >
  > ```c
  >  /* 3.Select mode :Free-Run or Restart */
  > GPT1->CR |= (1 << 9)； //  设置ENMOD为1时，GPT counter value is reset to 0 when it is disabled
  > ```
  >
  > 3.**故操作时序是：使能开启定时器->等待计数器到达比较器中设置的值->关闭定时器**
  >
  > ```c
  > 
  >     /* 6.start gpt */
  >     gpt_start();
  >     /* 7.wait output compare event occur */
  >     wait_cmp_event();
  >     /* 8.stop gpt */
  >     gpt_stop();
  > ```
  >
  > 
  >
  > ![](https://img-blog.csdnimg.cn/img_convert/bf80ce1c99d028f75859d5c4ea28c242.png)



## 2.3 确定比较寄存器的值(根据延时时间来确定)
![](https://img-blog.csdnimg.cn/img_convert/e87955b66dfe4dcf7ae0060315054baf.png)

- 选择GPTx_OCR1比较器，将比较事件写入到OF0状态寄存器中

  ```c
  /* 5.GPT Output Compare value:depandens delay time*/
      GPT1->OCR1 = us; // us，用户传入的时间
  ```

  

## 2.4 开启GPT定时器

![](https://img-blog.csdnimg.cn/img_convert/bf80ce1c99d028f75859d5c4ea28c242.png)

```c
void gpt_start() {
    GPT1->CR |= (1 << 0) | (1 << 1); // 设置ENMOD为1时，GPT counter value is reset to 0 when it is disabled
}
```



## 2.5 等待输出比较事件产生

![图片描述](https://img.mukewang.com/wiki/63e9d77809384e2e08990266.jpg)

![图片描述](https://img.mukewang.com/wiki/63e9d74c096a664f08940545.jpg)

>
>
>本例程**选择通道1**，因此，发生通道1 的比较事件后，会在状态寄存器中，将`SR`寄存器对应位设置为`1`
>
>```c
>void wait_cmp_event() {
>    int flag = 0;
>    while(!flag) {
>        flag = GPT1->SR & (1 << 0);
>    }
>}
>```
>
>

## 2.6 关闭GPT定时器

![](https://img-blog.csdnimg.cn/img_convert/bf80ce1c99d028f75859d5c4ea28c242.png)

```c
void gpt_stop() {
    GPT1->CR &= ~(1 << 0); // 使能位，不是1位
}
```



# 3.代码展示

```c
#include"imx6ull.h"
#include"led.h"
#include"gpt.h"

void gpt_init() {
    /* 1.Reset GPT */
    GPT1->CR |= (1 << 15);
    while(GPT1->CR & (1 << 15)){}

    /* 2.Select Clock:IPG(66MHZ) */
    GPT1->CR &= ~(0x7 << 6);
    GPT1->CR |=  (0x1 << 6);

    /* 3.Select mode :Free-Run or Restart */
    GPT1->CR |= (1 << 9)； //  设置ENMOD为1时，GPT counter value is reset to 0 when it is disabled
        
    /* 4.Select Prescaler:65:1MHZ-->1us 增加一次*/
    GPT1->PR = 65;
}

void gpt_delay_us(uint32_t us) {
    gpt_init();
    /* 5.GPT Output Compare value:depandens delay time*/
    GPT1->OCR1 = us;

    /* 6.start gpt */
    gpt_start();
    /* 7.wait output compare event occur */
    wait_cmp_event();
    /* 8.stop gpt */
    gpt_stop();
}
void gpt_delay_ms(uint32_t ms) {
    gpt_delay_us(ms * 1000);
}
void gpt_delay_sec(uint32_t sec) {
    gpt_delay_ms(sec * 1000);
}
void gpt_start() {
    GPT1->CR |= (1 << 0) | (1 << 1);
}

void gpt_stop() {
    GPT1->CR &= ~(1 << 0); // 使能位，不是1位
}

void wait_cmp_event() {
    int flag = 0;
    while(!flag) {
        flag = GPT1->SR & (1 << 0);
    }
}

void gpt_test() {
    led_init();

    while(1) {
        led_on();
        gpt_delay_ms(500);

        led_off();
        gpt_delay_ms(500);
    }
}


```

# 4.效果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ae63afdf8ec44d10acfc7628a4c23248.gif)
