# 1.定时器原理

![](https://img-blog.csdnimg.cn/img_convert/96fac2f6e2b3fc07963c10a6e6422ee2.jpeg)
![](https://img-blog.csdnimg.cn/img_convert/867501c3d837b8dd5e179ccce1c1bcf5.png)

# 2.GPT操作与高精度延时实现

## 2.1 软件复位GPT定时器

> 软件复位（GPT_CR控制寄存器中的SWR位）复位除EN、ENMOD、STOPEN、WAITEN和DBGEN位之外的所有寄存器位。这些位的状态不受软件复位的影响。请注意，`在禁用GPT时,可以进行软件复位`。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6c1df4ed01c1484990c209e3757bbe96.png)


- 注意：==程序要判断是否复位成功，复位成功后，GPT_CR控制器的15位自动清0==

  ```c
  /* 1.Reset GPT */
    GPT1->CR |= (1 << 15);
    while(GPT1->CR & (1 << 15)){}
  ```

## 2.2 确定GPT定时器的时钟源和工作模式

### 时钟源选定

![](https://img-blog.csdnimg.cn/img_convert/ded629e0a82d3649ba81ee7aad31bce7.png)
可以从 4 个时钟源中选择输入到预分频器的时钟，分别为：

- 高频参考时钟（`ipg_clk_highfreq`），
- 低频参考时钟（`ipg_clk_32k`），
- 外围时钟（`ipg_clk`）
- 外部时钟（`GPT_CLK`）或者晶体振荡器时钟（`ipg_clk_24M`）

> 外部时钟（GPT_CLK）或者晶体振荡器时钟（ipg_clk_24M）只能选择一个。
> 这里我们选择==ipg_clk=66MHZ==作为GPT定时器的输入时钟源，芯片在启动的时候，芯片内部的程序已经做了系统时钟初始化，初始化的时钟频率如下:

![](https://img-blog.csdnimg.cn/img_convert/a27d4f0274c780275486bdbcb91c7182.jpeg)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c2e4631f55f24485908d267ff9575e04.png)

```c
/* 2.Select Clock:IPG(66MHZ) */
    GPT1->CR &= ~(0x7 << 6);
    GPT1->CR |=  (0x1 << 6);
```

### 预分频器设定

![](https://img-blog.csdnimg.cn/img_convert/7e21cce50ac10f594e6ef74ca1a4e116.png)

```c
/* 4.Select Prescaler:65:1MHZ-->1us 增加一次*/
    GPT1->PR = 65;
```

### 工作模式设定

- `Restart Mode`:在**重新启动模式**下（可通过GPT控制寄存器`GPT_CR`选择），==当计数器达到比较值时，计数器复位并从0x00000000再次启动==。
- `Free-Run Mode`:在**自由运行模式**下，==当所有3个通道发生比较事件时，计数器不会重置；相反，计数器继续计数，直到0xffffffff，然后滚动（到0x00000000）==
  ![](https://img-blog.csdnimg.cn/img_convert/883ffd76a68082d9052ff1e3e25553b0.png)

```c
 /* 3.Select mode :Free-Run or Restart */
    GPT1->CR &= ~(1 << 9); // 要设置成重启模式，否则比较计时器没有效果了
```

## 2.3 确定比较寄存器的值(根据延时时间来确定)
![](https://img-blog.csdnimg.cn/img_convert/e87955b66dfe4dcf7ae0060315054baf.png)

- 选择GPTx_OCR1比较器，将比较事件写入到OF0状态寄存器中

## 2.4 开启GPT定时器

![](https://img-blog.csdnimg.cn/img_convert/bf80ce1c99d028f75859d5c4ea28c242.png)

## 2.5 等待输出比较事件产生



## 2.6 关闭GPT定时器

# 3.代码展示

```c
#include"imx6ull.h"
#include"led.h"
#include"gpt.h"

void gpt_init() {
    /* 1.Reset GPT */
    GPT1->CR |= (1 << 15);
    while(GPT1->CR & (1 << 15)){}

    /* 2.Select Clock:IPG(66MHZ) */
    GPT1->CR &= ~(0x7 << 6);
    GPT1->CR |=  (0x1 << 6);

    /* 3.Select mode :Free-Run or Restart */
    GPT1->CR &= ~(1 << 9); // 要设置成重启模式，否则比较计时器没有效果了

    /* 4.Select Prescaler:65:1MHZ-->1us 增加一次*/
    GPT1->PR = 65;
}

void gpt_delay_us(uint32_t us) {
    gpt_init();
    /* 5.GPT Output Compare value:depandens delay time*/
    GPT1->OCR1 = us;

    /* 6.start gpt */
    gpt_start();
    /* 7.wait output compare event occur */
    wait_cmp_event();
    /* 8.stop gpt */
    gpt_stop();
}
void gpt_delay_ms(uint32_t ms) {
    gpt_delay_us(ms * 1000);
}
void gpt_delay_sec(uint32_t sec) {
    gpt_delay_ms(sec * 1000);
}
void gpt_start() {
    GPT1->CR |= (1 << 0) | (1 << 1);
}

void gpt_stop() {
    GPT1->CR &= ~(1 << 1);
}

void wait_cmp_event() {
    int flag = 0;
    while(!flag) {
        flag = GPT1->SR & (1 << 0);
    }
}

void gpt_test() {
    led_init();

    while(1) {
        led_on();
        gpt_delay_ms(500);

        led_off();
        gpt_delay_ms(500);
    }
}


```

# 4.效果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ae63afdf8ec44d10acfc7628a4c23248.gif)
