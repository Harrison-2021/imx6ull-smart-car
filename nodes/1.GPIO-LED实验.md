# 1. LED灯闪烁实验
## 1.1 LED原理图分析
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/4f158adf-524f-476a-b1bd-eb64cc798105)
- 由于mos管的出现，1处电平为高电平时，mos管导通，LED点亮
- 即，**让UART3_RTS输出高低电平来控制LED灯亮灭**
- ![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/ae49e627-85b9-4e1b-80c8-84b0974238d5)
- 找到UART3_RTS管脚所在的GPIO引脚位置：IO27
  ![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/3096fda2-f976-4902-ac84-11d224e7fff2)
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/3220ce9a-4abf-4f4e-b1b2-9c33e8bac3aa)

## 1.2 GPIO操作思路
### 1.2.1 设置IOMUXC控制器将管脚复用为GPIO功能模式
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/6e92dd92-cbce-4886-b6d2-03534ce37759)
- 找到UART3_RTS管脚的GPIO复用寄存器
- 命名形式:**IOMUXC_SW_MUC_CTL_PAD_XX_XX**，后面的“XX_XX”就是 GPIO 命名
- 在`imx6ull.h`头文件中定义好复用寄存器的地址
```c
#define IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 *((volatile unsigned int *)0x20E00B0)
```
### 1.2.2 设置GPIO管脚的电器属性(可选)
![image](https://img.mukewang.com/wiki/63e626cc09526a7108691556.jpg)
### 1.2.3 设置GPIO管脚为输出方向
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/48b22df0-c86e-4f9c-9b54-745c889250dc)
- 通过GPIO1_GDIR寄存器，设置输入输出方向
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/9d77bc10-5e47-4b8f-983c-9ad9a70b820a)
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/4863dd6a-1b0d-4ed4-9071-3bca84a7918a)
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/f8db84e4-c491-400e-b5be-969e3a1f481a)

### 1.2.4 打开GPIO管脚的时钟信号(可选)
- 任何一个外设如果想正常工作，都必须打开它的时钟开关。CCM（Clock Controller Module）时钟控制模块寄存器用来使能外设时钟。 CMM一共有CCM_CCGR0~CCM_CCGR6这 7 个寄存器，控制着I.MX6ULL的所有外设时钟开关。
- ![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/708d4b3a-5870-46f5-9d51-1678efe7465f)
- - 本实验使用CCGR1时钟控制模块寄存器，默认是使能状态
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/fb819b14-e9ed-490a-b0af-8b3b1799b70f)
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/2e422800-356f-4ab9-a693-15172603a8e3)

### 1.2.5 设置GPIO管脚输出高电平与低电平
- 通过设置io的第27位，1，为高输出，0，为输入
![image](https://github.com/Harrison-2021/imx6ull-smart-car/assets/77105239/eca1c15c-1f48-4bf1-8794-c9bf8059416a)

## 1.3 代码实现
### makefile编写与链接文件编写
#### makefile
```c
CROSS_COMPILE=arm-linux-gnueabihf-
CC=$(CROSS_COMPILE)gcc --std=c99
LD=$(CROSS_COMPILE)ld
OBJCOPY=$(CROSS_COMPILE)objcopy #格式转换工具

APP = imx6ull.elf
BIN = imx6ull.bin #不带操作系统，elf头没用，将elf头去掉

SRC      = $(shell find driver  -name "*.c")
OBJS     = $(patsubst %.c,%.o,$(SRC))
OBJS    += start/start.o
OBJS    += main.o

INCLUDE  = -I include
CFLAGS   = -c
LDFLAGS  =  -static  -L ./lib -lgcc

all:$(OBJS) 
	$(LD) -Timx6ull.lds -Ttext=0x87800000 $(OBJS) -o $(APP) $(LDFLAGS)
	$(OBJCOPY) -O binary $(APP) $(BIN) 

%.o:%.c
	$(CC) $(CFLAGS) $< -o $@ $(INCLUDE)

%.o:%.S
	$(CC) $(CFLAGS) $< -o $@ $(INCLUDE)

clean:
	rm -rf $(OBJS)

distclean:
	rm -rf $(OBJS) $(APP) $(BIN)

```
#### arm汇编
```bash
.global _start

_start:
    b reset
	ldr pc,_undefined_instruction
	ldr pc,_software_interrupt  @B   software_interrupt
	ldr pc,_prefetch_abort
	ldr pc,_data_abort
	ldr pc,_not_used
	ldr pc,_irq
	ldr pc,_fiq
_undefined_instruction:.word _undefined_instruction
_software_interrupt:.word software_interrupt
_prefetch_abort:.word _prefetch_abort
_data_abort:.word _data_abort
_not_used:.word _not_used
_irq:.word irq
_fiq:.word _fiq

reset:
    @告诉ARM核异常向量表所在的基地址
	adr r0,_start @获得异常向量表所在的地址
	mcr p15,0,r0,c12, c0, 0 @将异常向量表的基基地址写入cp15.c12

    ldr sp,=0x87800000
    bl  main

stop:
    b stop

software_interrupt:
	ldr sp,=0x81000000
	stmfd sp!,{r0-r12,lr}

	ldr r0,[lr,#-4]
	mov r1,#0xff
	bic r0,r0,r1,lsl #24

	ldmfd sp!,{r0-r12,pc}^

irq:
	ldr sp,=0x82000000
	sub lr,lr,#4
	stmfd sp!,{r0-r12,lr}

	@bl do_irq

	ldmfd sp!,{r0-r12,pc}^

```
#### 链接配置文件
- 链接配置文件，指明程序段先从自定义的_start处开始执行（先指明ARM核异常向量表基地址位置）
```c
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
 . = 0x00000000;
 . = ALIGN(4);
 .text :
 {
  start/start.o
  *(.text*)
 }
 . = ALIGN(4);
 .rodata : { *(.rodata*) }
 . = ALIGN(4);
 .data : {*(.data*)}
 . = ALIGN(4);
 __bss_start = .;
 .bss ALIGN(4) : { *(.bss)}
 __bss_end = .;

PROVIDE_HIDDEN (__exidx_start = .);
.ARM.exidx   : { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
PROVIDE_HIDDEN (__exidx_end = .);
}

```
### 主体代码lec.c
```c
#include"imx6ull.h"
#include"led.h"

void led_init(void) {
    /* 1.GPIO MODE */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 |=  (0x5 << 0);

    /* 2.Direction:Output */
    GPIO1->GDIR |= (1 << 27);

    /* 3.Enable GPIO Clock */
    CCM_CCGR1 |= (0x3 << 26);
}

void led_on(void) {
    /* 4.1 Outpur high level */
    GPIO1->DR |= (1 << 27);
}

void led_off(void) {
    /* 4.2 Output low level */
    GPIO1->DR &= ~(1 << 27);
}

void delay_time(uint32_t time) {
    for(int i = 0; i < 1000*time; i++) {
        for(int j = 0; j < 50000; j++){}
    }
}

void led_test(void) {
    led_init(); // 一定要注意()不要忘记写了
    
    while(1) {
        led_on();
        delay_time(1);
        led_off();
        delay_time(1);
    }

}
```
1.4 编译运行结果展示
- 使用ckermit软件进行开发板与linux系统的通讯，将编译的执行文件发送到开发板上
