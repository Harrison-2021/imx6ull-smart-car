# 1. LED灯闪烁实验

## 1.1 LED原理图分析

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/046f334c29074b2f942080d946adf634.png)


- 由于mos管的出现，1处电平为高电平时，mos管导通，LED点亮
- 即，**让UART3_RTS输出高低电平来控制LED灯亮灭**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1302bacec10a425b8d07dcace2926cac.png)

- 找到UART3_RTS管脚所在的GPIO引脚位置：IO27
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9df2813f652d46d89f51ed5b3a98b3a6.png)
## 1.2 GPIO介绍
- The `GPIO` general-purpose input/output `peripheral` provides `dedicated` general-purpose
`pins` that can be configured as either inputs or outputs.
	- >GPIO 全称为通用用途输入/输出,为外设提供专用的通用用途的管脚，可以配置为输入或输出。

- When configured as an `output`, it is possible to write to an `internal register` to `control the
	state driven` on the output pin.
	- >当配置为输出时，可以通过向其内部寄存器写值来控制管脚输出的电平状态
- When configured as an `input`, it is possible to `detect the state of the input` by reading the state of an internal register.
	- >当配置为输入时，可以通过读取内部寄存器的状态来检测输入的状态。
- In addition, the GPIO Peripheral can produce `CORE interrupts`
	- >此外，GPIO外设可以产生CORE中断
	  >
	  >![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4002b794f8e548eb91efedbec47dc479.png)
## 1.3 I.MX6ull GPIO介绍
- i.MX6ULL芯片的GPIO被分成 5 组, 并且每组GPIO的数量不尽相同
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2e8f17aa3775413c906f7af34e2878c0.png)
### 1.设计介绍
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8a70895bbfc04ee8adde727da07b59da.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/be468cdfc58f474283f3d8033eb9c814.png)
> `IOMUXC`:io mux controller 
> `SW_MUX`:software mux control
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5ff669d104e0406387885f9fd4c9a081.png)
> Pin指芯片封装好后的管脚，即用户能够看到的管脚，PAD是硅片的管脚，是封装在芯片内部的，用户看不到。PAD到PIN之间还有一段导线连接的。
### 2.IO管脚复用功能配置
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4e4045779e00499b8510b12ff3fbf717.png)
 - 命名形式:**IOMUXC_SW_MUC_CTL_PAD_XX_XX**，后面的“XX_XX”就是 GPIO 命名
	- >GPIO1_IO01
	>UART1_TX_DATA
	>JTAG_MOD
	>其他
	>![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5aa7fae2ed4c46a99aec080ba8481694.png)
### 3.IO管脚电器属性配置
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/996bcdbc09d544f28395ed3236f6d12f.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fbb5c34bfc8c4e0188b9269178b8bf7c.png)
### 4.IO管脚配置
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d750f52880624d7f825fc45cc4ab6672.png)
#### (1)GPIO direction register (`GPIOx_GDIR`)
- GPIO_GDIR functions as `direction control` when the IOMUXC is in GPIO mode. 
- Each bit specifies the direction of a `one-bit signal`. 
- The `mapping` of each **DIR bit to a corresponding SoC signal** is determined by the SoC’s pin assignment and the IOMUX table.
	- >GPIO_GDIR在IOMUXC处于GPIO模式时起到方向控制的作用。每个位指定一个位信号的方向。每个DIR位到相应SoC信号的映射由SoC的引脚分配和IOMUX表决定。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b01bd30bcab1459ea65cc8089d5c83b7.png)

#### (2)GPIO data register (`GPIOx_DR`)
- The `32-bit GPIO_DR` register `stores data` that is ready to be `driven to the output lines`. 
- If the IOMUXC is in GPIO mode and a given GPIO direction bit is set, then the `corresponding DR bit` is driven to the output. 
- If a given GPIO direction bit is `cleared`, then a `read` of GPIO_DR reflects the value of the corresponding signal.
	- >32位GPIO_DR寄存器存储准备驱动到输出线的数据。如果IOMUXC处于GPIO模式并且设置了给定的GPIO方向位，则将相应的DR位驱动到输出。如果给定的GPIO方向位被清除，则GPIO_DR的读取反映相应信号的值

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b3fa1b67165f454ebee62d8bea7f5821.png)

#### (3)GPIO pad status register (`GPIOx_PSR`)
- GPIO_PSR is a `read-only register.` 
- `Each bit` stores the value of the corresponding input signal (as configured in the IOMUX).
	- >GPIO_PSR是只读寄存器。每个位存储相应输入信号的值（如IOMUX中配置的）。
	

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2e1cecc77c4e4f21a3af8109313d2cd8.png)

### 5. 时钟源
- 任何一个外设如果想正常工作，都必须打开它的时钟开关。
- ·CCM·（Clock Controller Module）==时钟控制模块寄存器用来使能外设时钟==。 
- CMM一共有`CCM_CCGR0~CCM_CCGR6`这 `7 `个寄存器，控制着**I.MX6ULL的所有外设时钟开关。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7d7df524589849049faa7bccf505f21b.png)
这里以GPIO1为例讲解:
- These bits are used to `turn on/off the clock` to each module independently. The following table details the possible clock activity conditions for each module.
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2abc45dee19a49c0b793b3227eea50e7.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f28622653b95498abca514a4e3ca8d13.png)


## 1.4 GPIO操作思路

### 1 设置IOMUXC控制器将管脚复用为GPIO功能模式
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6d55967c20a543af81ee9b72740dbfb3.png)



- 找到UART3_RTS管脚的GPIO复用寄存器
- 命名形式:**IOMUXC_SW_MUC_CTL_PAD_XX_XX**，后面的“XX_XX”就是 GPIO 命名
- 在`imx6ull.h`头文件中定义好复用寄存器的地址

```c
#define IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 *((volatile unsigned int *)0x20E00B0)
```

```c
/* 1.GPIO MODE */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 |=  (0x5 << 0);
```

### 2 设置GPIO管脚的电器属性(可选)

![image](https://img-blog.csdnimg.cn/img_convert/e0cfb8b8128c8c2ed0698fdf062fec1a.png)

### 3 设置GPIO管脚为输出方向
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f73eeb89a3aa4d1293dc4624143e7aec.png)

```c
/* 2.Direction:Output */
    GPIO1->GDIR |= (1 << 27);
```

### 4 打开GPIO管脚的时钟信号(可选)

- 任何一个外设如果想正常工作，都必须打开它的时钟开关。CCM（Clock Controller Module）时钟控制模块寄存器用来使能外设时钟。 CMM一共有CCM_CCGR0~CCM_CCGR6这 7 个寄存器，控制着I.MX6ULL的所有外设时钟开关。
- 本实验使用CCGR1时钟控制模块寄存器，默认是使能状态
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7d7df524589849049faa7bccf505f21b.png)
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f28622653b95498abca514a4e3ca8d13.png)
```c
/* 3.Enable GPIO Clock */
    CCM_CCGR1 |= (0x3 << 26);
```

### 5 设置GPIO管脚输出高电平与低电平

- 通过设置io的第27位，==1，为高电平，0，为低电平==
  

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b3fa1b67165f454ebee62d8bea7f5821.png)
```c
void led_on(void) {
    /* 4.1 Outpur high level */
    GPIO1->DR |= (1 << 27);
}

void led_off(void) {
    /* 4.2 Output low level */
    GPIO1->DR &= ~(1 << 27);
}
```

## 1.5 代码实现

### makefile编写与链接文件编写

#### makefile

```makefile
CROSS_COMPILE=arm-linux-gnueabihf-
CC=$(CROSS_COMPILE)gcc --std=c99
LD=$(CROSS_COMPILE)ld
OBJCOPY=$(CROSS_COMPILE)objcopy #格式转换工具

APP = imx6ull.elf
BIN = imx6ull.bin #不带操作系统，elf头没用，将elf头去掉

SRC      = $(shell find driver  -name "*.c")
OBJS     = $(patsubst %.c,%.o,$(SRC))
OBJS    += start/start.o
OBJS    += main.o

INCLUDE  = -I include
CFLAGS   = -c
LDFLAGS  =  -static  -L ./lib -lgcc

all:$(OBJS) 
	$(LD) -Timx6ull.lds -Ttext=0x87800000 $(OBJS) -o $(APP) $(LDFLAGS)
	$(OBJCOPY) -O binary $(APP) $(BIN) 

%.o:%.c
	$(CC) $(CFLAGS) $< -o $@ $(INCLUDE)

%.o:%.S
	$(CC) $(CFLAGS) $< -o $@ $(INCLUDE)

clean:
	rm -rf $(OBJS)

distclean:
	rm -rf $(OBJS) $(APP) $(BIN)

```

#### arm汇编

```bash
.global _start

_start:
    b reset
	ldr pc,_undefined_instruction
	ldr pc,_software_interrupt  @B   software_interrupt
	ldr pc,_prefetch_abort
	ldr pc,_data_abort
	ldr pc,_not_used
	ldr pc,_irq
	ldr pc,_fiq
_undefined_instruction:.word _undefined_instruction
_software_interrupt:.word software_interrupt
_prefetch_abort:.word _prefetch_abort
_data_abort:.word _data_abort
_not_used:.word _not_used
_irq:.word irq
_fiq:.word _fiq

reset:
    @告诉ARM核异常向量表所在的基地址
	adr r0,_start @获得异常向量表所在的地址
	mcr p15,0,r0,c12, c0, 0 @将异常向量表的基基地址写入cp15.c12

    ldr sp,=0x87800000
    bl  main

stop:
    b stop

software_interrupt:
	ldr sp,=0x81000000
	stmfd sp!,{r0-r12,lr}

	ldr r0,[lr,#-4]
	mov r1,#0xff
	bic r0,r0,r1,lsl #24

	ldmfd sp!,{r0-r12,pc}^

irq:
	ldr sp,=0x82000000
	sub lr,lr,#4
	stmfd sp!,{r0-r12,lr}

	@bl do_irq

	ldmfd sp!,{r0-r12,pc}^

```

#### 链接配置文件

- 链接配置文件，指明程序段先从自定义的_start处开始执行（先指明ARM核异常向量表基地址位置）

```c
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
 . = 0x00000000;
 . = ALIGN(4);
 .text :
 {
  start/start.o
  *(.text*)
 }
 . = ALIGN(4);
 .rodata : { *(.rodata*) }
 . = ALIGN(4);
 .data : {*(.data*)}
 . = ALIGN(4);
 __bss_start = .;
 .bss ALIGN(4) : { *(.bss)}
 __bss_end = .;

PROVIDE_HIDDEN (__exidx_start = .);
.ARM.exidx   : { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
PROVIDE_HIDDEN (__exidx_end = .);
}

```

### 主体代码lec.c

```c
#include"imx6ull.h"
#include"led.h"

void led_init(void) {
    /* 1.GPIO MODE */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO27 |=  (0x5 << 0);

    /* 2.Direction:Output */
    GPIO1->GDIR |= (1 << 27);

    /* 3.Enable GPIO Clock */
    CCM_CCGR1 |= (0x3 << 26);
}

void led_on(void) {
    /* 4.1 Outpur high level */
    GPIO1->DR |= (1 << 27);
}

void led_off(void) {
    /* 4.2 Output low level */
    GPIO1->DR &= ~(1 << 27);
}

void delay_time(uint32_t time) {
    for(int i = 0; i < 1000*time; i++) {
        for(int j = 0; j < 50000; j++){}
    }
}

void led_test(void) {
    led_init(); // 一定要注意()不要忘记写了
    
    while(1) {
        led_on();
        delay_time(1);
        led_off();
        delay_time(1);
    }

}
```

# 2. 按键控制LED灯实验

## 2.1 按键原理图分析

![](https://img-blog.csdnimg.cn/img_convert/752d137e28a16b5538b0a9bc46489df4.png)

- 当按键没有按下，断开时，UART3_CTS管脚电平为高电平，上拉电阻
- **读取UART3_CTS管脚电平状态来控制LED10灯亮灭**,按键按下的时候灯亮，按键抬起的时候灯灭。

## 2.2 寄存器分析与编程思路

- 与UART3_RTS同为IGPT管脚，同样在芯片手册中找到对应IGPT管脚位置，对相关寄存器进行设置
- 设置管脚为GPIO功能模式
- 配置管脚的电器属性(可选)
- **设置管脚的GPIO方向为输入方向：输入**
- 打开管脚的时钟信号
- **读取管脚的电平状态**(GPIO1组的第26个管脚电平状态)
- 根据管脚电平状态，控制LED(低电平则LED灯亮,高电平则LED灯灭)

## 2.3 代码实现

```c
#include"imx6ull.h"
#include"led.h"

void key_init() {
    /* 1.GPIO Mode */
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO26 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO26 |=  (0x5 << 0);

    /* 2.Direction:Input */
    GPIO1->GDIR &= ~(1 << 26);

    /* 3.Enable GPIO Clock */
    CCM_CCGR1 |= (0x3 << 26);
}

/* 4.GPIO pad status */
int is_key_press() {
    int level = GPIO1->PSR & (1 << 26);
    return level == 0 ? 1 : 0; // 被按下，上拉电阻为低电平
}

void key_test() {
    key_init();
    led_init(); // led灯也要初始化

    while(1) {
        if(is_key_press()) led_on();
        else led_off();
    }
} 
```

# 3. 编译运行结果展示

- 使用ckermit软件进行开发板与linux系统的通讯，将编译的执行文件发送到开发板上
  ![请添加图片描述](https://img-blog.csdnimg.cn/direct/10b5382476a44da5aff16e3cf343d4d2.gif)
