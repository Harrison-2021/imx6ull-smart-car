# 一、硬件原理图分析

![图片描述](https://img.mukewang.com/wiki/63f897480945dc2d12800689.jpg)

![图片描述](https://img.mukewang.com/wiki/63f8975a08b04d3407570163.jpg)



# 二、GT911介绍

GT911 是专为 7”~8”设计的新一代 5 点电容触控方案，拥有 26 个驱动通道和 14 个感应通道，以满足更高的 touch 精度要求。 GT911 可同时识别 "5 个触摸点"位的实时准确位置，移动轨迹及触摸面积。并可根据主控需要，读取相应点数的触摸信息。

通讯接口

 **标准 I2C 通讯接口**

 从设备工作模式

 **支持 1.8V~3.3V 接口电平**



## 1.GT911从机地址

GT911 的 I 2C 从设备地址有两组，分别为 **0xBA/0xBB 和 0x28/0x29**。

<font color=green>**主控在上电初始化时控制 Reset 和 INT （中断）口状态进行设定**，</font>设定方法及时序图如下：



### **设定地址为 0x28/0x29 的时序**

![图片描述](https://img.mukewang.com/wiki/63f897a409c0cd7f12800373.jpg)



### **设定地址为 0xBA/0xBB 的时序**

![图片描述](https://img.mukewang.com/wiki/63f897b2092bddd512800371.jpg)



## 2.IIC总线读写寄存器



### **对 GT911写操作**

![图片描述](https://img.mukewang.com/wiki/63f897ca09845eb612800168.jpg)

![图片描述](https://img.mukewang.com/wiki/63f897ed082c755107530330.jpg)

> 设定了写操作寄存器首地址后，**可以只写 1 字节数据，也可以一次性写入多个字节数据，GT9 系列自动将其往高地址顺序存储**。



### 对GT911读操作

![图片描述](https://img.mukewang.com/wiki/63f8980d095e4b1e12800244.jpg)

**Address_R：带读控制位的从设备地址**。

**NACK：最后 1 字节读完主控回 NACK**。

- 设定了读操作寄存器地址后，**主控可以一次读取 1 字节，也可以一次性读取多个字节数据，GT91XX 自动递增寄存器地址，将后续数据顺序发送**。
- **设定完读操作寄存器地址后的停止信号（上图中的第一个 E 信号）可发可不发，但是重新开始 I 2C 通信 的起始信号必须再次发送**。



## 3.GT911重点寄存器介绍



### (1)Product ID

![图片描述](https://img.mukewang.com/wiki/63f89820098fb61712800148.jpg)



### (2)**实时命令（Write Only）**

![图片描述](https://img.mukewang.com/wiki/63f89830090bbc4312800163.jpg)



### (3)判断是否被触摸

![图片描述](https://img.mukewang.com/wiki/63f8983f0916925812800051.jpg)

- 当我们触摸屏幕时,寄存器0x814E的**最高位(bit7)位会被置位为1,** **低4位为触摸的点的数量, 最多支持5个点**。我们只要在**while中不断轮询判断**, 寄存器最高位是否置位,就可以知道, 屏幕是否被触摸
- <font color=green>**INT引脚会输出一个边沿信号**</font>, 我们只要在单片机中, 设置对应的连接引脚为中断引脚, 就可以实时知道屏幕是否被触摸
  - 当手指按下的时候，"buffer status"会置1且"number of touch points"有值
  - 当手指抬起的时候，"buffer status"会置1且"number of touch points"值为0

> **注意**
>
>  <font color="#fd6f01">**当我们读完寄存器0x814E后, 要清0该寄存器, 表示已读, 要不然他会不断输出中断信号。**</font>



### (4)获取触摸坐标点数据

![图片描述](https://img.mukewang.com/wiki/63f898520914ac6707781280.jpg)

**每个位置信息都由16+16+16位数据表示,** 

- **第一个16位是x的位置数据**,
- **第二个16位是y的位置数据**,
- **第三个是位置上的触摸面积**。
- **每个16位又由两个寄存器的8位数据构成,先是低8位,后是高8位。****



# 三、获取触摸坐标



## 1.编程思路

### (1)初始化GT911管脚

![图片描述](https://img.mukewang.com/wiki/63f8975a08b04d3407570163.jpg)

```c
void gt911_pin_init(void)
{
    /*SCL*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);
    
    /*SDA*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);

    IOMUXC_I2C2_SCL_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT |= (0x2 << 0);

    IOMUXC_I2C2_SDA_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SDA_SELECT_INPUT |= (0x2 << 0);

    /*touch interrupt*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO5_IO09 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO5_IO09 |=  (0x5 << 0);

    /*touch reset*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09 |=  (0x5 << 0);

}
 
```



### (2)复位GT911芯片，设置从机地址

![图片描述](https://img.mukewang.com/wiki/63f897b2092bddd512800371.jpg)

```c
void gt911_init_slave_addrress(void)
{
    /*
     *1.reset pin output low level
     *  interrupt pin output low level
     *
     */
    GPIO1->GDIR |= (1 << 9);
    GPIO5->GDIR |= (1 << 9);
    GPIO1->DR   &= ~(1 << 9);
    GPIO5->DR   &= ~(1 << 9);
    gpt_delay_us(10);

    /*
     2.interrupt pin output low level > 100us
       reset pin output high level
    */
    GPIO5->DR   &= ~(1 << 9);
    gpt_delay_us(200);
    GPIO1->DR   |= (1 << 9);

    /*
     3.interrupt pin output low level > 5ms
       interrupt pin input state
    */
    GPIO5->DR   &= ~(1 << 9);
    gpt_delay_ms(10);
    GPIO5->GDIR &= ~(1 << 9);

    gpt_delay_ms(100);

    return;
}
```



### (3)初始化IIC2控制器

```c
void gt911_init(void)
{
    gt911_pin_init();
    gt911_init_slave_addrress();
    iic_con_init(I2C2);
     
     return;
 }

```



### (4)编写GT911内部寄存器写函数

```c
#define GT911_SLAVE_ADDR_WRITE 0xBA

void gt911_write_register(uint16_t regaddr,uint8_t regval)
{
    int ret;
    uint8_t tx_buf[] = {regaddr >> 8,regaddr & 0xff,regval};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,GT911_SLAVE_ADDR_WRITE);
    
    //3.发送寄存器地址和数据
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.发送stop信号
    iic_con_send_stop(I2C2);

    return;
}

```



### (5)编写GT911内部寄存器读函数

```c
#define GT911_SLAVE_ADDR_READ  0xBB

uint8_t gt911_read_register(uint16_t regaddr)
{
    int ret;
    uint8_t rx_buf[1];
    uint8_t tx_buf[] = {regaddr >> 8,regaddr & 0xff};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,GT911_SLAVE_ADDR_WRITE);

    //3.发送寄存器地址
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.重新发送开始信号
    iic_con_send_repeat_start(I2C2);
    
    //7.发送从机地址 + read
    iic_con_send_slave_addr(I2C2,GT911_SLAVE_ADDR_READ);

    //8.读取从机数据
    iic_con_read_data(I2C2,rx_buf,sizeof(rx_buf));

    //9.发送stop信号
    iic_con_send_stop(I2C2);

    return rx_buf[0];
}

```



### (6)读取GT911的产品ID

```c
void read_gt911_product_id(void)
{
    int i = 0;
    uint8_t product_id[4];

    for(i = 0;i < 4;i ++){
        product_id[i] = gt911_read_register(GT911_PRODUCT_ID_ADDR + i);
        gpt_delay_ms(1);
    }

    uart_printf("product id hex : ");
    for(i = 0;i < 4;i ++){
        uart_printf("%x ",product_id[i]);
    }
    uart_printf("\r\n");

    uart_printf("product id str: GT%s\r\n",product_id);

    return;
}

```



### (7)初始化GT911 中断

```c
void gt911_interrupt_init(void)
{
    /*interrupt trigger 
      ICR9 [19–18]  10 RISING_EDGE — Interrupt n is rising-edge sensitive.
    */
    GPIO5->ICR1 &= ~(0x3 << 18);
    GPIO5->ICR1 |=  (0x2 << 18);

    /*Enable GPIO5_09 Interrupt*/
    GPIO5->IMR |= (1 << 9);

    /*Clear GPIO5_09 Interrupt Statu*/
    GPIO5->ISR |= (1 << 9);

    request_irq(GPIO5_Combined_0_15_IRQn,gt911_interrupt_handler);
    enable_irq();

    return;
}

```



### (8)设置GT911触摸点个数

```c
void gt911_config_touch_number(uint32_t number)
{
    uint8_t real_touch_number;

    gt911_write_register(GT911_TOUCH_BUMBER_ADDR,number);
    gpt_delay_ms(1);
    real_touch_number = gt911_read_register(GT911_TOUCH_BUMBER_ADDR);
    gpt_delay_ms(1);

    uart_printf("Current touch number:%d\r\n",real_touch_number);

    return;
}
```



### (9)发送实时命令，开启触摸坐标测量

```c
void gt911_send_real_cmd(uint8_t cmd)
{
    gt911_write_register(GT911_REAL_CMD_ADDR,cmd);
    gpt_delay_ms(1);

    return;
}

```



### (10)产生触摸中断，在中断处理函数中读取坐标

```c
void gt911_init(void)
{
    gt911_pin_init();
    gt911_init_slave_addrress();
    iic_con_init(I2C2);
    gt911_interrupt_init();
    gt911_config_touch_number(5);
    gt911_send_real_cmd(0x0);

    return;
}

int  gt911_interrupt_handler(int id)
{
    uint8_t status;

    /*Clear GPIO5_09 Interrupt Statu*/
    GPIO5->ISR |= (1 << 9);

    status = read_gt911_touch_status();

    //Bit7: Buffer status，
    //      1 表示坐标（或按键）已经准备好，主控可以读取；
    //      0 表示未就绪，数据无效。
    if(status & (1 << 7)){
        //Bit3~0: Number of touch points, 屏上的坐标点个数
        int i,j;
        uint8_t value[6];
        int number = status & 0xf;
        
        if(number){
            uart_printf("touch press\r\n");
        }else{
            uart_printf("touch release\r\n");
        }

        for(i = 0;i < number;i ++){
            for(j = 0;j < 6;j ++){
                uint16_t point_addr = GT911_TOUCH_POINT_ADDR + i * 8;
                value[j] = gt911_read_register(point_addr + j);
                gpt_delay_ms(1);
            }
            uart_printf("X_%d : %d\r\n",i + 1,(value[1] << 8) | value[0]);
            uart_printf("Y_%d : %d\r\n",i + 1,(value[3] << 8) | value[2]);
            uart_printf("S_%d : %d\r\n",i + 1,(value[5] << 8) | value[4]);

            uart_printf("------------------------------\r\n");
        }

   
    }

    return;
}

```



## 2.完整代码

```c
#include "imx6ull.h"

#define GT911_SLAVE_ADDR_WRITE 0xBA
#define GT911_SLAVE_ADDR_READ  0xBB

#define GT911_PRODUCT_ID_ADDR 0x8140
#define GT911_TOUCH_BUMBER_ADDR 0x804C
#define GT911_TOUCH_STATUS 0x814E
#define GT911_TOUCH_POINT_ADDR 0x8150

#define GT911_REAL_CMD_ADDR 0x8040

void gt911_pin_init(void)
{
    /*SCL*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO30 |=  (0x2 << 0) | (1 << 4);
    
    /*SDA*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO31 |=  (0x2 << 0) | (1 << 4);

    IOMUXC_I2C2_SCL_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SCL_SELECT_INPUT |= (0x2 << 0);

    IOMUXC_I2C2_SDA_SELECT_INPUT &= ~(0x3 << 0);
    IOMUXC_I2C2_SDA_SELECT_INPUT |= (0x2 << 0);

    /*touch interrupt*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO5_IO09 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO5_IO09 |=  (0x5 << 0);

    /*touch reset*/
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09 |=  (0x5 << 0);

}

void gt911_init_slave_addrress(void)
{
    /*
     *1.reset pin output low level
     *  interrupt pin output low level
     *
     */
    GPIO1->GDIR |= (1 << 9);
    GPIO5->GDIR |= (1 << 9);
    GPIO1->DR   &= ~(1 << 9);
    GPIO5->DR   &= ~(1 << 9);
    gpt_delay_us(10);

    /*
     2.interrupt pin output low level > 100us
       reset pin output high level
    */
    GPIO5->DR   &= ~(1 << 9);
    gpt_delay_us(200);
    GPIO1->DR   |= (1 << 9);

    /*
     3.interrupt pin output low level > 5ms
       interrupt pin input state
    */
    GPIO5->DR   &= ~(1 << 9);
    gpt_delay_ms(10);
    GPIO5->GDIR &= ~(1 << 9);

    gpt_delay_ms(100);

    return;
}

void gt911_write_register(uint16_t regaddr,uint8_t regval)
{
    int ret;
    uint8_t tx_buf[] = {regaddr >> 8,regaddr & 0xff,regval};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,GT911_SLAVE_ADDR_WRITE);
    
    //3.发送寄存器地址和数据
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.发送stop信号
    iic_con_send_stop(I2C2);

    return;
}

uint8_t gt911_read_register(uint16_t regaddr)
{
    int ret;
    uint8_t rx_buf[1];
    uint8_t tx_buf[] = {regaddr >> 8,regaddr & 0xff};

    //1.产生start信号
    iic_con_send_start(I2C2);
    
    //2.发送从机地址 + write
    iic_con_send_slave_addr(I2C2,GT911_SLAVE_ADDR_WRITE);

    //3.发送寄存器地址
    iic_con_send_data(I2C2,tx_buf,sizeof(tx_buf));

    //4.重新发送开始信号
    iic_con_send_repeat_start(I2C2);
    
    //7.发送从机地址 + read
    iic_con_send_slave_addr(I2C2,GT911_SLAVE_ADDR_READ);

    //8.读取从机数据
    iic_con_read_data(I2C2,rx_buf,sizeof(rx_buf));

    //9.发送stop信号
    iic_con_send_stop(I2C2);

    return rx_buf[0];
}

void read_gt911_product_id(void)
{
    int i = 0;
    uint8_t product_id[4];

    for(i = 0;i < 4;i ++){
        product_id[i] = gt911_read_register(GT911_PRODUCT_ID_ADDR + i);
        gpt_delay_ms(1);
    }

    uart_printf("product id hex : ");
    for(i = 0;i < 4;i ++){
        uart_printf("%x ",product_id[i]);
    }
    uart_printf("\r\n");

    uart_printf("product id str: GT%s\r\n",product_id);

    return;
}

uint8_t read_gt911_touch_status(void)
{
    uint8_t status = gt911_read_register(GT911_TOUCH_STATUS);
    gpt_delay_ms(1);
    gt911_write_register(GT911_TOUCH_STATUS,0);
    gpt_delay_ms(1);

    return status;
}

int  gt911_interrupt_handler(int id)
{
    uint8_t status;

    /*Clear GPIO5_09 Interrupt Statu*/
    GPIO5->ISR |= (1 << 9);

    status = read_gt911_touch_status();

    //Bit7: Buffer status，
    //      1 表示坐标（或按键）已经准备好，主控可以读取；
    //      0 表示未就绪，数据无效。
    if(status & (1 << 7)){
        //Bit3~0: Number of touch points, 屏上的坐标点个数
        int i,j;
        uint8_t value[6];
        int number = status & 0xf;
        
        if(number){
            uart_printf("touch press\r\n");
        }else{
            uart_printf("touch release\r\n");
        }

        for(i = 0;i < number;i ++){
            for(j = 0;j < 6;j ++){
                uint16_t point_addr = GT911_TOUCH_POINT_ADDR + i * 8;
                value[j] = gt911_read_register(point_addr + j);
                gpt_delay_ms(1);
            }
            uart_printf("X_%d : %d\r\n",i + 1,(value[1] << 8) | value[0]);
            uart_printf("Y_%d : %d\r\n",i + 1,(value[3] << 8) | value[2]);
            uart_printf("S_%d : %d\r\n",i + 1,(value[5] << 8) | value[4]);

            uart_printf("------------------------------\r\n");
        }

   
    }

    return;
}

void gt911_interrupt_init(void)
{
    /*interrupt trigger 
      ICR9 [19–18]  10 RISING_EDGE — Interrupt n is rising-edge sensitive.
    */
    GPIO5->ICR1 &= ~(0x3 << 18);
    GPIO5->ICR1 |=  (0x2 << 18);

    /*Enable GPIO5_09 Interrupt*/
    GPIO5->IMR |= (1 << 9);

    /*Clear GPIO5_09 Interrupt Statu*/
    GPIO5->ISR |= (1 << 9);

    request_irq(GPIO5_Combined_0_15_IRQn,gt911_interrupt_handler);
    enable_irq();

    return;
}

void gt911_config_touch_number(uint32_t number)
{
    uint8_t real_touch_number;

    gt911_write_register(GT911_TOUCH_BUMBER_ADDR,number);
    gpt_delay_ms(1);
    real_touch_number = gt911_read_register(GT911_TOUCH_BUMBER_ADDR);
    gpt_delay_ms(1);

    uart_printf("Current touch number:%d\r\n",real_touch_number);

    return;
}

void gt911_send_real_cmd(uint8_t cmd)
{
    gt911_write_register(GT911_REAL_CMD_ADDR,cmd);
    gpt_delay_ms(1);

    return;
}

void gt911_init(void)
{
    gt911_pin_init();
    gt911_init_slave_addrress();
    iic_con_init(I2C2);
    gt911_interrupt_init();
    gt911_config_touch_number(5);
    gt911_send_real_cmd(0x0);

    return;
}

void gt911_test(void)
{
    gt911_init();

    while(1){
      //  read_gt911_product_id();
      //  gpt_delay_sec(1);
    }

    return;
}

```



# 四、关于GT911的初始化序列

```c
// The version number of the configuration file
#define GOODIX_REG_CONFIG_DATA  0x8047

/* Private variables ---------------------------------------------------------*/
static uint8_t GT911_Config[] = {
0x81, 0x00, 0x04, 0x58, 0x02, 0x0A, 0x0C, 0x20, 0x01, 0x08, 0x28, 0x05, 0x50, // 0x8047-0x8053
0x3C, 0x0F, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8054-0x8060
0x00, 0x89, 0x2A, 0x0B, 0x2D, 0x2B, 0x0F, 0x0A, 0x00, 0x00, 0x01, 0xA9, 0x03, // 0x8061-0x806D
0x2D, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, // 0x806E-0x807A
0x59, 0x94, 0xC5, 0x02, 0x07, 0x00, 0x00, 0x04, 0x93, 0x24, 0x00, 0x7D, 0x2C, // 0x807B-0x8087
0x00, 0x6B, 0x36, 0x00, 0x5D, 0x42, 0x00, 0x53, 0x50, 0x00, 0x53, 0x00, 0x00, // 0x8088-0x8094
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8095-0x80A1
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80A2-0x80AD
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, // 0x80AE-0x80BA
0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, // 0x80BB-0x80C7
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80C8-0x80D4
0x02, 0x04, 0x06, 0x08, 0x0A, 0x0F, 0x10, 0x12, 0x16, 0x18, 0x1C, 0x1D, 0x1E, // 0x80D5-0x80E1
0x1F, 0x20, 0x21, 0x22, 0x24, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, // 0x80E2-0x80EE
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80EF-0x80FB
0x00, 0x00, 0xD6, 0x01 }; // 0x80FC - 0x8100

typedef struct{
        uint16_t X_Resolution;
        uint16_t Y_Resolution;
        uint8_t Number_Of_Touch_Support;
        bool ReverseX;
        bool ReverseY;
        bool SwithX2Y;
        bool SoftwareNoiseReduction;
}GT911_Config_t;

/* API Implementation --------------------------------------------------------*/
void  GT911_Config_Init(void)
{
        GT911_Config_t config ={
            .X_Resolution = 480,
            .Y_Resolution = 272, 
            .Number_Of_Touch_Support = 1,
            .ReverseY = true,
            .ReverseX = true,
            .SwithX2Y = false,
            .SoftwareNoiseReduction = true
        };
    
        //Set X resolution
        GT911_Config[1] = config.X_Resolution & 0x00FF;
        GT911_Config[2] = (config.X_Resolution >> 8) & 0x00FF;
        //Set Y resolution
        GT911_Config[3] = config.Y_Resolution & 0x00FF;
        GT911_Config[4] = (config.Y_Resolution >> 8) & 0x00FF;
        //Set touch number
        GT911_Config[5] = config.Number_Of_Touch_Support;
        //set reverse Y
        GT911_Config[6] = 0;
        GT911_Config[6] |= config.ReverseY << 7;
        //set reverse X
        GT911_Config[6] |= config.ReverseX << 6;
        //set switch X2Y
        GT911_Config[6] |= config.SwithX2Y << 3;
        //set Sito
        GT911_Config[6] |= config.SoftwareNoiseReduction << 2;
        
        //Reset chip
        reset_gt911();
        
        GT911_Send_Config(1);
}

/*
        配置gt911，发送gt911配置参数
        参数1：mode（0:参数不保存到flash
                    1:参数保存到flash）
*/
void GT911_Send_Config(uint8_t mode)
{
        uint8_t i;
        uint8_t buf[2];
        uint8_t tx_buf[1024];
        
        buf[0] = 0;
        buf[1] = mode;//是否写入到GT911 FLASH?  即是否掉电保存
        for(i=0; i < sizeof(GT911_Config); i++)
        {
                buf[0] += GT911_Config[i];//计算校验和
        }
        buf[0]=(~buf[0])+1;

        //寄存器开始地址
        tx_buf[0] = (GOODIX_REG_CONFIG_DATA & 0xFF00) >> 8;
        tx_buf[1] = GOODIX_REG_CONFIG_DATA & 0xFF;
        
        //数据
        memcpy(&tx_buf[2], GT911_Config, sizeof(GT911_Config));
        gt911_i2c_write(tx_buf,sizeof(GT911_Config) + 2);//发送寄存器配置
       
        //校验
        gt911_i2c_write(buf, 2);//写入校验和,和配置更新标记
        
        return;
}

```