# 一、单总线介绍
- 1-wire单总线是`Maxim`全资子公司`Dallas`的一项专有技术。
- 与目前多数标准串行数据通信方式，如SPI 、I2C不同，它采用==单根信号线==，**`既传输时钟，又传输数据`**，而且**`数据传输是双向的`**
- 它具有**`节省I/O口线资源`**、**`结构简单、成本低廉、便于总线扩展和维护`**等诸多优点。

- 1-wire单总线适用于==单个主机系统==，能够**`控制一个或多个从机设备`**。
- 当只有一个从机位于总线上时，系统可按照**`单节点`系统**操作；而当多个从机位于总线上时，则系统按照**`多节点`系统**操作。

- 每一个符合`OneWire`协议的**`从芯片都有一个唯一的地址`**，包括==48位的序列号==、==8位的家族代码==和==8位的CRC代码==。
- 主芯片对各个从芯片的寻址依据这`64`位的不同来进行。

- 单总线利用一根线实现双向通信。因此其协议对==时序的要求较严格==，**`如应答等时序都有明确的时间要求`**。
- **基本的时序包括**：==复位、应答时序、写1位时序、读1位时序==。
- **在复位及应答时序中**，主器件发出复位信号后，**要求从器件在`规定的时间内送回应答信号`**；
- **在位读和位写时序中**，**主器件要在`规定的时间内`读出或写入数据**。

# 二、`DS18B20`介绍
- The `DS18B20` uses Dallas `exclusive 1-Wire bus protocol` that implements bus communication `using one control signal`. 
- The control line requires a `weak pullup resistor` since all devices are linked to the bus via a `3-state or open-drain port `(the` DQ pin in the case of the DS18B20`). 
- In this bus system, the `microprocessor `(the master device) `identifies and addresses devices` on the bus using each device’s `unique 64-bit code`. Because each device has a unique code, the number of devices that can be addressed on one bus is `virtually unlimited`.

>- DS18B20采用达拉斯独有的==单线总线协议==，使用一个控制信号实现总线通信。
>- 控制线需要一个==弱上拉电阻==，因为所有设备都通过==三态或漏极端口（DS18B20中的DQ引脚）连接到总线==。
>- 在该总线系统中，微处理器（主设备）使用==每个设备唯一的64位代码识别和寻址总线上的设备==。由于每个设备都有唯一的代码，因此可以在一条总线上寻址的设备数量几乎是无限的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fe6421be2a8c41e8abdc270e304ba1d5.png)
- Another feature of the DS18B20 is the `ability to operate without an external power supply`. 
- Power is `instead supplied` through the 1-Wire pullup resistor `via the DQ pin` when the bus is high. 
- The high bus signal also `charges` an `internal capacitor (CPP)`, which then supplies power to the device when the bus is low. 
- This method of deriving power from the 1-Wire bus is `referred to as “parasite power.” `As an `alternative`, the DS18B20 may also be powered by an external supply on VDD

>- DS18B20的另一个特点是能够在没有外部电源的情况下运行。
>- **当总线为高电平时**，==电源通过DQ引脚通过1-Wire上拉电阻供电==。
>- **高总线信号还为内部电容器（CPP）充电，然后在总线为低电平时为器件供电**。
>- 这种从1-Wire总线获取电源的方法被称为“==寄生电源==”。作为替代方案，**DS18B20也可以由VDD上的外部电源供电**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8d485601c7dc467696d9184c48653085.png)
# 三、`MEASURING TEMPERATURE`(温度测量)
- The core functionality of the DS18B20 is its `direct-to-digital temperature sensor`. 
- The resolution of the temperature sensor is user-configurable to `9, 10, 11, or 12 bits`, corresponding to increments of `0.5℃, 0.25℃, 0.125℃, and 0.0625℃`, respectively. The `default resolution at power-up is 12-bit.` 
- The DS18B20 powers-up `in a low-power idle state`; to initiate a temperature measurement and A-to-D conversion, `the master must issue a Convert T [44h] command`. Following the conversion, the resulting thermal data is stored `in the 2-byte temperature register in the scratchpad memory` and` the DS18B20 returns to its idle state`.

>- DS18B20的核心功能是其**直接数字温度传感器**。
>- 温度传感器的分辨率可由用户配置为9、10、11或12位，分别对应0.5℃、0.25℃、0.125℃和0.0625℃的增量。==上电时的默认分辨率为12位==。
>- DS18B20**在低功耗空闲状态下`上电`；要启动温度测量和A到D转换，主机必须发出`转换T[44h]命令`**。转换后，**生成的热数据存储在`2字节温度寄存器中在暂存器`中，DS18B20返回其空闲状态**。

- The temperature data is stored as a `16-bit sign-extended two’s complement number` in the temperature register . 
- The sign `bits (S)` indicate if the temperature is `positive or negative`: for `positive numbers S = 0 `and for `negative numbers S = 1`. If the DS18B20 is configured `for 12-bit resolution`, all bits in the temperature register will contain `valid data`.

>- 温度数据在温度寄存器中存储为==16位符号扩展的二进制补码==。
>- 符号位（S）指示温度是正的还是负的：==对于正数S=0，对于负数S=1==。**如果DS18B20配置为12位分辨率，温度寄存器中的所有位都将包含有效数据**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/819d581b6ee04e869276492cd0b12cec.png)

>- **整数正数**：
>	- ==补码等于原码==
>	- 例如：+3
		补码[0011] -----> 原码[0011] 
>- **整数负数**：
>	- ==补码等于除去符号位的原码取反加1==
>	==原码等于除去符号位的补码取反加1==
>	- 例如：-3
		原码[1011]----->反码[1100] ----->补码[1101] 
		补码[1101]----->反码[1010] ----->原码[1011] 
>- **小数正数**：
>	- ==原码等于补码==
>	- 例如：3.75
>	原码[0011.1100]----->补码[0011.1100]
>- **小数负数**：
>	- ==补码等于原码除去符号位外，原码取反加1，后四位为小数位==
		==原码等于补码除去符号位外，补码取反加1，后四位为小数位==
>	- 例如：-1.25
>	原码[1001.0100] ---->反码[1110.1011]---->补码[1110.1100]
>	补码[1110.1100]----->反码[1001.0011]---->原码[1001.0100]
>- ==补码直接相加就是补码运算后的结果==
>	- 例如：-1.25 + 3.75 = 2.50;
		1110.1100 + 0011.1100 = 0010.1000 = 2.50;
>	- 例如：-1.25 -3 = -4.25
		1110.1100 + 1101.0000 = 1011.1100（补码） = 1100.0100 （原码）= -4.25


- For 11-bit resolution, bit 0 is undefined. For 10-bit resolution, bits 1 and 0 are undefined, and for 9-bit resolution bits 2, 1 and 0 are undefined. 
- Table 2 gives examples of digital output data and the corresponding temperature reading for `12-bit resolution conversions`.

>- **对于11位分辨率，位0是未定义的。对于10位分辨率，位1和0是未定义的，对于9位分辨率，位2、1和0是未定义的**。
>- 表2给出了12位分辨率转换的数字输出数据和相应温度读数的示例。

# 四、`DS18B20`操作过程
The **transaction sequence for accessing** the DS18B20 is as follows:
- Step 1. `Initialization`
- Step 2. `ROM Command`
- Step 3. `DS18B20 Function Command`

## 1.`INITIALIZATION`
- All transactions on the 1-Wire bus `begin with an initialization sequence`.
- The initialization sequence `consists` of a `reset pulse` transmitted by the bus master followed by `presence pulse(s)` transmitted by the slave(s). 
- The **presence pulse lets the bus master know that slave devices (such as the DS18B20) are on the bus and are ready to operate**.

>- 1-Wire总线上的所有事务都以==初始化序列开始==。
>- 初始化序列由总线主站发送的**`复位脉冲`**和从站发送的**`存在脉冲`**组成。
>- **`存在脉冲`**让总线主站知道从站设备（如DS18B20）**`在总线上并准备好运行`**。

## 2.`ROM COMMANDS`
- After the bus master has detected a presence pulse, it can issue a ROM command. 
- These commands `operate on the unique 64-bit ROM codes of each slave` device and allow the master to single out a specific device if many are present on the 1-Wire bus.

>- `总线主站检测到存在脉冲后，它可以发出ROM命令`。
>- 这些命令**`对每个从设备的唯一64位ROM代码进行操作`**，如果1-Wire总线上存在许多设备，则允许主站单独选择特定设备。

- SEARCH ROM [F0h]
- ==READ ROM [33h]==
- MATCH ROM [55h]
- ==SKIP ROM [CCh]==
- ALARM SEARCH [ECh]
### (1)`READ ROM [33h]`
- This command can `only be used when there is one slave` on the bus. It allows the bus master to read the slave’s 64-bit ROM code `without using the Search ROM procedure`. 
- If this command is used when **there is more than one slave present on the bus, a data collision will occur** when all the slaves attempt to respond at the same time.

>- 此命令只能在`总线上有一个从站`时使用。**它允许`总线主机读取从站的64位ROM代码`，而无需使用搜索ROM过程**。
>- 如果**`在总线上有多个从站时使用此命令`，当所有从站尝试同时响应时，将发生`数据冲突`**。

- Each DS18B20 contains a unique 64–bit code stored in ROM.
- The `least significant 8 bits` of the ROM code `contain the DS18B20’s 1-Wire family code: 28h`. 
- The `next 48 bits contain a unique serial number`. 
- The most significant 8 bits contain a `cyclic redundancy check (CRC) `byte that is calculated from the first 56 bits of the ROM code.
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/26d058f65c41406e8a3031573a2910b4.png)

>- 每个DS18B20都包含一个存储在ROM中的唯一64位代码。
>- ROM代码的**`最低有效8位包含DS18B20的1-Wire系列代码`**：`28h`。
>- 接下来的48位包含一个唯一的`序列号`。
>- 最高有效8位包含一个==循环冗余码检测（CRC）字节==，**该字节是从ROM代码的前56位计算出来的。**

>- DS18B20的==CRC校验多项式==如下:
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fc5cab94238c4d1dbc4a133018bc34ad.png)
- [CRC校验如何计算视频](https://www.bilibili.com/video/BV1V4411Z7VA/)
- [在线CRC校验](http://www.ip33.com/crc.html)
### (2)`SKIP ROM [CCh]`
- The master can use this command to `address all devices on the bus simultaneously` without sending out any ROM code information.
-  For example, the master can make all DS18B20s on the bus perform simultaneous temperature conversions by issuing a Skip ROM command followed by a `Convert T [44h] command.`

>- 主机可以使**用此命令`同时寻址总线上的所有设备`，而`无需发送任何ROM代码信息`**。
>- 例如，主机可以**通过`发出跳过ROM命令后跟转换T[44h]命令来使总线上的所有DS18B20同时执行温度转换`**。

## 3.`FUNCTION COMMANDS`
- After the bus master has used a `ROM command to address the DS18B20 with which it wishes to communicate`, the master can `issue one of the DS18B20 function commands`.

>- 总线主站使用ROM命令寻址它希望与之通信的DS18B20后，主站可以发出DS18B20`功能命令`之一。

- `CONVERT T [44h]`
- WRITE SCRATCHPAD [4Eh]
- `READ SCRATCHPAD [BEh]`
- COPY SCRATCHPAD [48h]
- RECALL E2 [B8h]
- READ POWER SUPPLY [B4h]
### (1)`CONVERT T [44h]`
- This command `initiates a single temperature conversion`.
- Following the conversion, the resulting thermal data is stored in the 2-byte temperature register in the `scratchpad memory` and the DS18B20 returns to its low-power idle state.

>- **此命令`启动单次温度转换`**。
>- 转换后，生成的热数据存储在**暂存内存**中的2字节`温度寄存器`中，DS18B20`返回低功耗空闲状态`。

### (2)`READ SCRATCHPAD [BEh]`
- This command allows the master to read the contents of the `scratchpad`. 
- The data transfer starts with the `least significant bit` of byte 0 and continues through the scratchpad until the `9th byte (byte 8 – CRC)` is read. 
- The master may `issue a reset` to `terminate reading` at any time if only part of the scratchpad data is needed.
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/166028a653084327874516d46a1c3d3f.png)
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/819d581b6ee04e869276492cd0b12cec.png)


>- 此命令允许主机读取暂存板的内容(`采样的温度值`）。
>- 数据搬迁从**字节0的最低有效位开始**，并继续通过暂存板，直到读取第9个字节（**字节8-CRC**）。
>- 如果只需要部分暂存板数据，**`主机可以随时发出重置以终止读取`**。

# 五、DS18B20操作时序
## 1.`INITIALIZATION PROCEDURE`
- All communication with the DS18B20 begins with an `initialization sequence` that consists of a `reset pulse` from the master followed by a `presence pulse` from the DS18B20. 
- When the DS18B20 sends the presence pulse in response to the reset, it is `indicating` to the master that it is on the bus and ready to operate.

>- 与DS18B20的所有通信都以==初始化序列==开始，该序列由主设备的==复位脉冲==和DS18B20的==存在脉冲==组成。
>- `当DS18B20响应复位发送存在脉冲时`，它向主设备表明它在总线上并准备好操作

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/529397d631e04a959efe8f8d05dcc685.png)
- During the initialization sequence the bus master transmits (TX) the reset pulse by `pulling the 1-Wire bus low` for a minimum of `480us`.
- The bus master then `releases the bus and goes into receive mode (RX)`. When the bus is released, the `5k pullup resistor pulls the 1-Wire bus high`.
- When the` DS18B20 detects this rising edge`, it waits `15us to 60us` and then `transmits a presence pulse` by `pulling the 1-Wire bus low for 60us to 240us`.

>- 在初始化序列中，总线主控器通过将1-Wire总线==拉低至少480秒==来发送复位脉冲。
>- 然后总线主控器**`释放总线并进入接收模式（RX）`**。当总线释放时，==5k上拉电阻将1-Wire总线拉高==。
>- 当DS18B20**检测到这种上升沿时**，它**等待`15us到60us`**，然后通过**将`1-Wire总线拉低60us到240us来发送存在脉冲`**。

## 2.`WRITE TIME SLOTS`
- There are `two types` of write time slots: `“Write 1”` time slots and `“Write 0”` time slots. 
- The bus master uses a Write 1 time slot to write a logic 1 to the DS18B20 and a Write 0 time slot to write a logic 0 to the DS18B20. 
- All write time slots must be a `minimum of 60us in duration` with a minimum of a `1us recovery time` between individual write slots. Both types of write time slots are `initiated by the master pulling the 1-Wire bus low` .

>- 有两种类型的写入时隙：**`“写入1”时隙和“写入0”时隙。`**
>- 总线主控器使用写入1时隙将逻辑1写入DS18B20，使用写入0时隙将逻辑0写入DS18B20。
>- 所有写入时隙的==持续时间至少为60us==，单个写入时隙之间的==恢复时间至少为1us==。这两种类型的写入时隙都是由主控器将==1-Wire总线拉低启动==的。

- **To generate a Write 1 time slot**, `after pulling the 1-Wire bus low`, the bus master `must release the 1-Wire bus within 15us`.When the bus is released, the 5k pullup resistor will pull the bus high. 
- **To generate a Write 0 time slot**, after pulling the 1-Wire bus low, the bus master must continue to hold the bus low for the duration of the time slot (`at least 60us`).
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/00c5d240ade04b4591936eb5a701a595.png)


>- **要产生写1时隙**，在将1-Wire总线拉低后，总线主机必须在==15us内释放1-Wire总线==。当总线释放时，5k上拉电阻将把总线拉高。
>- **要产生写0时隙**，在将1-Wire总线拉低后，总线主机必须在时隙==持续时间（至少60us==）内继续保持总线低电平。

- The DS18B20 **samples** the 1-Wire bus `during a window that lasts from 15us to 60us `after the master initiates the write time slot. 
- If the bus is `high` during the sampling window, a `1 `is written to the DS18B20. If the line is `low`, a `0` is written to the DS18B20.

>- DS18B20在主机启动写入时隙后的==15us到60us的窗口中对1-Wire总线进行采样==。
>- 如果在采样窗口中总线为==高电平==，则向DS18B20==写入1==。如果线路为==低电平==，则向DS18B20==写入0==。

## 3.`READ TIME SLOTS`
- The DS18B20 can only `transmit data to the master` when the `master issues read time slots`. 
- Therefore, the master must `generate read time slots` immediately `after issuing` a `Read Scratchpad [BEh]` or `Read Power Supply [B4h] command`, so that the DS18B20 can provide the requested data. 
- In addition, the master can generate read time slots after `issuing Convert T [44h] or Recall E2 [B8h] commands` to find out the `status of the operation` as explained in the DS18B20 FUNCTION COMMAND section.

>- DS18B20只有在**`主控机发出读取时隙时才能向主控机传输数据`**
>
>- 因此，主控机必须在**`发出读取记录板[BEh]或读取电源[B4h]命令后立即生成读取时隙`**，以便DS18B20能够提供所请求的数据。
>- 此外，主控机可以在发出**`转换T[44h]或召回E2[B8h]命令后生成读取时隙`**，以找出操作的状态，如DS18B20功能命令部分所述。

- All read time slots must be a `minimum of 60us` in duration with a minimum of a `1us recovery time` between slots. 
- A read time slot is initiated by the master device `pulling the 1-Wire bus low for a minimum of 1us` and `then releasing the bus` .

>- 所有读取时隙的**`持续时间必须至少为60us，时隙之间的恢复时间至少为1us。`**
>- 读取时隙由主设备**`将1-Wire总线拉低至少1us，然后释放总线启动`**。

- After the master initiates the read time slot, `the DS18B20 will begin transmitting a 1 or 0 on bus`.
- The `DS18B20 transmits a 1 by leaving the bus high and transmits a 0 by pulling the bus low`. 
- When **transmitting a 0, the DS18B20 will release the bus by the end of the time slot**, and the bus will be pulled back to its high idle state by the pullup resister. 
- `Outputdata` from the DS18B20 is `valid` for `15us` after the falling edge that initiated the read time slot. Therefore, `the master must release the bus` and then `sample the bus state within 15us` from the start of the slot.
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a599a7a1c3b54a5e903db7180788f8ce.png)

>- 当主机启动读取时隙后，**DS18B20将开始在总线上传输1或0**。
>- DS18B20通过将**总线保持在高电平来传输1，并通过将总线拉低来传输0**。
>- 当传输0时DS18B20将在时隙结束时释放总线，总线将被上拉电阻拉回其高空闲状态。
>- DS18B20的输出数据在==启动读取时隙的下降沿后对15us有效==。因此，**主机必须释放总线，然后从时隙开始在15us内对总线状态进行采样**。
>- (==即，主机端发送1us启动读信号后，从机设备开始写数据，主机端采样读取数据要在启动信号后的15us内读取从机传过来的值是0还是1，超过15us不一定有效==）

# 六、DS18B20硬件原理图分析
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/60186cde65df43e5b77a9905387ce884.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/330b09961d6940fc80a2293f577a2252.png)
# 七、GPIO控制器-模拟1-wire主设备信号
## 1.管脚初始化
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/da461624bce7407fb8357c779827ff11.png)

```c
void ds18b20_pin_init() {
    IOMUXC_SW_MUX_CTL_PAD_GPIO5_IO02 &= ~(0xf << 0);
    IOMUXC_SW_MUX_CTL_PAD_GPIO5_IO02 |= (0x5 << 0);
}
```

## 2.输入输出方向控制
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8f00feb0b3df41f482c7baa355417009.png)

```c
// Master read direction
void ds18b20_pin_input() {
    GPIO5->GDIR &= ~(1 << 2);
}

// Master write direction
void ds18b20_pin_output() {
    GPIO5->GDIR |= (1 << 2);
}
```

## 3.写入与读取输出电平

```c
// Master write level
void ds18b20_write_level(uint8_t level) {
    GPIO5->DR &= ~(1 << 2);
    GPIO5->DR |= (level << 2);
}

// Master read level
uint8_t ds18b20_read_level() {
    uint8_t level;
    level = GPIO5->PSR & (1 << 2);
    return level ? 1 : 0;
}
```
# 八、DS18B20相关操作函数接口
## 1.初始化探测DS18B20设备
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/529397d631e04a959efe8f8d05dcc685.png)
>- During the initialization sequence the bus master transmits (TX) the reset pulse by `pulling the 1-Wire bus low` for a minimum of `480us`.
>- The bus master then `releases the bus and goes into receive mode (RX)`. When the bus is released, the `5k pullup resistor pulls the 1-Wire bus high`.
>- When the` DS18B20 detects this rising edge`, it waits `15us to 60us` and then `transmits a presence pulse` by `pulling the 1-Wire bus low for 60us to 240us`.

> ==注意：==
>- 等待从机拉低总线的时间，**不能太短也不能太长**，
>  ==太长==，可能由于编程代码时间，错过了拉低过程，level接收的是从设备释放总线后拉高的电位，
>    ==太短==，可能从设备还没来得及拉低总线，level接收的是主设备释放总线后拉高的电位
>	- // wait slave detects this rising edge(`15us-60us`) and pull low `60us-240us`(60-300us)
>	- `gpt_delay_us(100);
    level = ds18b20_read_level();`
```c
/ master detecter slave
int ds18b20_detect() {
    uint8_t level;
    // simulate Resistor pullup
    ds18b20_pin_init();
    ds18b20_pin_output();
    ds18b20_write_level(ONEWIRE_HIGH);// 默认上拉电阻将总线拉高
    gpt_delay_us(10);

    // bus master pulling low minimum 480uss(至少480)
    ds18b20_write_level(ONEWIRE_LOW);
    gpt_delay_us(700);

    // releases the bus,and goes into receive mode (RX)
    // simulate Resistor pullup
    ds18b20_write_level(ONEWIRE_HIGH);
    ds18b20_pin_input();

    // wait slave detects this rising edge(15us-60us) and pull low 60us-240us
    gpt_delay_us(100);
    level = ds18b20_read_level();
    // 读取需要一点时间，读取完毕，再判断
    gpt_delay_us(200);
    if(level) {
        uart_printf("master detect failed!\r\n");
        return -1;
    } else {
        uart_printf("mastet detect succeed!\r\n");
    }
    return 0;
}

void ds18b20_test() {
    ds18b20_detect();
}
```
## 2.向DS18B20写入一个位
>- **To generate a Write 1 time slot**, `after pulling the 1-Wire bus low`, the bus master `must release the 1-Wire bus within 15us`.When the bus is released, the 5k pullup resistor will pull the bus high. 
>- **To generate a Write 0 time slot**, after pulling the 1-Wire bus low, the bus master must continue to hold the bus low for the duration of the time slot (`at least 60us`).
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/00c5d240ade04b4591936eb5a701a595.png)
>- The DS18B20 **samples** the 1-Wire bus `during a window that lasts from 15us to 60us `after the master initiates the write time slot. 
>- If the bus is `high` during the sampling window, a `1 `is written to the DS18B20. If the line is `low`, a `0` is written to the DS18B20.

```c
// master write 1 bit to ds18b20
void ds18b20_write_bit(uint8_t bit) {   
    if(bit){ // write 1 
        ds18b20_pin_output();
        ds18b20_write_level(ONEWIRE_LOW);
        gpt_delay_us(1); // within 15 us
        ds18b20_pin_input(); // released bus
        gpt_delay_us(70);// wait slave samples[15-60]
    } else { // write 0
        ds18b20_pin_output();
        ds18b20_write_level(ONEWIRE_LOW);
        gpt_delay_us(80);     // at least 60us
        ds18b20_pin_input(); // released bus
        gpt_delay_us(15); // wait slave samples[15-60]
    }
}
```

## 3.从DS18B20读取一个位
>- All read time slots must be a `minimum of 60us` in duration with a minimum of a `1us recovery time` between slots. 
>- A read time slot is initiated by the master device `pulling the 1-Wire bus low for a minimum of 1us` and `then releasing the bus` .
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a599a7a1c3b54a5e903db7180788f8ce.png)
>- After the master initiates the read time slot, `the DS18B20 will begin transmitting a 1 or 0 on bus`.
>- The `DS18B20 transmits a 1 by leaving the bus high and transmits a 0 by pulling the bus low`. 
>- When **transmitting a 0, the DS18B20 will release the bus by the end of the time slot**, and the bus will be pulled back to its high idle state by the pullup resister. 
>- `Outputdata` from the DS18B20 is `valid` for `15us` after the falling edge that initiated the read time slot. Therefore, `the master must release the bus` and then `sample the bus state within 15us` from the start of the slot.

```c
uint8_t ds18b20_read_bit() {
    uint8_t bit;
	// 主机拉低至少1us启动读取时隙
    ds18b20_pin_output();
    ds18b20_write_level(ONEWIRE_LOW);
    gpt_delay_us(5); // pulling the 1-Wire bus low for minimum of 1us
    ds18b20_pin_input(); // released bus
    
    gpt_delay_us(3); // master sample within 15us  
    bit = ds18b20_read_level();
    
    gpt_delay_us(60); // read next bit,读取时隙的持续时间必须至少为60us

    return bit;
}

```

## 4.向DS18B20写入一个字节
> ==从低位往高位写，与iiC不同，iiC 从高位往低位写==

```c
void ds18b20_write_byte(uint8_t data) {
    uint8_t i;
    uint8_t bit;
    for(i = 0; i < 8; i++) {
        bit = data & 1;
        ds18b20_write_bit(bit);
        data = data >> 1;
    }
}
```
## 5.从DS18B20读取一个字节

```c
uint8_t ds18b20_read_byte() {
    uint8_t data = 0; 
    uint8_t i;
    uint8_t bit;
    for(i = 0; i < 8; i++) {
        bit = ds18b20_read_bit();
        data = data | (bit << i);
    }
}
```
# 九、读取DS1B20的ID和采集的温度
## 1.读取ID
>- Each DS18B20 contains a unique 64–bit code stored in ROM.
>- The `least significant 8 bits` of the ROM code `contain the DS18B20’s 1-Wire family code: 28h`. 
>- The `next 48 bits contain a unique serial number`. 
>- The most significant 8 bits contain a `cyclic redundancy check (CRC) `byte that is calculated from the first 56 bits of the ROM code.
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/26d058f65c41406e8a3031573a2910b4.png)
>- DS18B20的==CRC校验多项式==如下:
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fc5cab94238c4d1dbc4a133018bc34ad.png)
>- [CRC校验如何计算视频讲解](https://www.bilibili.com/video/BV1V4411Z7VA/)
>- [在线CRC校验工具](http://www.ip33.com/crc.html)

> ==注意：==
> - 1.==gpt定时器，定时器模式要设置成重启模式==，否则比较计时器没有效果了
>	- /* 3.Select mode :Free-Run or Restart */
    >	- `GPT1->CR &= ~(1 << 9); // 要设置成重启模式，否则比较计时器没有效果了`
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/250334a0254c48f983ba08806a3a1336.png)
>- 2.==循环变量注意不能定义成uint8_t，uint8_t是无符号==,否则递减时，0减1成255，永远循环下去
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/01683480f23d475b9d904c3499d6e135.png)
```c
void ds18b20_read_id(int) {
    int i; // 注意不能定义成uint8_t，否则递减时，0减1成255，永远循环下去
    uint8_t ret;
    uint8_t id[8];

    // master detect slave
    ret = ds18b20_detect();
    if(ret < 0) {
        return;
    } 
    // write read command
    ds18b20_write_byte(READ_ROM);
    // uart_printf("test read:\r\n");
    for(i = 0; i < 8; i++) {
        id[i] = ds18b20_read_byte();
    }
    uart_printf("ID : H-L: ");
    for(i = 7; i >= 0; i--) {
        uart_printf("%x ",id[i]);
    }
    uart_printf("\r\n");
}
```

### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/58e104c5ada048d7a2f89e3c9a4cf96b.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/75402a221b2a47edaffc669979287d70.png)

## 2.读取温度

```c
void ds18b20_read_temperature() {
    int ret;
    uint8_t data[2];
    uint16_t temperature;
    uint8_t  low4bit;
    uint8_t  interger;
    uint8_t  temp[2];

    ret = ds18b20_detect();
    if(ret < 0){
        return;
    }
    ds18b20_write_byte(SKIP_ROM);//skip rom-主设备同时寻址所有从设备（ds18b20）
    ds18b20_write_byte(CONVERT_T);//转换命令
    
    gpt_delay_sec(1);// wait salve sample temperature

    ret = ds18b20_detect();
    if(ret < 0){
        return;
    }
    ds18b20_write_byte(SKIP_ROM);//skip rom
    ds18b20_write_byte(READ_SCR);//读取 SCRATCHPAD 

    data[0] = ds18b20_read_byte(); // low 8 bit
    data[1] = ds18b20_read_byte(); // high 8 bit

    uart_printf("Temp H:%x,Temp L:%x\r\n",data[1],data[0]);
    temperature = *((uint16_t *)data);

    low4bit  = temperature & 0xf; // [3-0]:decimal
    interger = temperature >> 4;  // [11-4]:interger
    if(interger & 0x80){//1000 0000 -负数，储存的是补码，需要换算成原码
        temperature = ~temperature + 1; // 最高符号位不参与换成10进制，因此可以直接取反加1
        temp[1] = temperature >> 4;
        temp[0] = temperature & 0xf; 

        //0.0625 x 10000 = 625-小数转为整数输出，eg.0001->0.0625->625
        uart_printf("temperature:-%d.%04d\r\n",temp[1],625 * temp[0]);
    }else{
        temp[1] = interger;
        temp[0] = low4bit;
        uart_printf("temperature:%d.%04d\r\n",temp[1],625 * temp[0]);
    }

    return;
}
```
### 结果展示
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e80f16e4e4144e548b0cb196a9945486.png)
